[TIL on December 14th, 2022](../../TIL/2022/12/12-14-2022.md)
# **Dynamic Programming**
- From 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 vol. 1

### Dynamic Programming (동적 계획법)
#### Introduction
- Developer of D.P., Richard E. Bellman just choose word 'dynamic' because it's charming
- Some subproblems could be used to solve more than one problem
  * Original statement: 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용하여 속도의 향상을 꾀할 수 있다.
- We can reduce an amount of calculation by reusing these calculation results
- Cache: a memory to save results already calculated
- Overlapping subproblems: calculated results used more than once
  * Original statement: 이미 계산한 값을 저장하는 메모리를 '캐시'라 하며, 두 번 이상 계산되는 부분 문제를 '중복되는 부분 문제'라고 부릅니다.

#### Referential transparency (참조적 투명성)
- A function is referential transparent if its return value only depends on input values
  * Original statement: 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 유식한 말로 참조적 투명성이라 부른다. 그리고 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들을 참조적 투명함수(referential transparent function)이라 부른다.
- Memoization could only be applied to referential transparent functions


### Memoization implementation
```cpp
const int MXA, MXB;
int cache[MXA][MXB]; // initialized as -1

int someObscureFunction(int a, int b) {
  // base case
  if(isBaseCase()) doSomething();
  if(cache[a][b] != -1) return cache[a][b];
  calculateSmallProblem();
}

int main() {
  int a, b; cin >> a >> b;
  memset(cache, -1, sizeof(cache));
  cout << someObscureFunction(a, b);
}
```




___

### References
1. [프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 vol. 1](https://www.google.co.kr/books/edition/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C_%ED%95%B4%EA%B2%B0_%EC%A0%84%EB%9E%B5_%EC%84%B8%ED%8A%B8/koK5NAEACAAJ?hl=en)