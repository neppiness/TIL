# **TIL on January 22nd, 2023**
### BOJ step by step: 유니온 파인드
#### [boj.kr/1976](../../../Problem%20Solving/boj/Union%20find/1976-01-21-2023.cpp): solved on 3rd try (memory: 2020 kB, time: 0 ms, Code length: 797 B)
* 예제에 대한 답이 나왔다고 정답이라 생각해버림.
  - 문제를 잘못 이해해서 인접 배열을 잘못 받음. 조심할 것.
* 2번째도 오답. 애초에 MST 문제와는 달리 merge를 완전히 분리시켜야 하고, 두 그룹이 다르다고 해서 merge를 해버리면 안 된다.


### S3 to G3 random defense
#### [boj.kr/10819](../../../Problem%20Solving/boj/random%20defense/10819-01-22-2023.cpp)
* next_permutation을 사용하여 모든 경우를 돌아봄.
  - `while(n--)`로 입력값을 받아놓고는 이후에 n을 사용했음. 이는 완전한 잘못. 주의할 것.
  
### BOJ step by step: 유니온 파인드
#### [boj.kr/4195](../../../Problem%20Solving/boj/Union%20find/4195-01-22-2023.cpp)
* 랭크를 사람 수로 갱신하면 무난하게 풀릴 듯함.

* 해쉬로 구현하니 메모리 초과.
  - 트라이로 구현해야 하는가?
  - 알파벳 대소문자를 사용하니 52개 문자고, 길이 20 이하의 문자열. 그렇게 많은 메모리가 들진 않을 것.

* 구종만 알고리즘 책에 나온 트라이 코드를 하나씩 살펴보자.

```cpp
const int ALPHABETS = 26;
int toNumber(char ch) { return ch - 'A'; }
struct TrieNode {
  TrieNode* children[ALPHABETS];
  bool terminal; // 종료 노드 여부
  TrieNode() : terminal(false) {
    memset(children, 0, sizeof(children));
  }
  ~TrieNode() {
    for(int i = 0; i < ALPHABETS; ++i)
      if(children[i]) delete children[i];
  }

  void insert(const char* key) {
    if(*key == 0) terminal = true;
    else {
      int nxt = toNumber(*key);
      if(children[nxt] == NULL)
        children[nxt] = new TrieNode();
      children[nxt] -> insert(key + 1);
    }
  }

  TrieNode* find(const char* key) {
    if(*key == 0) return this;
    int nxt = toNumber(*key);
    if(children[nxt] == NULL) return NULL;
    return children[nxt] -> find(key + 1);
  }
};
```

* toNumber 함수의 경우 알파벳 대소문자를 사용해야 하는 문제 풀이 시에는 아래와 같이 구현할 수 있을 것이다.

```cpp
int toNumber(char ch) {
  if(ch >= 'A' && ch <= 'Z') return ch - 'A'; // 0-25는 알파벳 대문자
  else return ch - 'a' + 26; // 26-51은 알파벳 소문자
}
```

