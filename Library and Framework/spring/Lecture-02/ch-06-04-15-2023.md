[TIL on April 15th, 2023](../../../TIL/2023/04/04-15-2023.md)
## 섹션 6. 컴포넌트 스캔

### 컴포넌트 스캔과 의존관계 자동 주입 시작하기
* 지금까지 스프링 빈을 등록할 때는 자바 코드의 @Bean이나 XML의 <bean> 등을 통해 설정 정보에 직접 등록할 스프링 빈 목록을 작성했다.
* 실무에서 이런 식으로 등록할 빈이 수십, 수백개가 되면 일일이 등록하기가 힘들다. 설정 정보도 커지고, 누락하는 문제도 발생된다.
* 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이 가능하다.

* `@ComponentScan`: 컴포넌트 스캔 어노테이션을 활용하면, `@Component`로 등록된 클래스를 찾아서 스프링 빈에 등록을 자동으로 해준다.
  - 다만, 설정을 해줄 것이 있는데, `@Configuration`도 역시 @Component가 붙은 어노테이션 인터페이스이기 때문에, 이를 제외시켜줘야 한다. 이를 위한 코드는 아래와 같다.
```java
@ComponentScan(
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)
)
```
  - 사실 보통은 이 설정이 필요 없지만, 우리가 이미 컴포넌트 스캔 없이 AppConfig를 하는 방식으로 작성해둔 코드가 있기 때문에 이를 보호하는 차원에서 설정하는 것이다.
  - 기존 AppConfig에서 작성했던 것과 다르게 그 안에 @Bean이라 설정할 게 하나도 없다.

* TestConfig에 그 테스트에서만 적용할 환경을 구성했었기 때문에, 이런 것도 등록이 되어버림에 유의해야 한다.

* 실무에서는 모두 컴포넌트 스캔을 통해서 설정할 수 있는 환경으로 구성한다. 그렇지 않으면 번거로워지니까.

* 생성자에 @Autowired라는 어노테이션을 붙인다. 이를 통해 MemberRepository에 해당하는 것을 찾아와서 자동으로 주입시켜준다. MemberServiceImpl 클래스를 수정한 코드는 아래와 같다.

```java
package hello.core.member;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository;

    @Autowired //ac.getBean(MemberRepository.class)를 통해 빈을 찾는 거라고 생각하면 된다.
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }

    // 테스트 용, 필드인 MemberRepository를 꺼내는 메소드.
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }
}
```

* 이전에 AppConfig에서는 @Bean 으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다. 이제는 이런 설정 정보 자체가 없기 때문에, 의존관계 주입도 이 클래스 안에서 해결해야 한다. @Autowired 는 의존관계를 자동으로 주입해준다. 자세한 룰은 조금 뒤에 설명하겠다.
  - 이에 관련된 룰이 몇 가지 있다고 함.
* @Autowired를 활용하면 여러 의존 관계도 한 번에 처리할 수 있다.

* 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자로 사용한다.
  - 빈 이름 기본 전략: `MemberServiceImpl` 클래스 `memberServiceImpl`
  - 빈 이름 직접 지정: 만약 스프링 빈의 이름을 직접 지정하고 싶으면 `@Component("memberService2")` 이런식으로 이름을 부여하면 된다.

* 같은 타입이 여러 개 있는 경우, 그러니까, 우리가 지금까지 구현했던 것 중에서 할인 정책 두 가지가 모두 빈의 @Component를 받은 상태라면 충돌이 일어나게 된다. 이에 대한 내용은 뒤에서 다룬다.
* 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
  - `getBean(MemberRepository.class)`와 동일하다 생각하면 된다.

* 생성자에 넣어야 하는 인자가 많아도 다 찾아서 주입시켜 준다.

> 정리: AutoAppConfig를 보면 다른 것 필요 없이 @Componentscan만 넣어주면 AppConfig에서 우리가 직접 작성했던 코드와 동일한 작업을 해준다.

<br>

### 탐색 위치와 기본 스캔 대상
* 탐색할 패키지의 기본 위치를 지정할 수가 있다. 그 구현 방식은 아래와 같다.
  - 이를 통해 자동으로 빈을 등록해보면, member 안에 있는 빈들만 가져올 수 있다.
  - 검색 위치를 지정해주면, 불필요한 검색을 피할 수 있다.
  
```java
@ComponentScan(
        basePackages = "hello.core.member",
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)
)
```

* 지정하지 않는 경우에는 어떻게 될까?
  - @ComponentScan 이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다
  - 즉, 이 예제의 경우에는 AutoAppConfig의 패키지인 hello.core에서 시작해서 하위 패키지를 다 찾게 된다.

* 권장하는 방법
  - 패키지 위치를 지정하지 않고, 설정 정보 크클래스의 위치를 프로젝트 최상단에 두는 것으로써 프로젝트 전 범위를 살펴볼 수 있게 설정하는 것을 권장한다.
  - 이런 방법을 권장하기 때문에 우리가 설정 파일을 둬야 하는 위치가 결정된다고 이해할 수 있을 듯.

* 프로젝트를 열었을 때, 설정 정보를 먼저 확인하는 게 당연하기 때문에, 이를 가장 최상단에 두는 것이 바람직하다고 함.

* 기본적으로 CoreApplication에 컴포넌트 스캔이 붙어있기 때문에 자동으로 빈으로 설정되는 거라 함.

#### 컴포넌트 스캔 기본 대상
* 컴포넌트 스캔은 `@Component` 뿐만 아니라, 다음과 같은 내용도 추가로 대상에 포함시킨다.
  - @Component: 컴포넌트 스캔에서 사용
  - @Controller: 스프링 MVC 컨트롤러에서 사용
  - @Service: 스프링 비즈니스 로직에 사용
  - @Repository: 저장소, 스프링 데이터 접근 계층에서 사용
  - @Configuration: 스프링 설정 정보에서 사용

* 해당 클래스의 소스 코드를 보면 `@Componente`를 포함하고 있는 것을 알 수 있다.

> 참고: 어노테이션은 상속관계라는 게 없다. 그래서 이렇게 어노테이션이 특정 어노테이션을 상속한 것으로 인식되는 건 자바 언어의 기본 지원 기능이 아니라, 스프링을 통해 구현된 기능이다.

* 컴포넌트 스캔의 용도 뿐만 아니라, 다음 어노테이션이 있으면 스프링은 부가 기능을 수행한다.
  - @Controller : 스프링 MVC 컨트롤러로 인식
  - @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 *스프링 예외로 변환해준다.*
  - @Configuration : 앞서 보았듯이 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
  - @Service : 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.
* 위의 모든 어노테이션은 컴포넌트 어노테이션의 자식이라 생각할 수 있다. 컴포넌트의 역할을 하면서 추가 기능을 수행하도록 만들어진 자식 어노테이션.


<br>

### 필터
* `includeFilters`: 컴포넌트 스캔 대상을 추가로 지정한다.
* `excludeFilters`: 컴포넌트 스캔에서 제외할 대상을 지정한다.

* `includeFilters`에 `MyIncludeComponent` 어노테이션을 추가해서 BeanA가 스프링 빈에 등록된다.
* `includeFilters`에 `MyIncludeComponent` 어노테이션을 추가해서 BeanA가 스프링 빈에 등록된다.

#### FiterType 옵션
* FilterType은 5가지 옵션이 있다.
  - ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다: ex) org.example.SomeAnnotation
  - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다. ex) org.example.SomeClass
  - ASPECTJ: AspectJ 패턴 사용. ex) org.example..*Service+
  - REGEX: 정규 표현식, ex) org\.example\.Default.*
  - CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리, ex) org.example.MyTypeFilter

* 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기보다는 스프링의 기본 설정에 최대한 맞춰 사용하는 것을 권장함.

<br>

### 중복 등록과 충돌
* 두 가지 상황으로 나뉜다.

#### 자동 빈 등록 vs. 자동 빈 등록
* 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
  - `ConflictingBeanDefinitionException` 발생
* 오류 메시지도 잘 다듬어놨음. 디버깅하기 매우 편리한다.

#### 수동 빈 등록 vs. 자동 빈 등록
* 만약 수동 빈 등록과 자동 빈 등록에서 빈 이름이 충돌하면 어떻게 될까?

```java
public class AutoAppConfig {
    
    @Bean(name = "memoryMemberRepository")
    MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}
```

* 위와 같은 AutoAppConfig를 만들었다고 하자. 이 경우, MemoryMemberRepository가 memoryMemberRepository의 이름을 가질 것이기 때문에, 이와 같이 설정하면 중복이 일어난다.
  - 수동 빈 등록 시가 우선되기 떄문에 이로 인해 어떻게 대체가 일어났는지 명확히 스프링이 알려준다.

```
17:41:45.125 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Overriding bean definition for bean 'memoryMemberRepository' with a different definition: replacing [Generic bean: class [hello.core.member.MemoryMemberRepository]; scope=singleton; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [C:\Users\Neppiness\Desktop\clonecoding\hello-core\core\out\production\classes\hello\core\member\MemoryMemberRepository.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=autoAppConfig; factoryMethodName=memberRepository; initMethodName=null; destroyMethodName=(inferred); defined in hello.core.AutoAppConfig]
```
  - 길긴 하지만, 포인트만 뽑으면: `Overriding bean definition for bean 'memoryMemberRepository' with a different definition: replacing`

* 현실적으로는 이렇게 충돌되는 경우는 본인이 의도한 게 아니라, 실수로 겹치는 경우가 대부분일 것.
  - 그리고 이와 같은 허용으로 인해 버그가 날 여지가 생긴다. 애매한 상황은 만들지 않는 게 최선이다.

* 스프링부트가 최근에 이런 오버라이딩을 막아서, 본인이 application.properties 파일에 아래와 같이 속성을 임의로 조작하지 않고는 위 같은 충돌을 허용하지 않는다.
```
spring.main.allow-bean-definition-overriding=true
```
  - 부트는 위 옵션의 기본 값을 false로 막았다.

* 정말 많은 사람의 개발자가 함께 개발하기 때문에 명확한 게 좋다.
  - 코드를 좀 더 작성하더라도 명확하게 하는 게 좋다.