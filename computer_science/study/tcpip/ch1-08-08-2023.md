[TIL on August 8th, 2023](/TIL/2023/08/08-08-2023.md)
## **Preface**
### Intended Audience
* 이 거 읽고 전문가가 될 거라 생각하지 마세요
* 이 책을 읽은 후 스스로 실험하고 배울 수 있게, 자립할 수 있게 하는 것이 목적입니다.
* Java 1.6을 기반으로 썼다는데, 그럼 대체 몇 백 년 전 버전이라는 거지...

### Approach
* 각 챕터에서 어떤 거 다룰 건지 적어둠.

### What This Book Is Not
* 자바 기본서가 아님
* 프로토콜(IP, TCP, FTP, HTTP 등)에 대한 책이 아님
* 자바 라이브러리들에 대한 책이 아님
* 객체 지향 프로그램에 대한 책이 아님
* 프로덕션-퀄리티 코드에 대한 글이 아님
* 자신만의 소켓을 직접 구현하기 위한 글이 아님
* 이에 대해선 직접 책을 보다보면 알게 될 것이라.

<br>

# **Introduction**
* 어떻게 프로그램이 네트워크를 통해 다른 프로그램과 통신하는가?
* 자바는 소켓이라는 API를 통해 서로 통신하는 프로그램을 구현하기 위한 실용적 추상화들을 제공한다.

## 1.1 Networks, Packets, and Protocols
* 컴퓨터 네트워크는 커뮤니케이션 채널들로 상호연결된 기계들로 이루어져 있다. 이 기계들을 호스트(host)와 라우터(router)라고 한다.
* Host: 웹 브라우저, 파일 공유 프로그램과 같은 어플리케이션을 실행하는 컴퓨터들을 호스트라 한다.
  * 호스트 위에서 작동 중인 응용 프로그램들을 네트워크의 진짜 "사용자(user)"라 할 수 있다.
* Router: 한 커뮤니케이션 채널에서 다른 커뮤니케이션 채널로 정보를 잇거나 전달하는 역할을 하는 것.
* 커뮤니케이션 채널은 바이트의 연속을 한 호스트에서 다른 호스트로 전달하는 수단을 의미함(WiFi, Ethernet 등).
* 몇 개의 라우터를 거쳐서 호스트 간 연결이 이루어지는지 조차 알 수가 없음.
* 정보는 프로그램에 의해서 구축되고 해석되는 연속된 바이트이며, 컴퓨터 네트워크 관점에선 패킷이라고 불린다.
* 프로토콜은 문제 해결을 위한 약속이다. 이렇게 쓰자고 약속을 하고 그대로 실행하는 방식이라 생각하면 될 듯함. 패킷들이 어떤 구조를 이루고 있는지 알 수 있다.
  * HTTP는 서버 간 하이퍼텍스트 오브젝트를 어떻게 전송할 것인지, 어디에 저장되고 생성될 것이며, 웹 브라우저가 어떻게 그걸 사용자에게 유용한 정보로 시각화할 것인지에 대한 고민을 해결한다.
* 네트워크를 구축하기 위해서 굉장히 많은 문제를 해결해야 했다. 모든 것들을 제어할 수 있는 상태로, 또 모듈성을 유지하도록 하기 위해 서로 다른 문제들을 해결하기 위한 서로 다른 규약들이 생긴 것이다(표현 난해-).
  * TCP/IP는 해결책들의 한 집합이다. 이 집합을 프로토콜 스위트(protocol suite)라고 한다. TCP/IP 스위트의 주된 규약들은 IP와 TCP, 그리고 UDP가 있다.
* 프로토콜들을 레이어로 표현하면 굉장히 유용하다. TCP/IP를 비롯하여 다른 프로토콜 스위트는 가상적으로 이같이 조직된다. 그림에는 TCP를 통해 데이터가 어떻게 어플리케이션에서 나와 소켓을 거쳐 호스트와 라우터를 통과해 다른 어플리케이션으로 전달되는지를 나타낸다.

> 그림 1.1을 보면, 어플리케이션에서 나와 소켓을 통해 전달된다. 이 과정에서 필요한 정보들을 덧붙이는 것이라 이해된다. 이더넷과 같은 채널을 통해 흘러가며 라우터가 중계해주고, 해당 정보를 원하는 주체에 도착하면 다시 IP와 TCP 또는 UDP 프로토콜을 통해 해석되고, socket을 통해 다른 어플리케이션으로 전달된다. 왜 이렇게 그림을 그렸는지 더 공부하면서 생각해보자.

* TCP/IP에서 가장 밑바닥에는 커뮤니케이션 채널이 위치한다. 예를 들어, 이더넷이나 모뎀 연결 등이 있다. 이들은 네트워크 레이어로 사용된다. 이는 패킷을 목적지로 보내기 위한 문제를 해결한다. TCP/IP 스위트 안에 있는 단일 네트워크 레이어 프로토콜은 IP이다. 이는 일련의 채널들과 라우터들을 구성하고, 두 호스트 간 연결을 가능하게 한다.
* 인터넷 프로토콜은 데이터그램 서비스를 제공한다. 네트워크로 전송되는 모든 패킷은 마치 우체국을 통해 전달되는 소포나 편지 같아서 모두 독립적으로 전달된다. 이를 위해, 각각의 IP 패킷들은 보내는 곳의 주소가 있어야 한다. IP는 최선을 다하지만 패킷을 잃어버릴 수도 있고, 중복될 수도 있으며, 도착 순서가 바뀔 수도 있다.
* IP 위에 있는 계층은 전송 계층(transport layer)이다. 이는 TCP 혹은 UDP를 선택할 수 있다. 이들을 모두 IP 프로토콜 서비스  기반이지만, 어플리케이션 영역에서 서로 다른 수요에 따라 존재한다. TCP와 UDP는 번지를 지정(addressing)하는 공통 기능을 수행한다. IP는 패킷을 호스트들에  전달한다. 그러나, 특정 프로그램에 의도한 패킷을 전달하기 위해선 좀 더 주소를 세분화해야 한다. TCP와 UDP 모두 주소를 사용하는데, 이를 포트(port) 번호라고 한다. 이는 호스트 내에서 어플리케이션들을 구분하는 데 쓰인다. TCP와 UDP는 끝에서 끝으로 가는 전송 규약들(end-to-end transport protocols)이라 불린다.
> 결국, IP 주소는 인터넷 프로토콜에 활용되는 주소이고, 내부에서 활용되는 포트 번호들은 TCP와 UDP가 활용하는 번호였던 것.
* TCP는 패킷의 중복이나 손실, 그리고 다른 오류들을 감지하고 복원하기 위해 설계됨. TCP는 신용할 만한 바이트 스트림(byte-stream) 채널을 제공한다. 이를 통해 어플리케이션은 그런 문제들에 대해 신경 쓸 필요가 없어진다.  또한 연결지향적 프로토콜로, 통신을 하기 전에 먼저 두 프로그램이 TCP 연결을 수립해야 한다. TCP를 활용한 통신은 file I/O와 많은 부분이 비슷하다. UDP의 경우 IP에 의한 패킷 순서 변경, 손실 등의 문제를 두 어플리케이션의 통신 차원에서 조정해야 한다.

* 너무 모든 내용을 통으로 번역할 생각하지 말고 필요한 내용만 뽑아 단순화하자.

## 1.2 About Addresses
* IP + port 번호 조합으로 프로그램 간 소통을 수행한다.
* 인터넷 주소는 두 버전이 있다.
  - IPv4: 32비트 길이로, 2^32 = 40억개의 주소를 구분한다..
  - IPv6: 128비트 길이. IPv4 주소가 부족해 이를 보완하기 위해 등장.

* IPv6는 총 여덟 자리를 콜론(:)으로 구분하며, 각 그룹은 2바이트를 나타낸다.
  - 0부터 15까지 나타낼 수 있는 숫자 4개 = 4비트 4개 = 16비트 = 2바이트
  - 앞서는 0(leading zero)은 생략할 수 있다.
* 인터넷 연결이 하나의 호스트로 이어지기 때문에, 이를 통해 호스트를 식별할 수 있다.
* 반면, 호스트는 여러 개의 네트워크 인터페이스를 가질 수 있으므로, 호스트를 통해 인터넷 주소를 특정할 순 없다. 실제로 하나의 인터페이스(랜카드)에 IPv4 주소와 IPv6 주소가 따로 할당될 수 있다.
* 포트번호는 건물의 호수나 회사의 내선 번호와 같은 역할을 한다. 16비트 길이로 1이상 65,535이하의 값을 갖는다.
* 루프백주소
  - 전송된 패킷을 보내는 사람에게 즉시 돌려주는 가상의 장치를 루프백 인터페이스라 한다.
  - 이 인터페이스에 할당되는 주소가 루프백 주소다.
  - 이는 모든 호스트에게 있으며, 컴퓨터가 인터넷에 연결되지 않아도 쓸 수 있다.
  - IPv4는 127.0.0.1, IPv6는 0:0:0:0:0:0:0:1이 루프백 주소다.
* IPv4의 특정 주소는 사설 IP로 활용된다. 10으로 시작되거나 192.168, 172, *.16, *.31인 그룹은 사설망에 활용된다.
  - 이런 주소들은 집이나 사무실 단위에서 활용되며 NAT(network address translation) 장비를 통해 인터넷에 연결된다.
  - 라우터와 같이 동작되며, 패킷 상 IP와 포트번호를 덮어쓴 뒤 대상에게 전달해준다.
  - 사설 IP와 포트번호를 공적 IP와 포트번호과 매칭해준다.
  - 사설 IP를 가지곤 인터넷(global internet)에 접근할 수 없다.
* 또한 링크-로컬 주소들이 있다. IPv4의 169.254.이나 IPv6의 FE8:은 동일한 네트워크에 있는 호스트끼리 연결해준다.
* 멀티캐스트 주소: 이를 활용하면 임의의 수만큼의 목적지로 연결될 수 있다. IPv4의 244~239와 IPv4의 FF가 이에 해당한다.


## 1.3 About Names
* 주소를 이름으로 찾아갈 수 있게 매핑해두면, IP가 변경되었을 때도 쉽게 찾아갈 수 있다.
* 이같이 매핑을 위한 두 가지 방법이 있다.
  - DNS: 도메인 네임 서버는 분산된 데이터베이스로, 도메인 이름을 인터넷 주소와 다른 정보들과 매칭해준다.
  - Local configuration datatbases: OS 측면의 메커니즘으로 로컬 이름을 인터넷 주소와 매핑한다. 네트워크 작업 그룹을 형성하는 것을 뜻하는 듯하다.


## 1.4 Clients and Servers
* 전화에서 수신자 전화를 걸고, 발신자가 이를 받는 것과 같이 인터넷 통신도 비슷하게 이루어진다.
* 클라이언트와 서버가 이같은 역할을 의미한다.
  - 클라이언트는 통신을 시작한다. 서버 프로그램은 이를 수동적으로 기다리며 클라이언트가 연결 시도하길 기다린다.
  - 이로써 클라이언트와 서버는 어플리케이션을 구성한다.
  - 보통 서버가 특별한 데이터베이스 서비스 등을 제공하고, 클라이언트가 이에 접근하게 된다.
* 서버냐 클라이언트냐는 상호 간 통신을 수립하기 위한 소켓 API의 사용에 따라 결정된다.
  - 누가 서버고 누가 클라이언트인지는 중요한데, 클라이언트는 서버에 접속하기 위해 주소와 포트를 알고 있어야 하기 때문이다.
  - 소켓 API를 통해서 서버는 클라이언트의 주소 정보를 알아낼 수 있다. 이는 클라이언트가 초기에 통신하는 과정에서 주소 정보를 전달하기 때문이다.
* 클라이언트는 URL을 입력하고 DNS를 통해 서버의 인터넷 주소를 알아낸다.
* 서버는 약속된 포트번호를 열어둔다. 21번은 FTP를 위한 번호이다. 그외 용도가 잘 알려진 '웰-노운(well-known)' 포트는 IANA를 통해 알 수 있다.


## 1.5 What Is a Socket
* 소켓은 어플리케이션이 데이터를 주고 받는 과정에 대한 추상적 개념이다.
  - 이는 파일을 안정적인 저장소에서 읽고 쓰는 과정과 유사하다.
* 소켓은 어플리케이션이 네트워크에 연결되게 하며, 동일 네트워크에 연결된 다른 어플리케이션들과 통신하게 한다.
* TCP/IP 프로토콜 스위트의 주 소켓 유형은 스트림 소켓(stream socket)과 데이터그램 소켓(datagram socket)이 있다.
  - 스트림 소켓은 TCP를 end-to-end protocol로 활용하며, 신뢰할 수 있는 바이트스트림(byte-stream) 서비스를 제공한다.
  - 데이터그램 소켓은 UDP에 사용되며, 65,500 바이트에 달하는 메시지를 전송할 수 있게 한다.
* 스트림 소켓과 데이터그램 소켓 모두 다른 프로토콜 스위트에도 활용되지만, 이 책에선 다루지 않을 것이다.
* TCP/IP 소켓은 인터넷 주소와 포트 번호를 통해 유일하게 식별된다.
> 이해한 바로는 소켓은 소통 창구로, 어플리케이션에서 이를 몇 개 만들어 준비하는 듯.
> 소켓을 IP + 포트 번호에 묶어 외부에서 이를 통해 어플리케이션에 접근할 수 있도록 만드는 듯함.
> 왜 '추상화된 소켓(socket abstraction)'이라 하냐면, 소켓은 원래 파이프의 끝단이니까, 통신의 끝단 역할을 하는 '일종의 소켓'이란 의미를 명시하는 것으로 이해됨.

* 소켓은 어플리케이션을 식별하는 게 아니라 사실은 포트를 식별한다. 소켓은 이처럼 하나의 포트에 바인드되어서 활용된다.
