# **TIL on February 28th, 2023**
### Warm up
#### [boj.kr/2501](../../../Problem%20Solving/boj/uncategorized/2501-02-28-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 274 B)

#### [boj.kr/9506](../../../Problem%20Solving/boj/uncategorized/9506-02-28-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 527 B)
<br>

### S3 to G3 Problems
#### [boj.kr/9205](../../../Problem%20Solving/boj/random%20defense/9205-02-28-2023.cpp): solved on 1st try (memory: 2060 kB, time: 12 ms, Code length: 948 B)
* 50미터에 한 병씩 맥주를 마셔야 함.
* 중간 지점에 도착해서 맥주를 충전하는 경우를 생각하면 아직 맥주를 마시지 않아도 이동할 수 있는 거리가 남아있을 수 있음. 이 상태에서 20개 맥주를 꽉 채우고 이동할 수 있을 것.
* st는 0, en은 n - 1인 플로이드나 다익스트라 알고리즘을 통해 풀 수 있을 듯함.
  - $O(N^3)$인 플로이드도 가능할 것.
  - $O(ElgE)$인 다익스트라 알고리즘은, $E={{100 \times 99}\over {2}} ≒ 5000$이기 때문에 무난함.
  - 50*20 = 1000이 넘는 거리에 대해서 갈 수 없는 거리라고 판단하면 됨.
* 계산이 복잡해질 것을 염려해 구조체를 선언했지만, 그 정도 복잡한 문제는 아니었음.
  - 플로이드 알고리즘을 적용하려고 0x3f3f3f3f를 INF로 선언함.
<br>

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1F 트라이
#### [boj.kr/5670](../../../Problem%20Solving/boj/Trie/5670-02-28-2023.cpp): solved on 1st try (memory: 108472 kB, time: 820 ms, Code length: 1314 B)
* 트라이에 모든 글자를 다 넣은 후에 BFS로 영어 소문자 26개를 확인하며 다음으로 이어지는 문자가 하나인 경우 한층 더 깊이 들어감.
  - 예제로 제시되는 hell과 hello는 어떻게 생각할까: checked인 노드에선 반드시 멈춘다.
  - chk된 노드에 대해서도 더 들어가야 할 수는 있음.
* 처음에는 반드시 입력이 필요하다. 이 부분은 단순하게 ROOT 노드에서 BFS로 탐색하기 위한 노드를 입력한 것으로 간주하고, 거기서부터 입력 로직을 반영하는 것으로 구현하면 될 듯.
* 입력에 필요한 문자를 세는 방법이 더 중요할 듯함.
  - 주변에 2개 이상의 이어지는 루트가 있다면 그 수를 다 세는 것도 방법일 듯.

* 트라이 내에서 단순히 전체적으로 확인하면 된다고 생각했는데, 그 안에 속해 있는 단어 개수 따라서 처리하는 방법이 달라져야 하는 듯함. app, apple, apply가 있다고 하면, 어쨌든 a를 최소 3번은 눌러야 하는 것. app까지는 자동완성 될 것이고, l을 apple, apply에 대해 각각 한 번씩 추가로 눌러야 하고, 마지막엔 각각 e와 y를 눌러야 함.
  - 이를 수행하기 위한 자연스러운 로직이 있나? 특히 l을 두 번 눌러야 한다는 사실을 명확히 확인할 수 있어야 한다는 게 요점인 듯.

* hello와 hell의 경우를 보자. 총 글자 수는 h(2), e(2), l(2), l(2), o(1)이 되는데, hell까지는 자동완성된다. 이는 글자수의 변화가 없기 때문이라 생각할 수 있다. 따라서 이를 활용하여 재귀적으로 접근하는 코드를 작성하였다. 다만, 동적 배열을 활용해서 노드 접근에 필요한 연산수를 줄이면 빠르게 동작하도록 개선할 수 있을 것이다.

* 동적 배열을 활용하는 경우, `vector<pair<int, int>> trie[MX];`로 선언해서 활용할 수 있을 것. insert 할 때만 조금 동작 속도가 느리고 trav할 때는 훨씬 빨라질 것.

#### [Resolve boj.kr/5670](../../../Problem%20Solving/boj/Trie/5670-re-02-28-2023.cpp)): solved on 1st try (memory: 40456 kB, time: 360 ms, Code length: 1186 B)
* 메모리도 시간도 엄청나게 많이 개선됨. `vector<pair<int, int>> trie[MX];` 활용도 항상 염두에 두면 좋을 듯함.