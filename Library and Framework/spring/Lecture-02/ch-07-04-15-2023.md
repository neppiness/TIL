[TIL on April 15th, 2023](../../../TIL/2023/04/04-15-2023.md)
## 섹션 7. 의존관계 자동 주입

### 다양한 의존관계 주입 방법
* 의존관계 주입 방법은 크게 4가지가 있다.
  1. 생성자 주입
  2. 수정자 주입(setter 주입)
  3. 필드 주입
  4. 일반 메소드 주입

#### 생성자 주입
* 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법
* 지금까지 우리가 진행한 방법이 생성자 주입임.
* 특징
  - 생성자 호출 시점에 딱 한 번만 호출되는 것이 보장됨
  - *불변, 필수* 의존관계에 사용. 이 특징이 굉장히 중요함.

* 접근과 생성 등을 잘 제한하는 게 좋은 프로그래밍임.

* 공연 중간에 배우를 바꿀 일이 없음.

* 간단하게 OrderServiceImpl 클래스를 살펴보자.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용, 필드인 MemberRepository를 꺼내는 메소드.
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }
}

```
  - 위와 같은 코드에서 주입받아야 하는 필드를 private final로 설정해 null을 피하면서 외부에서 딱 한 번만 접근 및 주입할 수 있도록 설정함.
  - 또한 생성자가 딱 1개 있다면 @Autowired를 생략할 수 있다. 그러나, 오버로딩을 통해, 다른 인자 입력으로 생성자를 호출할 수 있게 열면 @Autowired 없이 쓸 수 없다.

#### 수정자 주입
* 세터를 선언하고, 이를 통해 외부에서 주입하는 방식으로 구현.

```java

private MemberRepository memberRepository;

@Autowired
public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = jmemberRepository;
}
```

* 스프링 라이프 사이클 2단계
  - 빈을 생성하는 단계 / 의존 관계 주입하는 단계
  - 이렇게 두 단계로 나누고, 세부적으로는: 컨테이너 생성 -> 빈 등록 -> 의존 관계 설정 준비 -> 주입

* 다만, 생성자는 `OrderServiceImpl` 클래스를 구성하면서 바로 호출되기 때문에, 필드가 바로 할당된다. 스프링 컨테이너에서 생성자의 형태를 보고, 생성자에 건내줘야 하는 인자를 파악한 뒤, 이를 주입하는 방식.
* 그러나, 세터는 의존관계 주입 단계에서 따로 일어난다고 함. 물론, 이 둘이 꼬인다고 해서 주입에 문제가 발생하진 않을 듯함.

* *선택, 변경* 가능성이 있는 의존관계에서 활용함. 선택적으로 의존관계를 주입.
  - `@Autowired(required = false)`를 통해 선택적으로 쓸 수 있다.

> 참고: `@Autowired`의 기본 동작은 주입할 대상이 없으면 오류가 발생. 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)`로 설정을 해줘야 함.

* 자바빈 프로퍼티 규칙.
  - 세터 게터의 이름을 정하는 규칙이 있음.


#### 필드 주입
* 필드 그대로 값을 넣는다.

* 아래와 같이 @Autowired를 걸어서 연결할 수 있다.

```java
    @Autowired private final MemberRepository memberRepository;
    @Autowired private final DiscountPolicy discountPolicy;
```

* 필드 주입은 외부에서 변경이 불가능해서 테스트하기 어렵다는 단점이 있다.
  - 스프링 컨테이너가 아닌 순수한 자바로 테스트할 방법이 없다.

```java
@Test
void fieldInjectionTest() {
    OrderServiceImpl orderService = new OrderServiceImpl();
    // setter 추가 필요
    orderService.createOrder(1L, "1teimA", 10000);
}
```

* 결국 테스트를 위해 setter를 둬야하고, 간결함을 잃게 된다. 다만, @Autowired를 활용한 테스트 코드 작성 시엔 필드에 직접 주입해도 무방하기 때문에 '필드 주입'을 써도 된다.

* **순수 자바 코드로써 테스트할 일이 없는 코드들에만 적용하지 않으면 된다.** 그래도 필드 주입은 추천하지 않는다고 함(금하기 위해선 지원에서 아예 빼버리면 되지 않을까 싶음.)


#### 일반 메소드 주입
* 일반 메소드를 통해 주입 받을 수 있다.
* 특징
  - 아무 메소드에다가 주입 명령을 해버리는 것.
  - setter 메소드와 이름만 다른 듯함.
  - 생성자 주입과 생성자 주입을 자주 쓰지, 이런 독자 메소드를 통한 주입은 잘 하지 않는다.

> 참고: 의존관계 자동 주입은 스프링 콘테이너가 관리하는 스프링 빈이어야 동작한다. 스프링 빈이 아닌 `Member` 같은 클래스에서 `@Autowired` 코드를 적용한다 해도 아무 일도 일어나지 않는다.

<br>

### 옵션 처리
* 주입할 스프링 빈이 없어도 동작해야 하는 경우가 있다.
  - 대상이 없는 것이 확인되었을 때 수행해야 하는 동작을 구현할 일이 있을 수 있다.

* @SpringBootTest: 통합 테스트.
  - 동일한 이름을 가진 빈이 등록될 수 없음.

* 옵션 처리는 어떻게 할 것인가?

* 자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
  - @Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메소드 자체가 호출 안 됨
  - `org.springframework.lang.@Nullabe`: 자동 주입할 대상이 없으면 null이 입력된다.
  - `Optional<>`: 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.

* 아래와 같은 테스트 코드를 확인해보자.

```java
public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
    }

    static class TestBean {

        @Autowired(required = false)
        public void setNoBean1(Member noBean1) {
            System.out.println("noBean1 = " + noBean1);
        }

        @Autowired
        public void setNoBean2(@Nullable Member noBean2) {
            System.out.println("noBean2 = " + noBean2);
        }

        @Autowired
        public void setNoBean3(Optional<Member> noBean3) {
            System.out.println("noBean3 = " + noBean3);
        }
    }
}
```

* 이를 실행시킨 결과는 아래와 같다.

```
noBean2 = null
noBean3 = Optional.empty
```

* 위에서 언급했던 것처럼 `@Autowired(required = false)`로 설정한 경우, 아예 호출이 안 된다.
* `@Nullable`이나 `Optional<Member>`을 활용해서 값이 없을 때도 가져올 수 있다.
  - Nullable과 Optional은 자바 문법이기 때문에 전체에 대해서 활용할 수 있다.

<br>

### 생성자 주입을 선택해라!
* 왜 생성자 주입을 선택하는 게 좋은지 설명함.

* 과거에는 수정자 주입과 필드 주입도 많이 활용했다. 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다.

* **불변**
  - 대부분의 의존관계는 한 번 일어나면 어플리케이션 종료시점까지 변경할 일이 없다. 오히려 대부분의 의존관계는 프로그램 실행 중에 변해선 안 된다.
  - 수정자 주입을 사용하면, setXxx 메소드를 public으로 열어야 하며, 이를 누군가 실수로 변경할 수도 있다. 변경하는 안 되는 값을 조작하는 메소드를 열어두는 것은 좋은 설계법이 아니다.
  - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로, 이후에는 호출될 일이 없다.


* **누락**
  - 프레임워크 없이 순수한 자바 코드를 단위 테스트하는 경우, 수정자 의존관계를 활용하면 어떤 것들을 주입해줘야 하는지 일일이 다 확인하고 입력해줘야 한다.
  - 아래 코드는 수정자 의존관계를 사용했을 때 정상 동작하지 않는다. nullPointException이 터진다.

```java
    @Test
    void createOrder() {
        OrderServiceImpl orderService = new OrderServiceImpl();
        orderService.createOrder(1L, "itemA", 10000);
    }
```
  - 반면, 생성자 주입을 활용하는 경우엔 `OrderServiceImpl orderService = new OrderServiceImpl();` 명령에서 컴파일 오류가 발생한다. 이는 생성자에 넘겨줘야 하는 인자를 넘겨주지 않았기 때문이다.

```java
    @Test
    void createOrder() {
        MemoryMemberRepository memberRepository = new MemoryMemberRepository();
        memberRepository.save(new Member(1L, "name", Grade.VIP));

        OrderServiceImpl orderService = new OrderServiceImpl(memberRepository, new FixDiscountPolicy());
        Order order = orderService.createOrder(1L, "itemA", 10000);
        assertThat(order.getDiscountPrice()).isEqualTo(1000);
    }
```

* **final 키워드**
* 생성자를 활용하면 final 키워드를 활용할 수 있다. 즉, 생성자 또는 초기값 할당만을 통해 값을 줄 수 있으므로, 변할 위험이 없다.
  - 또한, final을 써두면 값이 입력되지 않은 상황을 즉각 확인할 수가 있다.

> 컴파일 오류는 세상에서 가장 빠르고 좋은 오류다.

* 정리
  - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이다.
  - 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 활용할 수 없다.
  - 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라. 필드 주입은 사용하지 않는 게 좋다.

<br>

### 롬복과 최신 트랜드
* 막생 개발을 해보면, 대부분이 다 불변이고, 그래서 다음과 같이 final 키워들르 사용하게 된다.
* 그런데 생성자도 만들어야 하고, 주입 받은 값을 대입하는 코드도 만들어야 한다.
* 필드 주입처럼 좀 편리하게 사용하는 방법은 없을까?

* spring initializr에서 라이브러리로 Lombok을 찾아 넣을 수 있으니 참고할 것.
  - build.gradle에 아래와 같이 작성하면 된다.
```
configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}
```

* 의존성은 아래와 같이 작성해준다.
```
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter'

	compileOnly 'org.projectlombok:lombok:'
	annotationProcessor 'org.projectlombok:lombok:'

	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

* 롬복을 사용하게 되면, 아래와 같이 getter와 setter를 자동으로 만들어준다.
  - 네이밍 컨벤션에 따라 자동으로 세팅을 해주고, 필요한 게터나 세터를 찾아 쓰면 될 듯함. 
  - 아래와 같이 설정해서 클래스를 실행하게 되면, `name = neppiness` 출력을 볼 수 있음.
```java
@Getter
@Setter
@ToString
public class HelloLombok {

    private String name;
    private int age;

    public static void main(String[] args) {
        HelloLombok helloLombok = new HelloLombok();
        helloLombok.setName("neppiness");
        
        String name = helloLombok.getName();
        System.out.println("name = " + name);
    }
}

```

* 롬복 관련해서 검색하면 필요한 기능들을 굉장히 간편하게 갖다 쓸 수 있다.
  - 실무에서도 기본으로 깔고 쓴다고 함.

* 아래와 같은 코드는 자동으로 필드를 정리해서 출력해줌.

```java
@Getter
@Setter
@ToString
public class HelloLombok {

    private String name;
    private int age;

    public static void main(String[] args) {
        HelloLombok helloLombok = new HelloLombok();
        helloLombok.setName("neppiness");

        System.out.println("helloLombok = " + helloLombok);        
    }
}
```
  - 결과: `helloLombok = HelloLombok(name=neppiness, age=0)`

* `@RequiredArgsConstructor`
  - final이 붙은 필드 값에 대해서 자동으로 처리해주는 생성자를 만들어준다.

```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용, 필드인 MemberRepository를 꺼내는 메소드.
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }
}
```

* 이를 적용하면, 필드에 대한 직접 주입보다 간결한 코드가 나온다.

<br>

### 조회 빈이 2개 이상 - 문제
* 


### @Autowired 필드 명, @Qualifier, @Primary
### 애노테이션 직접 만들기
### 조회한 빈이 모두 필요할 때, List, Map
### 자동, 수동의 올바른 실무 운영 기준