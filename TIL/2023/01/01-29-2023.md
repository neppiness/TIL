# **TIL on January 28th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1C 플로이드 알고리즘
#### [boj.kr/23286](../../../Problem%20Solving/boj/Floyd%20algorithm/23286-01-29-2023.cpp): solved on 1st try (memory: 2376 kB, time: 36 ms, Code length: 787 B)
* 플로이드로 싹 경유하면서 각 경로 당 높이 최솟값을 저장하자.
* 비용은 높이 최댓값인 1,000,000 이하로 제어되기 때문에, int로 저장 가능.

* 플로이드 알고리즘에 활용된 식은 아래와 같음

```cpp
for(int k = 1; k <= n; k++)
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			h[i][j] = min(h[i][j], max(h[i][k], h[k][j]));
```

* 여기서 `h[i][i] = 0;`는 있든 없든 영향 없음. 단방향 그래프가 주어져 돌아올 수 없는 경우도 있을 수 있고, 계산을 위해 0으로 설정해야 하는 경우도 있으니 어느 쪽이 옳다고 판단해야 할지는 잘 모르겠음.

* PR용 주석은 아래와 같다.
```cpp
/*
현재까지 계산된 i에서 j로 가는 길목의 허들 높이를 h[i][j]라 하자.

플로이드 알고리즘을 통해 N개 노드를 경유하면서
h[i][j]를 아래 두 값 중 작은 값으로 갱신한다(31번째 줄).
  1. h[i][j]의 현재 값
  2. i -> k -> j 경로로 갈 때의 길목 상 최대 허들 높이
    - h[i][k], h[k][j] 중 큰 값
*/
```


### Silver 3 to Gold 3 Random Defense
#### [boj.kr/19948](../../../Problem%20Solving/boj/random%20defense/19948-01-29-2023.cpp): solved on 5th try (memory: 2156 kB, time: 0 ms, Code length: 800 B)
* cin은 공백문자 입력을 무시한다. 따라서 getline 뒤에 나오는 cin은 정상동작한다.
* 2번째 시도까지 틀림. 일단 한 번은 스페이스 두 번 나온 경우에 정답 벡터로 스페이스가 빨려들어갔기 때문이라 하지만, 100%에서 한 번 틀림.
* 시의 내용과 시의 제목이 Enter키로 구분된다고 함: 이 조건은 의미 없는 게, 입력으로 *첫 줄*에 시의 내용이 주어진다고 했기 때문.
* 문제 조건 잘 읽자. 제목도 타이핑 해야함. 따라서 제목을 기록할 문자는 사용 가능 횟수를 2만큼 차감해야 함.


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x16 이진 검색 트리
#### [이진 검색 트리 사용법 복습](../../../Languages/C/binary_search_tree_example.cpp)
* 다음과 같은 명령으로 set를 초기화 할 수 있다: `set<int> s({161, 188, 154, 180, 172});`
* 멤버함수 insert 사용 시, 중괄호로 여러 원소를 넣을 수 있다: `s.insert({161, 188, 154});`
* count 함수는 해당 원소가 있나 없나 확인해준다. set의 경우 중복을 허용하지 않기 때문에, 1 또는 0만 반환된다.

```cpp
set<int> s({161, 161, 188, 154, 180, 172});
cout << s.count(161); // 1
```

* next와 prev를 통해서 iterator를 다음 또는 이전으로 이동시킬 수 있다.
* 멤버함수 lower_bound를 통해 원하는 값을 이분탐색할 수 있다.

```cpp
set<int> s({161, 188, 154, 180, 172}); // s = {154, 161, 172, 180, 188}
auto it = s.lower_bound(156); // {154, 161, 172, 180, 188}
//                                      ^
cout << *prev(it); // 154
```

* set을 이정도로 활용할 수 있다고 인지한 채로 BOJ 19700번을 한 번 더 보자.


#### [3rd Retry: boj.kr/19700](../../../Problem%20Solving/boj/Binary%20search%20tree/19700-re2-01-29-2022.cpp)
* 입력 값을 키 순서대로 정렬한다.
* 키가 큰 애들부터 차례대로 들어가면, 현재 그 그룹에 자신보다 키가 큰 애가 몇 명이나 들어갔는지 파악할 수가 있다. 다만, 이 경우에 효율적인 선택이 안 될 듯하다.

* 팀 내 최소 등수를 기준으로 내림차순 정렬 후 배치하면 어떨까?
* map의 사이즈 체크만으로 현재까지 몇 명이 들어왔는지 체크할 수 있고, 만약에 키에 대한 내림차순으로 정렬한 뒤에 이진 검색 트리에 넣으려고 한다면 현재 자신의 순위가 얼마인지도 파악이 된다. 그치만, '효율적인 배치'를 고려할 때... 그렇게 해도 되는가?

* 그리디 풀이에 대한 감이 있어야 할 듯.


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x11 그리디
#### [boj.kr/2847](../../../Problem%20Solving/boj/Greedy/2847-01-29-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 365 B)
* 가장 뒤에 있는 수를 기준으로 깎아감
  - 가장 뒤에 있는 수를 깎게 되면 전체적으로 커트를 낮춰야 해서 감소시켜야 하는 횟수가 늘어날 수 있음
  - 따라서, 가장 덜 감소시키는 방법은 성립하지 않을 때 큰 놈만 깎는 것.
  - 높이의 차로 깎을 필요도 없고(해봐야 연산량이 200만이라) 그냥 하나씩 깎으면서 확인해도 됨.


#### [boj.kr/1439](../../../Problem%20Solving/boj/Greedy/1439-01-29-2023.cpp): solved on 1st try (memory: 2024 kB, time: 0 ms, Code length: 313 B)
* 숫자가 연속된 덩어리를 찾은 후에 작은 쪽 덩어리 수만큼 뒤집으면 됨
* 오늘 풀었던 타이핑 문제와 같이 한 덩어리를 찾는 로직은 이전과 같은 문자인 경우에 다음 인덱스를 탐색하는 것으로 구현함.

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x12 수학
#### [boj.kr/1456](../../../Problem%20Solving/boj/Math/1456-01-06-2023.cpp)
* PR용 풀이 정리