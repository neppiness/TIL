# **TIL on February 26th, 2023**
### Warm up
#### [boj.kr/10813](../../../Problem%20Solving/boj/uncategorized/10813-02-26-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 312 B)

#### [boj.kr/10811](../../../Problem%20Solving/boj/uncategorized/10811-02-26-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 408 B)

#### [boj.kr/2444](../../../Problem%20Solving/boj/uncategorized/2444-02-26-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 351 B)
<br>

### Pick and solve
#### [boj.kr/1083](../../../Problem%20Solving/boj/uncategorized/1083-02-26-2023.cpp):
* 합리적인 로직이 있는가? 높은 자리에 큰 수가 있는 경우가 가장 유리하기 떄문에 항상 그 위치부터 확인하는 알고리즘으로 접근하면 좋을 듯.
  - 그리디로 접근했다가 틀림.

* 어떤 풀이를 떠올릴 수 있을까?
  - 다음 순열 사용 시엔, 10 20 30 40 50 60 70은 10 20 30 40 50 70 60이 됨.

* 교환할 수 있는 숫자 쌍의 총 수는 49.
  - 교환하면 몇 번째로 큰 수가 되는지 알 수 있나?

* 가장 큰 수를 가장 큰 위치에 보낼 수 있는 스왑 횟수인지 파악함
  - 범위를 잡고 로테이션 시켜야 할 듯
  - 가장 큰 수가 되기 위한 과정이 있기 때문에, 큰 수를 잡아서 스왑을 해야함: 아래 예제를 두고 생각해보자.

```shell
7
10 20 30 40 50 60 70
6
```
`
* 이같은 경우, 70이 첫번째 자리로 갈 수 있다면, 즉 가능한 스왑 횟수가 6이라면, 70 10 20 30 40 50 60이 되는 게 가장 큰 수임.
  - 그러나 이전에 제출했던 코드로 계산해보면 40 30 20 10 50 60 70이 됨.
  - 가장 큰 수를 가장 큰 자리로 보낸다는 아이디어가 좋기는 한데, 만약 그 횟수가 충분하지 않은 경우엔 어떻게 할까? 어떤 선택이 최선의 선택일까?
  - 횟수가 충분하지 않은 경우엔 정렬되지 않은 원소를 잡고, 큰 원소를 최대한 위로 올리는 그리디적 선택이 옳은 선택일 것이라 생각됨.

* 추후에 풀이를 좀 더 명확하게 고안하자.
<br>

### Solved.ac Class 5 Problems
#### [boj.kr/9527](../../../Problem%20Solving/boj/solvedac/9527-02-26-2023.cpp)
* 간단한 관찰을 해보자.
  - 트리 구조처럼 생각할 수 있을 듯 0과 1에서 시작해서, 다시 0과 1을 붙여 숫자를 만드는 방식으로 생각.
  - 00, 01, 10, 11
  - 이 경우에는 00, 01이 기존에 있던 0, 1과 중복됨.
* 결과 값이 무엇인지는 계산을 해야하고, 그 수까지 몇 개의 1이 저장됐는지도 기록을 해야할 것.

* n개 비트로 표현 가능한 모든 수의 1 개수를 구하자.
  - n개 비트로 표현 가능한 모든 수의 개수는 $2^n$이다.
  - 이 수들은 n개 비트로 이루어져 있으며, 이 비트들의 딱 절반이 켜져있다.
  - 따라서, $n \times 2^{n} / 2$가 n개 비트로 표현 가능한 모든 수의 1 개수이다.
  - 비트를 밀 때 그냥 활용하는 1은 int형이기 때문에 오버플로우가 날 수 있다. 따라서, 이를 유의하여 (long long)1로 둔 후에 비트를 이동시키도록 하자.
* 단순하게, f(x)를 x이하의 수들의 1의 개수라고 하면, 주어진 입력 a, b에 대해 아래 값을 출력하면 된다.
  - `f(b) - f(a - 1)`
