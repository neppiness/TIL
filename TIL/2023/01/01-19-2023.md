# **TIL on January 19th 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1A Topological Sort
#### [boj.kr/2637](../../../Problem%20Solving/boj/Topological%20sorting/2637-01-19-2023.cpp): solved on 1st try (memory: 2028 kB, time: 0 ms, Code length: 742 B)
* 위상정렬 풀이.
  - 시작은 완제품인 N에서 출발.
  - indegree가 다 제거되었다는 건, 필요한 부품의 수가 확정되었다는 것이므로, 이를 토대로 주변에 필요한 양을 전달하면 자연스러운 풀이가 가능할 것.
  - `vector<pair<int, int>> req[MX + 2];`를 선언하여, 필요한 양을 기록함: 예제의 경우, 완제품인 7이 5번 제품 2개, 6번 제품 3개, 4번 제품 5개가 필요하므로, 이를 `req[7] = {{5, 2}, {6, 3}, {4, 5}};`로 기록한다.

### BOJ step by step: 위상정렬
#### [boj.kr/3665](../../../Problem%20Solving/boj/Topological%20sorting/3665-01-19-2023.cpp): solved on 2nd try (memory: 2276 kB, time: 24 ms, Code length: 1469 B)
* 순위 변동이 있다는 걸 어떻게 처리할 것인가?

* 인접 행렬을 구현해서, 필요한 순서를 지우거나 수정할 수 있도록 하는 게 좋을 듯하다.

* 팀 순위가 주어질 때, 앞선 팀은 뒤에 있는 모든 팀과 연관되며, 인접 행렬에 기록해 이후 indgree를 조정할 때 반영한다.
  - 예를 들어, 처음에 5 4 3 2 1로 주어졌다면 `adj[5][4] = 1, adj[5][3] = 1, adj[5][2] = 1, adj[5][1] = 1`로 설정한다. 마찬가지로, 4팀에 대해서도 `adj[4][3] = 1, adj[4][2] = 1, adj[4][1] = 1`로 설정한다.
  - u팀과 v팀의 순위 변동을 입력 받은 경우, `adj[u][v] = !adj[u][v]`, `adj[v][u] = !adj[v][u]`로 뒤집는다.

* 예외 처리는 두 가지로 나뉜다.
  - ind가 0이 되는 경우가 동시에 발생해서 2개 이상의 노드를 큐에 넣어야 하는 상황이 생기면, 이는 순위 구분이 확실치 않은 경우이다. 이 경우, `?`를 출력한다.
  - 최종적으로 얻은 정답의 길이가 주어졌던 팀의 수와 다른 경우, 모든 팀에 대해 배치하지 못한 것이기 때문에, 이 경우 `IMPOSSIBLE을` 출력한다.
  - 해당 예외 처리가 올바른지는 정확히 판단이 어렵다. `?`를 출력하는 예외처리가 `cnt > 2`인 경우로 설정됐지만 정답코드로 인정이 되었기 때문이다. 해당 조건을 본래 의도대로 `cnt > 1`로 바꿔도 정답으로 인정되었다.

```cpp
if(cnt > 2) {
  cout << "?\n";
  return;
}
```

* 솔직히 예외에 대한 이해도가 낮았지만, 이같이 답을 얻은 것은 운이라 생각한다. 데이터가 추가되는 경우, 충분히 오답이 될 수 있으니, 나중에 한 번 더 예외에 대해 면밀히 생각해보자.

* `adj[cur][nxt]`가 0이어서 `ind[nxt] == 0` 조건을 확인할 필요가 없는데도, 이상하게 `ind[nxt] -= adj[cur][nxt]`로 해놔서 `ind[nxt] == 0`인 애가 계속 큐로 들어갔을 것. 이로 인한 버그를 겪었으니 의미를 명확하게 하는 데 좀 더 신경을 쓰자.