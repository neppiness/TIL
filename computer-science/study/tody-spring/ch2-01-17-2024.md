**토비의 스프링 3.1**

# 2장: 테스트
* 스프링은 객체지향과 테스트에 가치를 둔다.
* 테스트는 작성한 코드를 확실할 수 있게 해준다.

## 2.1 UserDaoTest 다시 보기
### 2.1.1 테스트의 유용성
* 테스트를 통해 결과가 원하는 대로 나오는지 확인함.
* 이를 통해 디버깅을 수행 가능.
    - 모든 과정을 마친 후 확인된 결함을 전부 제거했다고 확신할 수 있다.

### 2.1.2 UserDaoTest의 특징
* 책에 나와있는 테스트 코드의 내용을 정리하면 아래와 같은 작업을 수행하고 있다.
    - 자바에서 가장 손쉽게 실행 가능한 main() 메소드를 이용한다.
    - 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
    - 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
    - 테스트의 결과를 콘솔에 출력해준다.
    - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.
* main() 메소드를 이용해 테스트 수행을 쉽게했다는 점과 테스트 대상인 UserDao를 직접 호출해서 사용한다는 점에 주목하자.

#### 웹을 통한 DAO 테스트 방법의 문제점
* 보통은 DAO를 테스트하기 위해선 제반 사항이 다 갖춰져 있어야 함.
    - 호출을 수행해보고 DAO 작업 과정을 거쳐, 다른 API로 호출해보며 결괏값을 확인해보는 식이라고 하자.
* 이 경우, DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
    - 심지어 문제가 발생하더라도 어떤 게 오작동했는지 파악하기가 굉장히 어렵다.

#### 작은 단위의 테스트
* 테스트하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
* 테스트는 가능하면 작은 단위로 쪼개야 한다.
    - 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
* 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트라고 한다.
* 단위는 작을수록 좋다.
    - 단위를 넘어서는 코드들과 무관하게 테스트가 동작할 수 있으면 좋다.
* DB가 초기화된 상태에서 테스트를 통해 DB가 온전히 조작된다면 단위테스트라고 할 수 있는 모양.
* 때로는 API의 통합적인 테스트를 수행해야 하는 경우도 있다.
* 개발자가 코드를 작성하는 시기에 테스트도 같이 수행하는 편이 맥락을 잊어버리지 않고, 세심하게 테스트하기 좋다.

#### 자동수행 테스트 코드
* 테스트를 위한 클래스를 따로 작성함.
* 테스트는 자동으로 수행할 수 있어야 함.
    - 수동으로 일일이 어떤 폼에 어떤 값을 작성하고 이를 서버에 전달하는 과정을 확인하는 등, 번거로운 작업을 해야한다면 굉장히 어려운 일이 됨.

### 2.1.3 UserDaoTest의 문제점
* 수동 확인 작업의 번거로움
    - 정상적인 결과가 출력된 것인지 눈으로 일일이 확인해야 한다.
* 실행 작업의 번거로움
    - 이와 같은 테스트 방식을 활용하면 main() 메소드를 존재하는 DAO 개수만큼 동작시켜야 함.

<br>

## 2.2 UserDaoTest 개선
### 2.2.1 테스트 검증의 자동화
* 테스트 검증하는 로직을 조금 수정함
    - 메소드가 오류를 내지 않고 동작하는 것도 중요하지만, 이를 통해 버그를 잡아낼 수는 없음.
    - 따라서 기대하는 값과 실제 얻은 값이 같은지 확인하는 과정이 필요함.
* 자동화 과정이 없으면 검증이 불안해짐.
* 검증이 제대로 되지 않으면 작업을 마치고도 불안할 수밖에 없음.

### 2.2.2 테스트의 효율적인 수행과 결과 관리 
* JUnit을 통한 자바 단위테스트 작성

#### JUnit 테스트로 전환
* 프레임워크가 흐름을 제어하기 때문에 main() 메소드 없이도 동작시킬 수 있는 테스트를 작성할 수 있음.

#### 테스트 메소드 전환
* main() 메소드를 사용하지 않고, `@Test` 어노테이션과 `public` 접근 제어자가 필요
    - 그러나 JUnit5에서는 더이상 `public` 접근 제어자가 필요 없다.


```java
// import statement

public class UserDaoTest {

    @Test
    public void addAndGetTest() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        // and so on...
    }

}
```

#### 검증 코드 전환
* `assertThat(user2.getName(), is(user.getName()));`
    - 이와 같은 방식으로 검증이 가능하다.
* 최근에는 assertj.core.api의 Assertions 상 API를 통해서 아래와 같이 작성

```java
int a = 5;
Assertions.assertThat(a).isEqualTo(5);
```

#### JUnit 테스트 실행
* 예전에는 JUnit 프레임워크를 시작시켜줘야 했던 것으로 보임.
    - 현재는 간단하게 run test 조작 하나만으로 테스트가 가능.

<br>

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
### 2.3.1 JUnit 테스트 실행 방법
#### IDE
* 이클립스 쓰던 시절 얘기
    - run as 항목 중에 JUnit Test를 선택하면 테스트가 자동으로 실행된다고 함.
* JUnit5만 가지고 테스트를 작성한다고 하면, 이에 대한 동작은 어떻게 실행시켜볼 수 있을까?
    - 사실은 run으로 간단하게 테스트를 돌려보는 것도 IntelliJ가 제공하는 기능인 것 아닐까
    - 우리가 실제로 테스트를 실행하려면 더 복잡한 로직으로 이를 호출해야 할지도 모르겠다.

### 2.3.2 테스트 결과의 일관성
* 현재 코드는 코드에 변경사항이 없을 때에도 DB 상태에 따라 실패할 수도, 성공할 수도 있는 코드다.
* 좋은 테스트는 코드에 변경사항이 없다면 항상 동일한 결과를 내야 한다.

#### deleteAll()과 getCount() 추가
* 적당히 활용할 새로운 기능을 추가함.

#### deleteAll()과 getCount()의 테스트
* deleteAll()과 getCount()의 정상적 동작을 위한 세부 고려사항에 대해 서술

#### 동일한 결과를 보장하는 테스트
* 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다.

### 2.3.3 포괄적인 테스트
* 테스트의 동작 순서는 보장되지 않는다.

#### get() 예외조건에 대한 테스트
* id 값에 해당하는 사용자 정보가 없는 경우
    - EmptyResultDataAccessException을 사용할 것이라고 함.
    - 이렇게 예외가 터지는 경우는 예전에 `@Test(expected=EmptyResultDataAccessException.class)`로 테스트 어노테이션에 작성을 했음.
    - 지금은 `Assertions.assertThatThrownBy();` 메소드를 통해서 주어진 람다 함수를 호출했을 때 예외가 발생하나 검토함.
* "예외 테스트를 먼저 만들라."
    - 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.
    - 이런 예외 상황이 발생했을 때 어떻게 처리되는지 확인하는 테스트를 작성한다면 꼼꼼한 개발이 가능하다.

### 2.3.4. 테스트 주도 개발
* 조건, 행위, 결과로 테스트가 구분됨
    - given, when, then과 같은 것.

#### 테스트 주도 개발
* 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 할 수 있게 테스트 코드를 먼저 작성.
    - 테스트를 성공하는 코드를 작성하는 방식의 개발 방법.
* 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 작성하지 않는다는 게 기본 원칙이라 함.
* 이를 통해 짧은 주기로 빠르게 피드백을 받을 수 있는 개발이 가능하다고 함.
    - 다음 토이 프로젝트는 이같은 방식으로 작성하는 것도 생각해봐야 할 듯.

### 2.3.5 테스트 코드 개선
#### @Before
* 중복된 처리를 @Before 코드를 통해 수행
    - 현재는 `@BeforeEach`, `@BeforeAll`로 대체된 듯함.
* 테스트 클래스에서 @Test 어노테이션이 붙은 테스트 메소드를 찾고, 테스트 클래스 오브젝트를 하나 만듦.
    - @Before 실행 -> 코드 실행 후 결과 저장 -> @After 실행 과정을 반복.
* 현재 JUnit5도 이런 과정으로 동작할까?
* 테스트 메소드를 실행할 때마다 테스트 클래스의 인스턴스를 새로 만든다고 함.    
    - 그렇다면 너무 비효율적이지 않나.
    - 각 테스트가 서로에게 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해서라고 함.

#### 픽스처
* 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 함.
* 픽스처를 미리 세팅하는 구문을 작성해 @Before로 추출한다 생각해도 될 듯함.

<br>

## 2.4 스프링 테스트 적용
* 어플리케이션 컨텍스트
    - @Before 메소드에서 어플리케이션 컨텍스트를 불러와서 쓰고 있는데, 이 또한 반복되기 때문에 컨텍스트 역시 반복해서 만들어진다.
    - 또한, 어플리케이션 컨텍스트를 초기화할 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다.
    - 이런 경우, 테스트를 마치고 리소스를 깔끔하게 정리해주지 않으면 다음 테스트에서 만드는 새로운 컨텍스트와 충돌할 수 있다.
* 어플리케이션 컨텍스트는 공유하더라도 큰 문제가 발생하지 않는다.
    - 따라서, 이를 공유하도록 설정하자.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {

    @Autowired
    private ApplicationContext context;
    
    // ... fields

    @Before
    public void setUp() {
        this.dao = this.context.getBean("userDao", UserDao.class);
        // ... statements
    }

}
```

* @RunWith을 통해서 SpringJUnit4ClassRunner라는 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 컨텍스트를 만들고 관리하는 작업을 진행해준다.
* @ContextConfiguration은 자동으로 만들어줄 어플리케이션 컨텍스트의 설정파일 위치를 지정한 것.
* 이후 설정된 컨텍스트가 Autowired로 연결된 context를 주입함.

#### 테스트 메소드의 컨텍스트 공유
* 컨텍스트 재사용 시에 메소드 테스트 수행 속도가 굉장히 짧아진다.

#### 테스트 클래스의 컨텍스트 공유
* 여러 클래스가 같은 어플리케이션 컨텍스트를 사용하면 이를 공유할 수 있도록 도움.

#### @Autowired
* @Autowired가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크가 변수 타입과 일치하는 컨텍스트 내 빈을 찾음.
* 스프링 어플리케이션 컨텍스트는 초기화 시 자기 자신도 빈으로 등록함.
    - 따라서 이를 주입받을 수 있음.
* UserDao를 써야할 때 그냥 이를 가져오도록 @Autowired를 활용할 수도 있다.
* @Autowired를 통해 빈을 조회하는 경우 우선 타입이 일치하는 빈이 있는지 확인한다.
    - 만약 타입이 일치하는 빈이 다수인 경우, 선언된 변수의 이름과 동일한 빈이 있는지 확인한다.
    - 두 가지 방법 모두 활용해도 빈을 찾을 수 없는 경우 에러가 발생한다.
    - 빈의 이름은 @Bean 어노테이션으로 등록하는 메소드의 이름이 될 것.

### 2.4.2 DI와 테스트
* 우리가 개발하는 시스템 운영 중에 절대로 바뀌지 않을 것이 있다고 하자
    - 그렇다면 주입을 받을 필요가 딱히 없지 않을까?
* 그래도 인터페이스를 두고 써야 하는 이유가 있다.
    1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
        + 바뀌지 않는 것은 없다. 변경될 때를 대비해 주입을 통해 관리하는 게 좋다.
        + 주입 받는 것은 아주 쉽고 간결하다.
        + 바뀌지 않을 거라는 전제 하에 그렇게 한다는 거였는데, 이렇게 부정해버리면 아무런 의미가 없지 않나.
    2. 클래스의 구현 방식은 바뀌지 않더라도 인터페이스를 둬서 가져오면 나중에 다른 구현체를 활용하기 좋다.
    3. 테스트를 효율적으로 하기 위해선 DI를 활용하는 게 좋다.

#### 테스트 코드에 의한 DI
* 테스트가 운영용 DB의 정보를 없애버릴 위험이 있다.
    - 그렇다고 컨텍스트를 테스트할 때와 배포할 때로 구분하는 건 번거롭기도 하고 여전히 위험성이 있다.
    - 이럴 경우 테스트 코드에 의한 DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주면 된다.
* @DirtiesContext 어노테이션을 활용하여 테스트 컨텍스트의 상태를 변경한다는 것을 알림.
    - 변경이 일어났다고 표시하는 역할.
    - 이렇게 표시된 테스트 클래스의 어플리케이션 컨텍스트는 공유되지 않는다.

#### 테스트를 위한 별도의 DI 설정
* DI의 장점을 살려 DAO가 테스트에서만 다른 DataSource를 사용하게 할 수 있는 방법
* 테스트 전용 설정파일을 따로 만들어두는 방법.
    - application.yml에서는 어떻게 설정해야 하는지 배워보자.

#### 컨테이너 없는 DI 테스트
* 컨테이너를 사용하지 않고 필요한 객체를 @Before에서 생성하도록 작성함.
    - 이를 통해 컨텍스트 없이 전체 흐름을 이해할 수 있게 됨.

#### DI를 이용한 테스트 방법 선택
* 가장 먼저는 컨텍스트 없이 테스트 할 수 있도록
* 이후 컨텍스트를 공유하여 테스트 할 수 있도록
* 컨텍스트 변경이 불가피한 경우 반드시 @DirtiesContext를 활용하여 테스트할 수 있도록

<br>

## 2.5 학습 테스트로 배우는 스프링
* 학습테스트
    - 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만든 라이브러리 등에 대한 테스트
    - 테스트지만 기능에 대한 검증이 목적이 아님.
    - 자신이 테스트를 하려는 기술이나 기능에 대한 이해도를 확인하고, 그 사용 방법을 알고 있는지 검증하는 게 목적.

### 2.5.1 학습 테스트의 장점
* 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
* 학습 테스트 코드를 개발 중에 참고할 수 있다.
    - 코드를 계속 수정하면서 기능을 확인하기에 최종 수정한 예제 코드만 남는다.
* 프레임워크나 제품을 업그레이드할 때 호환성 검증을 돕는다.
    - 버전이 달라질 때 변화로 기존 코드에 문제가 생길 수 있다.
    - 마이너 버전 업그레이드 시 다른 버그가 발생해 문제가 생길 수 있다.
    - 학습 테스트를 만들어뒀다면 업데이트 적용 후 정상 동작이 이루어지는지 확인할 수 있다.
* 테스트 작성에 대한 좋은 훈련이 된다
* 새로운 기술을 즐겁게 공부할 수 있다
    - 책이나 공식 문서를 읽는 공부는 쉽게 지루해진다.


### 2.5.2 학습 테스트 예제
#### JUnit 테스트 오브젝트 테스트
* 아래와 같은 테스트 코드를 작성

```java
// import statements

public class JUnitTest {

    static JUnitTest testObject;

    @Test
    public void test1() {
        asserThat(this, is(not(sameInstance(testObject))));
        testObject = this;
    }

    @Test
    public void test2() {
        asserThat(this, is(not(sameInstance(testObject))));
        testObject = this;
    }

}
```

* 메소드가 호출될 때마다 testObject의 레퍼런스를 갱신.
    - 이를 set를 활용해 개선함.
    - 그에 대한 코드는 별도로 작성하지 않음(pp.201-202)
* 지금까지 배운 스프링의 기능들을 직접 학습 테스트를 작성해서 공부해보길 권장함.


### 2.5.3 버그 테스트
* 버그 테스트는 일단 통과하지 못할 테스트를 작성하는 것
    - 이에 대한 장점을 언급하고자 함.
* 테스트의 완성도를 높여줌
    - 불충분했던 테스트를 보완해줌
* 버그의 내용을 명확히 분석하게 해줌.
    - 버그로 인해 발생할 수 있는 다른 오류도 함께 발견 가능함.
* 기술적인 문제를 해결하는 데 도움이 됨
    - 원인을 파악하기 어려울 때, 문제가 발생하는 단순한 코드를 제보하면 도움이 많이 됨.

### 2.6 정리
* 테스트의 필요성과 작성 방법에 대해 공부하였음.
