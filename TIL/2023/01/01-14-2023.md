# **TIL on January 14th 2023**
## Problem Solving Using C++
### For fun: Silver 3 problem
#### [boj.kr/10974](../../../Problem%20Solving/boj/backtracking/10974-01-14-2023.cpp): solved on 1st try (memory: 2020 kB, time: 20 ms, Code length: 318 B)
* next_permutation로 매우 손쉽게 풀 수 있는 문제

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x12 Math
#### [boj.kr/1256](../../../Problem%20Solving/boj/Math/1256-01-14-2023.cpp): solved on 1st try (memory: 2340 kB, time: 0 ms, Code length: 899 B) 
* 이항계수를 활용해 접근하려 함.
* 다음 수가 튈 때 long long 범위까지 올라갈 수도 있으므로, cache 배열은 long long으로 선언할 것.

* 예를 들어 0이 2개, 1이 2개(0011) 있다고 하자.
  - 001X의 경우, 한 군데 중에 한 곳을 골라 일을 1개 배치해야 하기 때문에 1C1 = 1가지 경우가 있다.
  - 01XX의 경우, 두 군데 중에 한 곳을 골라 일을 1개 배치해야 하기 때문에 2C1 = 2가지 경우가 있다.
  - 1XXX의 경우, 세 군데 중에 한 곳을 골라 일을 1개 배치해야 하기 때문에 3C1 = 3가지 경우가 있다.
  - 즉, 0011의 배치는 1 + 2 + 3 = 6가지 경우가 존재한다.
* 이를 활용하여 아래와 같이 접근할 수 있다.
  - 2번째 경우를 찾아야 한다면, 첫 번째 1을 배치할 자리를 먼저 위 논리에 따라 결정한다. 001X는 1가지 경우가 있기 때문에(0011) 001X 형태는 아니다.
  - 01XX의 경우, 2가지 경우가 있다. 이전 001X 형태가 1개 있기 때문에, 01XX의 형태는 2번째부터 3번째 경우가 된다. 이는 0101과 0110이다.
  - 그렇기 때문에 가장 큰 1은 01XX 위치에 배치된다. 이후 동일한 논리로 다음 1의 위치를 잡는 것이다.
* 001X의 경우를 셌기 때문에, 우리는 01XX의 배치 중 1번째 배치를 찾아야 한다.
  - 010X의 경우 한 군데 중에 한 곳을 골라 일을 1개 배치해야 하므로 1C1 = 1가지 경우가 있다.
  - 결국 전체에서 2번째 경우는 01XX꼴의 1번째 경우이며, 이는 0101이다.

* 이같이 nCr을 계산하며 최고 자릿수 1부터 최저 자릿수 1까지 위치를 결정할 수 있다. 로직이 명확하지 않아서 헤맸지만, 각 자릿수를 올리면서 경우의 수를 계속해서 차감해줘야 한다. 그 코드는 아래와 같이 구현된다.
```cpp
int setplace(int topick) {
  int idx = topick - 1;
  while(1) {
    if(k - bi(idx, topick - 1) <= 0) break;
    k -= bi(idx, topick - 1);
    idx++;
    if(idx == nm) return -1;
  }
  return idx;
}
```
  - 자릿수가 `nm = n + m`을 넘어가면 우리에게 주어진 n과 m의 모든 경우의 수보다 큰 k값이 주어진 것이므로, -1을 반환하여 유효하지 않음을 전달했다.
  - 좀 더 간단하게 반복문과 조건문을 쓸 수 있는지 고민이 필요하다. 이 두 명령을 서술할 때 스스로도 충분히 납득하지 못 했었다.