[TIL on April 15th, 2023](../../../TIL/2023/04/04-15-2023.md)
## 섹션 7. 의존관계 자동 주입

### 다양한 의존관계 주입 방법
* 의존관계 주입 방법은 크게 4가지가 있다.
  1. 생성자 주입
  2. 수정자 주입(setter 주입)
  3. 필드 주입
  4. 일반 메소드 주입

#### 생성자 주입
* 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법
* 지금까지 우리가 진행한 방법이 생성자 주입임.
* 특징
  - 생성자 호출 시점에 딱 한 번만 호출되는 것이 보장됨
  - *불변, 필수* 의존관계에 사용. 이 특징이 굉장히 중요함.

* 접근과 생성 등을 잘 제한하는 게 좋은 프로그래밍임.

* 공연 중간에 배우를 바꿀 일이 없음.

* 간단하게 OrderServiceImpl 클래스를 살펴보자.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용, 필드인 MemberRepository를 꺼내는 메소드.
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }
}

```
  - 위와 같은 코드에서 주입받아야 하는 필드를 private final로 설정해 null을 피하면서 외부에서 딱 한 번만 접근 및 주입할 수 있도록 설정함.
  - 또한 생성자가 딱 1개 있다면 @Autowired를 생략할 수 있다. 그러나, 오버로딩을 통해, 다른 인자 입력으로 생성자를 호출할 수 있게 열면 @Autowired 없이 쓸 수 없다.

#### 수정자 주입
* 세터를 선언하고, 이를 통해 외부에서 주입하는 방식으로 구현.

```java

private MemberRepository memberRepository;

@Autowired
public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = jmemberRepository;
}
```

* 스프링 라이프 사이클 2단계
  - 빈을 생성하는 단계 / 의존 관계 주입하는 단계
  - 이렇게 두 단계로 나누고, 세부적으로는: 컨테이너 생성 -> 빈 등록 -> 의존 관계 설정 준비 -> 주입

* 다만, 생성자는 `OrderServiceImpl` 클래스를 구성하면서 바로 호출되기 때문에, 필드가 바로 할당된다. 스프링 컨테이너에서 생성자의 형태를 보고, 생성자에 건내줘야 하는 인자를 파악한 뒤, 이를 주입하는 방식.
* 그러나, 세터는 의존관계 주입 단계에서 따로 일어난다고 함. 물론, 이 둘이 꼬인다고 해서 주입에 문제가 발생하진 않을 듯함.

* *선택, 변경* 가능성이 있는 의존관계에서 활용함. 선택적으로 의존관계를 주입.
  - `@Autowired(required = false)`를 통해 선택적으로 쓸 수 있다.

> 참고: `@Autowired`의 기본 동작은 주입할 대상이 없으면 오류가 발생. 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)`로 설정을 해줘야 함.

* 자바빈 프로퍼티 규칙.
  - 세터 게터의 이름을 정하는 규칙이 있음.


#### 필드 주입
* 필드 그대로 값을 넣는다.

* 아래와 같이 @Autowired를 걸어서 연결할 수 있다.

```java
    @Autowired private final MemberRepository memberRepository;
    @Autowired private final DiscountPolicy discountPolicy;
```

* 필드 주입은 외부에서 변경이 불가능해서 테스트하기 어렵다는 단점이 있다.
  - 스프링 컨테이너가 아닌 순수한 자바로 테스트할 방법이 없다.

```java
@Test
void fieldInjectionTest() {
    OrderServiceImpl orderService = new OrderServiceImpl();
    // setter 추가 필요
    orderService.createOrder(1L, "1teimA", 10000);
}
```

* 결국 테스트를 위해 setter를 둬야하고, 간결함을 잃게 된다. 다만, @Autowired를 활용한 테스트 코드 작성 시엔 필드에 직접 주입해도 무방하기 때문에 '필드 주입'을 써도 된다.

* **순수 자바 코드로써 테스트할 일이 없는 코드들에만 적용하지 않으면 된다.** 그래도 필드 주입은 추천하지 않는다고 함(금하기 위해선 지원에서 아예 빼버리면 되지 않을까 싶음.)


#### 일반 메소드 주입
* 일반 메소드를 통해 주입 받을 수 있다.
* 특징
  - 아무 메소드에다가 주입 명령을 해버리는 것.
  - setter 메소드와 이름만 다른 듯함.
  - 생성자 주입과 생성자 주입을 자주 쓰지, 이런 독자 메소드를 통한 주입은 잘 하지 않는다.

> 참고: 의존관계 자동 주입은 스프링 콘테이너가 관리하는 스프링 빈이어야 동작한다. 스프링 빈이 아닌 `Member` 같은 클래스에서 `@Autowired` 코드를 적용한다 해도 아무 일도 일어나지 않는다.

<br>

### 옵션 처리
### 생성자 주입을 선택해라!
### 롬복과 최신 트랜드
### 조회 빈이 2개 이상 - 문제
### @Autowired 필드 명, @Qualifier, @Primary
### 애노테이션 직접 만들기
### 조회한 빈이 모두 필요할 때, List, Map
### 자동, 수동의 올바른 실무 운영 기준