# **Chapter 4. Beyond the Basics**

* 자바의 소켓을 활용한 프로그래밍 모델에 대해 2장에서 배웠다.
* 이제 이를 다양한 프로그래밍 모델에 적용해본다.

## 4.1 Multitasking
* 이터랙티브 서버(iterative server)
  - 이터랙티브 서버는 요청을 순차적으로 다룬다.
  - 하나의 요청을 마치면 다음 요청을 처리한다.
  - 이는 접속량이 적을 때 잘 동작한다.
  - 그러나, 어떤 요청은 처리하는 데 오랜 시간이 걸릴 수 있어 대기 시간을 예측하기 어려울 수 있다.
* 따라서, 우리는 각 연결을 독립적으로 처리하기 위한 방법을 찾아야 한다.
  - 자바 스레드는 정확히 이 역할을 수행할 수 있다.
  - 서버들이 많은 클라이언트 요청(clients)을 동시에 처리(handle)할 수 있게 된다.
  - 스레드 마다 각 클라이언트를 담당하도록 할 수 있다.
* 두 가지 접근 방식이 있음.
  1. thread-per-client: 클라이언트가 연결되면 새로운 스레드를 만들어서 할당함
  2. thread pool: 스레드들을 만들어놓고 클라이언트가 연결되면 할당함

### 4.1.1 Java Threads
* 자바는 새 스레드로 연산을 수행하는 두 가지 방법을 제공한다.
  1. 스레드 클래스의 서브 클래스를 정의하고 run() 메소드로 해당 작업을 처리
  2. Runnable 인터페이스를 구현하여 run 메소드에 해당 작업을 처리하도록 구현. 이후 스레드 클래스 생성자 인자로 해당 인터페이스를 넘김.
* 두 경우 모두 start() 메소드가 실행되기 전까지는 처리하지 않는다.
* Runnable 인터페이스를 구현해 넘겨주는 편이 확장성이 좋아 보통 그렇게 처리한다.
  - Runnable 인터페이스는 run 메소드 하나만 구현하도록 가지고 있다.
```java
interface Runnable {
    void run();
}
```

* 스레드의 start() 메소드로 작업을 지시하면 JVM은 인스턴스의 run() 메소드를 새 스레드에서 실행한다.
  - 그동안 작업을 지시한 메인 스레드(original thread)는 start() 호출에서 돌아와 다음 작업을 진행한다.
  - Note: 직접 run() 메소드를 호출하면 새로운 스레드가 생성되지 않는다.
  - 작업이 비동기적으로 이루어지므로 어떤 순서로 작업을 마치게 될지 알 수 없다.
* 위 과정을 구현하는 코드는 아래와 같다.
```java
import java.util.concurrent.TimeUnit;

public class ThreadExample implements Runnable {
    private String greeting; // Message to print to consolejava
    public ThreadExample(String greeting) {
        this.greeting = greeting;
    }

    public void run() {
        while (true) {
            System.out.println(Thread.currentThread().getName() + ": " + greeting);
            try {
                // Sleep 0 to 100 milliseconds
                TimeUnit.MILLISECONDS.sleep(((long) Math.random() * 100));
            } catch (InterruptedException e) {
            } // Should not happen
        }
    }

    public static void main(String[] args) {
        new Thread(new ThreadExample("Hello")).start();
        new Thread(new ThreadExample("Aloha")).start();
        new Thread(new ThreadExample("Ciao")).start();
    }
}
```

* 각각의 일을 수행하게 하는 것은 위 코드와 같은 식으로도 충분히 구현할 수 있다.
  - 다만, 수정할 데이터를 공유하는 경우에는 동시성이 문제가 되므로 주의를 요한다.

### 4.1.2 Server Protocol
* 위에서 서술한 멀티태스킹은 클라이언트-서버 프로토콜과는 무관하다.

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.logging.Level;
import java.util.logging.Logger;

public class EchoProtocol implements Runnable {

    private static final int BUFSIZE = 32; // Size (in bytes) of I/O buffer
    private Socket clntSock; // Socket connect to client
    private Logger logger; // Server logger

    public EchoProtocol(Socket clntSock, Logger logger) {
        this.clntSock = clntSock;
        this.logger = logger;
    }

    public static void handleEchoClient(Socket clntSock, Logger logger) {
        try {
            // Get the input and output I/O streams from socket
            InputStream in = clntSock.getInputStream();
            OutputStream out = clntSock.getOutputStream();

            int recvMsgSize; // Size of received message
            int totalBytesEchoed = 0; // Bytes received from client
            byte[] echoBuffer = new byte[BUFSIZE]; // Receive Buffer

            // Receive until client closes connection, indicated by -1
            while ((recvMsgSize = in.read(echoBuffer)) != -1) {
                out.write(echoBuffer, 0, recvMsgSize);
                totalBytesEchoed += recvMsgSize;
            }

            logger.info("Client " + clntSock.getRemoteSocketAddress() + ", echoed "
                    + totalBytesEchoed + " bytes.");
        } catch (IOException ex) {
            logger.log(Level.WARNING, "Exception in echo protocol", ex);
        } finally {
            try {
                clntSock.close();
            } catch (IOException e) {
                // blank
            }
        }
    }

    public void run() {
        handleEchoClient(clntSock, logger);
    }
}
```

* EchoProtocol 자체가 Runnable 인터페이스의 구현체
* 아래 코드에서 의문이 듦.

```java
public void run() {
    handleEchoClient(clntSock, logger);
}
```
* handle을 하려면 EchoProtocol의 인스턴스가 있어야 할 것
  - 이에 따르면 이미 필드에 clntSock과 logger가 세팅된 상태일 것
  - 그런데 왜 46번째 줄에서는 handleEchoClient 호출 과정에 다시 인자로 (clnkSock, logger)를 전달하는가?

* Logger 클래스에 대해서
  - 서버에 문제가 발생했을 때 로그를 통해 확인할 수 있다.
  - 다음 명령을 통해 하나의 인스턴스를 받을 수 있으며, 이는 싱글톤으로 설계되어 있다.
  - `Logger logger = Logger.getLogger("practical");`
* 로거의 레벨, 심각도(severity), 로그 엔트리
  - 내장 레벨: severe, warning, info, config, fine, finer, finest.
* 로거는 핸들러에게 메시지를 전송한다.
  - 핸들러는 최소 로그 레벨밖에 없기 때문에 메시지의 수준이 로거와 핸들러의 한계치보다 높아야 한다.
  - (이 부분은 로그에 대한 기본 지식이 없어서 잘 이해가 안 됨)
* 로그는 멀티스레드 환경에 대해 안전하다(thread-safe)

### 4.1.3 Thread-per-Client
* *To be continued*
