# **TIL on January 5th 2023**
### Problem Solving Using C++
#### BOJ step by step: stack 2
##### [boj.kr/17299](../../../Problem%20Solving/boj/Stack/17299-01-05-2023.cpp): solved on 1st try (memory: 13740 kB, time: 224 ms, Code length: 641 B)
- Ai의 등장 횟수를 나타내는 F(Ai) 배열은 크기 1'000'001로 선언하여, 1이상 1,000,000 이하 범위 Ai의 값들을 받아두자. 이로써 F(Ai)를 확인해야 할 때, O(1)로 인덱싱해 값을 확인할 수 있다.
- 오등큰수 배열은 `ans[MX]`로 선언하고, -1로 초기화하자.
- 주어진 배열 A의 가장 큰 인덱스부터 차차 내려오는 방식으로 i를 이동한다. 이때, i번째 원소를 보고 있다고 하자. 스택이 비지 않는 동안에 스택의 top 값을 확인하면서 pop한다.
  * 중간에 top에 자기 보다 빈도가 큰 애가 나오면 `ans[i]`를 해당 값으로 채운 뒤 자신을 스택에 넣는다. 이후 다음 인덱스로 넘어간다.
  * 스택이 비었다면 자기 자신을 스택에 넣고 다음 인덱스로 넘어간다.
- 스택 문제들은 아직 직관적으로 와닿지 않아 여전히 까다롭다. 자연스럽게 수학적 모델을 떠올리는 방법을 훈련하자.

#### BOJ step by step: Dynamic programming
##### [boj.kr/11066](../../../Problem%20Solving/boj/Dynamic%20programming/11066-12-28-2022.cpp): try to solve
* 이 문제는 최적 부분 구조가 성립한다. 지금까지 밟아온 루트가 최종적으로 모든 항의 합에 이르기까지 도달하기 위한 최소 코스트와 아무런 관계가 없기 때문이다.

* 백트래킹을 하긴 하되, DP로 계산된 부분은 바로 불러올 수 있게 함.
* 연산자 사용 여부를 `vector<bool>`로 표현하고, `unordered_map<vector<bool>, int>`로 가져오자.
  - 예를 들어 a, b, c, d, e, f, g, h라는 8개 항이 있다고 하자. *i*번째 연산자는 *i*번째 항과 *i + 1*번째 항 사이에 위치한 연산자를 뜻하며, 0이면 두 항이 더해지지 않았음을, 1이면 두 항을 서로 더한 상태임을 의미한다.
  - 예시: `0110101`, a / b + c + d / e + f / g + h
  - 그러나, 이 경우 최대 499개 요소로 배열을 인덱싱해야 하며, 단순하게 생각해도 현재 상태 정보가 2^499개인데, 연관 배열이 정상적으로 작동할 수 없을 것이라 생각함. 메모리도 말도 안 되게 많이 잡아먹고, 동작 시간도 느릴 것: 문자열로도 해싱이 가능한데, bool 동적배열 정도는 쓸 수 있지 않을까?

* 다르게 푸는 방법을 찾아보자.
  - 파일 합치기는 파스칼의 삼각형이나 정수 삼각형 문제와 닮은 듯함.
  - 정수 삼각형 역시 경로를 내려오면서 갱신함.
  - `long long solve(int st, int en)` 함수를 다음과 같이 정의하자: st부터 en까지 배열을 합치는 최소 비용을 반환하는 함수
    * st와 en으로 캐시 배열을 만들 수 있다: `cache[502][502] // cache[st][en] = (min. value)`
    * 기저 사례: `st == en`이면 `0`을 반환. 합칠 때 발생하는 비용을 부분 합을 통해 계산하고 반환하는 방식으로 구현함.
    * 한 조각씩 떼어내며 캐시에 값을 갱신하는 방식
