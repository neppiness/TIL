# **TIL on March 6th, 2023**
### S3 to G3 Problems
#### [boj.kr/1516](../../../Problem%20Solving/boj/random%20defense/1516-03-06-2023.cpp): solved on 1st try (memory: 2440 kB, time: 4 ms, Code length: 977 B)
* 위상 정렬 연습 문제. 우선순위 큐를 선언해서 총 비용이 낮은, 그러니 시간적으로 빨리 완성될 건물을 확인하는 방식으로 구현함.
  - ind를 누구에게 부여해야 하는지 잘못 생각했었음. 이런 부분에 대한 주의가 필요.
<br>

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x0D 시뮬레이션
#### [boj.kr/17471](../../../Problem%20Solving/boj/Simulation/17471-03-06-2023.cpp): solved on 2nd try (memory: 2028 kB, time: 0 ms, Code length: 1414 B)
* next_permutation을 활용해서 팀원을 하나씩 늘리면서 n 중에서 최대 n/2까지 선택하는 경우에 대해 인접 여부를 확인하고, 선거구 인구 차이의 최솟값을 출력함. ans = INF로 선언하고, INF가 유지되는 경우 -1 출력.
  - 10C1, 10C2, 10C3, 10C4, 10C5는 10, 45, 120, 210, 252이기 때문에, 더 효율적으로 팀을 나눌 필요는 없음.
* 예제 입출력을 잘못 받아서 1번째 제출 WA.
  - 간선 입력을 아래와 같이 수정해서 받음

```cpp
for(int i = 0; i < n; i++) {
  int m; cin >> m;
  while(m--) {
    int x; cin >> x;
    adj[i].push_back(x - 1);
  }
}
```

* PR용 주석
```cpp
/*
next_permutation을 활용해 comb가 1인 구역을 하나씩 늘린다.
이로써 n개 구역 중 1개 구역부터 n/2개 구역까지 선택하며 선거구를 구성한다.
구역이 속한 선거구는 comb 값에 따라 구분한다.

이같이 구현하는 경우, 0011과 1100을 다른 경우로 판단해 중복 연산이 발생한다.
그러나, n이 가장 클 때인 10개 구역에 대해서
1명부터 5명씩 팀을 나누는 경우가 10C1 + 10C2 + 10C3 + 10C4 + 10C5이고
이들은 10 + 45 + 120 + 210 + 252 = 637이기 때문에,
더 효율적으로 팀을 나눌 필요는 없다고 판단하였다.

문제를 그래프로 구현했다.
문제의 구역 번호는 1-indexed지만, 편의상 0-indexed로 바꿔 구현하였다(69-75번째 줄).

구역 중 comb 값이 0인 경우와 1인 경우를 하나씩 찾아 bfs를 수행(45-48번째 줄)한다.
이때, 인접한 구역 중 동일 선거구에 속한 구역만 방문하고 큐에 넣는다(26-31번째 줄).

만약 comb 값이 0인 구역과 1인 구역에 대한 bfs를 마친 뒤에도 
방문횟수를 세는 viscnt 변수가 n에 도달하지 못했다면,
이는 인접하지 않은 구역이 있는 것이므로
인구 차이를 계산하지 않고 다음 경우로 넘어간다.

이같이 계산된 최솟값을 답으로 출력한다.
만약, 모든 경우에 대해 선거구가 나눠지지 않는다면
ans은 갱신되지 않아 INF이므로, 이 경우 -1을 출력한다.
*/
```
<br>

### Practice
#### [boj.kr/1738](../../../Problem%20Solving/boj/Graph/1738-03-06-2023.cpp): solved on 9th try (memory: 2168 kB, time: 4 ms, Code length: 1641 B)
* 벨만-포드 알고리즘 활용 문제
* 최적 경로의 정의: 민승이네 집에서 출발하여 코레스코 콘도에 도착하는 경로 중 금품의 양이 최대가 되는 경로
  - 계속해서 최댓값을 가져갈 건데, 이 경우, 값이 양수인 사이클이 있으면 최적경로가 존재하지 않게 된다.
* 1, 4번째 제출: 82퍼센트에서 WA.
  - 최적 경로와 직결되는 경우에만 update 되었다고 판정되도록 구현해야 할 듯함.
* 2, 3번째 제출: 89페선트에서 WA.
  - 구현을 수정하여 `if(it != n || nxt == n) is_updated = 1;`으로 update 조건을 바꿨지만 오답.
* 6번째 제출 WA: long long으로 수정하고 제출했으나 오답. 정수 오버플로우는 당연히 아님.

* 최적 경로가 존재하지 않는 경우에 대해 면밀히 살펴보자.
  - 콘도에 도착한다는 보장이 문제에 없기 때문에, 시작점과 연결되지 않아 얻은 금품의 양이 음의 무한대에 가깝다면 -1을 출력하는 로직을 추가해봤지만 WA.

* 도착하지 못하거나, 무한히 금품을 얻을 수 있는 경우엔 최적경로가 존재하지 않는다.
  - 반면, 음수의 사이클이 있다 하더라도 이를 피해서 콘도에 도착할 수 있다면 문제가 되지 않는다.

* 갱신된 노드의 연결성을 확인하는 것이 가장 중요한 문제였다.
  - 이에 대한 기록은 모든 노드를 기점으로 두고 시작하는 bfs를 수행해서 목적지인 n에 도달할 수 있는가 확인하는 작업이 필요하다.
  - 마지막에 updated된 노드가 있다면 그 노드가 목적지인 노드에 영향을 미칠 수 있는지 판단해야 한다. 영향이 없는 노드라면 문제 없는 것이므로 답을 출력해도 된다.
  - 완화하는 작업 전에 아직도 cur의 거리(여기서는 금품의 양인 val 변수)가 초기상태라면 굳이 해당 노드에 대한 간선들을 확인할 필요가 없다. 어떻게 하더라도 결국 cur에 인접한 노드들의 거리(가치)가 갱신될 일은 없기 때문이다. 이에 대한 구현은 다음과 같다: `if(val[cur] == MINF) continue;`