# **TIL on January 25th, 2023**
### 최소 신장 트리 복습
### [BaaaaaaaarkingDog Practical Algo. Lecture: 0x1B 최소 신장 트리](https://baaaaaaaaaaaaaaaaaaaaaaarkingdog.tistory.com/1024)
#### 정의
* 보조 개념
  - 부분 그래프: 주어진 그래프에서 일부 정점과 간선만을 택해서 구성한 새로운 그래프를 의미함
  - 신장 트리: 주어진 방향성이 없는 그래프의 부분 그래프(Subgraph)들 중에서 **모든 정점을 포함하는 트리**를 뜻함
  - 주어진 그래프가 연결 그래프일 때만 신장 트리가 존재.
  - 연결 그래프: 임의의 두 정점을 연결하는 경로가 존재하는 그래프
* 최소 신장 트리: 신장 트리 중에서 간선의 합이 최소인 트리

#### 크루스칼 알고리즘
* 사이클을 만들어내지 않는 선에서 비용이 작은 간선부터 최소 신장 트리에 편입시키는 그리디 알고리즘
  - 사이클을 생성하지 않기 위한 효율적인 방법으로 유니온-파인드 자료 구조를 활용함. 이를 통해 같은 그룹에 속한 정점을 한 번 더 합치지 않도록 제어.

#### 프림 알고리즘
* 한 정점을 출발점으로 하는 간선 중에서 비용이 최소인 간선을 선택한 뒤, 간선의 도착점이 이미 선택되었는지 여부를 확인함.
  - 이미 선택된 정점일 경우 다음 간선을 확인함.
  - 선택되지 않은 정점이라면 선택 후 해당 정점을 출발점으로 하는 모든 간선을 비용과 함께 우선순위 큐에 넣음.
  - 간선이 V-1개 선택될 때까지 이 과정을 반복함.


### BOJ step by step: 최소 신장 트리
#### [boj.kr/4386](../../../Problem%20Solving/boj/Minimum%20spanning%20tree/4386-01-25-2023.cpp): solved on 1st try (memory: 2308 kB, time: 0 ms, Code length: 1025 B)
* 간단한 MST 문제임.
* 소숫점 둘째 자리까지 출력하는 방법은 아래와 같음. 자주 안 써서 까먹기 쉬우니 기억할 것.

```cpp
  cout.precision(2);
  cout << fixed;
```

* 크루스칼로 구현하는 게 편함. 원래 정석대로면 같은 그룹인지 아닌지 파악한 뒤에 같은 그룹이면 넘어가고, 다른 그룹이면 merge를 수행하는 게 맞음. 바킹독 풀이 PR용이 아니라면 구분해서 구현하자.

* 앞으로 크루스칼 알고리즘을 구현할 때는 아래와 같이 할 것.

```cpp
  for(auto [dist, u, v] : e) {
    u = find(u); v = find(v);
    if(u == v) continue;
    merge(u, v);
    ans += dist;
    cnt++;
    if(cnt == n - 1) break;
  }
```
  - u와 v의 조상을 찾고, 둘이 같으면 넘어감. 아니면 머지함.
  - 간선 비용을 더하고, 간선 개수(cnt)를 1 증가시킴
  - 간선 개수가 (정점 개수 - 1)이 되면 종료.


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1B 최소 신장 트리
#### [boj.kr/13418](../../../Problem%20Solving/boj/Minimum%20spanning%20tree/13418-re-01-25-2023.cpp): solved on 2nd retry (memory: 11376 kB, time: 176 ms, Code length: 924 B)
* 단순하게 비용을 0과 1이라고 생각하고, 한 번은 MST를 구하고, 다른 한 번은 정렬해둔 간선을 끝에서부터 돌아오면서 신장 트리를 구하면 될 듯함.
* 0번부터 n번까지 정점이 있기 때문에 총 n + 1개의 정점이 있으며, MST의 간선 수는 n개가 되어야 함.
  - 간선 선택 중에 `if(cnt == n) break;`로 구현
* 이게 MST를 만들어놓고, 입구에서부터 방문을 시도해야 하는 것으로 이해됨.
* 모두 오르막길이라 하더라도 최대 999번의 오르막길만 오르면 되고, 피로도를 계산하기 위해 제곱하더라도 백만 정도기 때문에 인트 오버플로우가 발생하진 않음.

* **조건 제대로 읽지 않으면 뭘 구현해도 틀린다.**
  - 오르막길이 0, 내리막길이 1이었음. 이거 반대로 받아서 지금까지 틀림.


### Solved.ac Class Problems: Class 5 Essential
#### [boj.kr/2098](../../../Problem%20Solving/boj/solvedac/2098-01-24-2023.cpp)