# **TIL on February 5th, 2023**
### [Linear transformations and matrices | Chapter 3, Essence of linear algebra](../../../Math/vectors-02-02-2023.md)


### BOJ Step by Step: Minimum Spanning Tree
#### [boj.kr/1774](../../../Problem%20Solving/boj/Minimum%20spanning%20tree/1774-02-05-2023.cpp): solved on 1st try (memory: 14464 kB, time: 56 ms, Code length: 1189 B)
* 재채점 후 틀린 문제. 처음부터 다시 풀어보자.
  - hypot 함수를 쓰자. epsilon 값을 둬서 그 안으로 들어오게 수정할 것: 입실론이 필요가 없던 게, 계산 오차 범위가 그렇게 크지 않았음. 백만 단위 값들에 소숫점 둘째자리까지 정확히 출력해야 했기 때문.

```cpp
  for(auto [co, u, v] : e) {
    int pu = find(u);
    int pv = find(v);
    if(pu == pv) continue;
    merge(pu, pv);
    ans += co;
    cnt++;
    if(cnt == n - 1) break;
  }
```

* 위와 같은 코드를 작성하는데, `int pu = find(u);`, `int pv = find(v);`와 `pu == pv`에 대한 확인이 중복해서 일어남.

```cpp
bool try_merge(int u, int v) {
  u = find(u); v = find(v);
  if(u == v) return 0;
  if(p[u] > p[v]) swap(u, v);
  p[u] += p[v];
  p[v] = u;
  return 1;
}
```

* 두 노드 u와 v만 받아서 머지가 필요한지 확인하고, merge 했다면 했다고 true를 반환. 하지 않았다면 false를 반환.
* 이후 MST를 구축할 때는 아래와 같이 간선을 확인하면 시도

```cpp
  for(auto [co, u, v] : e) {
    if(!try_merge(u, v)) continue;
    ans += co;
    cnt++;
    if(cnt == n - 1) break;
  }
```

* 결국 바킹독 강의의 isDiffGroup과 동일한 형태가 됨. `int pu = find(u); int pv = find(v);` 구문이 좀 더 의미가 명확하고 실수를 적게할 수 있을 듯함. 코드 길이 차이도 많이 나지 않기 때문에 둘 중 어느 쪽이 좀 더 명료한지 생각해보기.


### KMP와 트라이 복습
#### [[실전 알고리즘] 0x1E강 - KMP](../../../Computer%20Science/Algorithm/kmp-algo-09-28-2022.md)
#### [[실전 알고리즘] 0x1F강 - 트라이](../../../Computer%20Science/Algorithm/trie-10-01-2022.md)