# **TIL on January 8th 2023**
### Problem Solving Using C++
#### BOJ step by step: Dynamic programming
##### [boj.kr/2629](../../../Problem%20Solving/boj/Dynamic%20programming/2629-01-06-2023.cpp): solved on 3rd try (memory: 3740 kB, time: 0 ms, Code length: 914 B)
* 문제 재정의: *x*가 구슬 무게라고 하면, 무게 차가 *x*가 되는 추들의 조합을 만들 수 있는가?
  - 완탐으로 푼다고 가정하자: 총 추 개수가 *n*이라고 하면, *x*와 같은 추가 있는지부터 확인하기 시작해서, 추를 사용하는 모든 경우의 수를 확인한다.
  - 어떻게 중복 문제를 많이 만들 것인가?

* 입력 수 확인: 추의 개수가 30 이하이기 때문에 넣고 빼는 데만 2^30 - 1개의 경우의 수가 생기며, 이를 서로 더하고 빼면... 고작 7개 이하의 구슬에 대해 파악한다고 해도 시간초과가 날 수밖에 없다.

* 함수 정의: 간단하게 입력 받은 구슬 무게 *x*를 만들 수 있다면 true를, 만들 수 없다면 false를 반환하는 bool 함수, `bool solve(int x)`로 정의하자.
  - 기저 사례: 입력 받은 추 무게에 도달하면 해당 구슬 무게를 만들 수 있다고 반환한다.
  - 이 함수가 참조할 cache는 0부터 40,000까지 인덱스로 쓰일 수 있는 크기 40,001의 정수형 변수 배열 `int cache[40'001]`로 선언한다.
  - 이 배열은 -1, 0, 1을 저장한다. 해당 무게에 대한 표현 가능 여부를 계산하지 않은 경우 -1 값을 갖는다. 가능하거나 불가능한 경우엔 각각 1과 0을 사용한다.
  - 점화식: 해당 구슬 무게를 만들 수 있는지 여부를 판단하는 점화식을 구성해야 함.

* DP가 아닌 직관에 따른 접근
  - 첫 번째 시도: 실패했음. BFS로 순회하는 것처럼 지금까지 조합했던 무게를 다 구하는 로직을 구현했으나, 이는 모든 경우의 수가 아니었음.
  - 두 번째 시도: 로직을 바꿔서, 이미 얻은 조합 값이 나오더라도 추를 더 추가하고 계산하도록 했으나, 1초 안에 통과할 수 없는 논리였음. 아마 모든 경우의 수는 확인할 테지만 이 풀이는 시간 복잡도가 너무 큼.

* 풀이 발상: 임의의 구슬 무게 *x*에 추 무게가 *a1*, *a2*, *a3*, ..., *an*으로 주어졌다고 하자.
  - 3개의 추를 활용해 구슬의 무게를 만들 수 있다는 건 다음 등식이 성립한다는 것이다: `x = a1 + a2 + a3`
  - 다음과 같은 방법도 가능하다: `x + a2 = a1 + a3 => x = a1 - a2 + a3`
  - 그러므로, bool 값을 반환하는 함수 `bool solve(vector<int> weight, int x)`는 추의 무게들을 더하거나 빼는 선형 조합을 만들어 *x*를 만들 수 있는 경우 참을 반환하고, 불가능한 경우 거짓을 반환하는 함수로 정의한다면, 이 문제의 답을 출력할 수 있다.
  
* 약간 수정해서 무게 추를 하나씩 추가하면서 만들 수 있는 무게를 체크하는 방식으로 진행할 것.
  - ex) a1, a2, a3가 있다고 하고, 이들을 조합해서 만들 수 있는 무게를 다음 표와 같이 순회하며 채운다.
  - a1을 활용해 만들 수 있는 조합은 0, a, -a이며, 이는 1번째 행에 만들 수 있는 조합으로 표시된다.
  - a2를 붙여 만들 수 있는 조합은 a1으로 만들 수 있는 조합들을 찾아서 +a2, -a2, +0을 한 값을 만들 수 있는 조합으로 표시해주면 된다.
* 이러한 알고리즘은 아래와 같이 구현할 수 있다.

```cpp
void solve() {
  // initialize
  int val[] = {-w[0], w[0], 0};
  for(int i = 0; i < 3; i++) {
    int idx = val[i] + CF;
    ispossible[0][idx] = 1;
  }
  // calc.
  for(int i = 1; i < n; i++) {
    val[0] = -w[i];
    val[1] = w[i];
    for(int j = 0; j < MX; j++) {
      if(!ispossible[i - 1][j]) continue;
      for(int k = 0; k < 3; k++) {
        int idx = j + val[k];
        ispossible[i][idx] = 1;
      }
    }
  }
}
```

* 만약 재귀적으로 풀어야 했다면 풀이 함수에 어떤 의미를 부여하고 접근했어야 했나?
  - 1번째부터 n번째 추를 조합해 해당 구슬 무게를 만들 수 있는지 그 여부를 반환하는 함수를 만들고, 순차적으로 1번째부터 n-1번째 추까지 활용하는 경우, 1번째부터 n-2번째 추까지 활용하는 경우를 호출하는 방식으로 접근해 풀 수 있을 듯하다.

##### [boj.kr/7579](../../../Problem%20Solving/boj/Dynamic%20programming/7579-01-08-2023.cpp): 5-time failed, going to re-write solution
* 공간적 제약을 감안하여 최적화한 냅색을 구현함.
* 1번째 시도: 메모리 초과 / 2, 3번째 시도: 오답
  - 3번째 시도할 때, ans를 0x3f3f3f3f로 초기화했던 게 잘못된 건가 싶어 수정했지만 여전히 오답임.
* 풀이가 잘못된 건 아닌지 살펴보자. 디버깅 중.

* 현재 모든 앱이 켜져있고, 이중 일부를 꺼서 M 바이트 이상의 메모리를 확보해야 하는 건데... 이게 그냥 앱들을 끄는 조합을 싹 다 뒤져서 그 중 M 바이트 이상이 되는 것 중에 비용이 최소인 걸 고르는 문제랑 뭐가 다르지?

* 4, 5번째 시도: 시간 초과. 정렬을 만만하게 봤음. 정렬해야 하는 가짓 수가 최대 천만이고, 이를 100번 정렬하면 무조건 시간초과가 남.

##### [Resolve boj.kr/7579](../../../Problem%20Solving/boj/Dynamic%20programming/7579-re-01-08-2023.cpp): solved on 2nd try (memory: 6004 kB, time: 4 ms, Code length: 905 B)
* Cost 총합이 상대적으로 작기 때문에 코스트 합을 싹 하면서, 그 안에 메모리의 max 값을 갱신. 필요한 메모리 양보다 크거나 같은 코스트 중, 가장 작은 코스트를 정답으로 반환.
* 첫 번째 시도(전체로 6번째)는 일단 오답.
  - 수정 전 코드: `cache[i][j] = cache[i - 1][j];`
  - 이는 이전 연산 결과가 반영된 자리에서 단순 할당으로 계산된 캐시 값을 가져오기 때문에 오답을 도출한다.
  - AC된 코드의 solve 함수는 아래와 같다.

```cpp
void solve() {
  memset(cache, -1, sizeof(cache));
  cache[0][0] = 0;
  for(int i = 1; i <= n; i++) {
    for(int j = 0; j <= MX; j++) {
      if(cache[i - 1][j] == -1) continue;
      // 수정 전: cache[i][j] = cache[i - 1][j];
      cache[i][j] = max(cache[i][j], cache[i - 1][j]);
      int m = mem[i - 1];
      int c = cost[i - 1];
      cache[i][j + c] = max(cache[i][j + c], cache[i - 1][j] + m);
    }
  }
}
```

* 공간 복잡도를 낮출 수 있는 키가 따로 있어서 신선한 문제였음. 여전히 냅색 문제를 구현하는 데 어려움을 겪으니 더 많은 DP 문제를 풀어보는 편이 좋을 듯함.
  - 이전에 구현했던 대로 solve 함수를 게층 별로 나눠 for문을 함수 내에서 한 번만 돌게 했으면 코드 가독성이 더 높았을 것이라 생각함.