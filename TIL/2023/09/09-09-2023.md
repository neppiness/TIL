**TIL on September 9th, 2023**

## PS Using C++
### BOJ#14466: 소가 길을 건너간 이유 6
* 유니온 파인드로 구하면 될 듯함.
  - 못 가는 간선을 만들고, 이를 표시해두는 식으로 풀이.
  - BFS든 DFS든 수행해서 컴포넌트 구분.
* 출력 실수, 인덱스 실수로 2번 틀림
* 3번째 제출 AC
  - 메모리 2104 kB, 시간 4 ms, 코드 길이 1580 B

## Some Insight
### [Where Does Bad Code Come From?](https://youtu.be/7YpFGkG-u1w)
* 문법 등을 모를 때는 자유분방하게 무의미한 타이핑을 함
  - 이후 숙련되면 문법에 맞는 코드를 짬
  - 이후 특정 패턴을 학습하고 체득하면 관성에 따라 자신에게 익숙한 형태의 코드를 작성함
* 프로그램을 탐험에 비유함
  - 예전에는 성공과 실패가 극명했음. 하드웨어의 제약에 따라 성능이 좋은 코드를 쓸 수밖에 없었다.
  - 지금은 프로그램을 돌리긴 쉬움. 그러나 성능이 좋지 않은 코드가 남발함.
* SOLID 원칙은 탐험에 적절한 도구가 아니라 망치를 쥐어준 거라 빗댐
  - 그러면서 이 망치가 탐험에 중요하다고 얘기하는 것이라 함
* 그래서 왜 나쁜 코드(성능이 안 좋은)들이 발생했는가?
  - 우리가 더이상 제대로 된 지침인 성능을 활용하지 않고 의식에 가까운 SOLID, 그리고 그외 클린코드 규칙을 따르기 때문이라 함
  - 심지어 SOLID 원칙은 측정 가능하지도 않다고
* WARMED 원칙
  - 모든 것은 비용이 있다. 코드 실행도 비용이다. 읽는 데 드는 시간 역시 비용이다.
  - 이 비용을 최소화시키는 방법이 좋은 코드를 작성하기 위한 지침이다.
  - Write / Agree / Read / Modify / Execute / Debug
  - 쓰고, 동의하고, 읽고, 수정하고, 실행하고, 디버그한다.
  - 이런 과정이 쉽게 이루어질 수 있도록 해야 한다는 의미인 듯.
> 어쨌든 이에 대한 반론이 될 수 있는 건: 클린코드가 사실 읽기 좋은 코드를 만드는 데 목적이 있다는 점을 인지해야 함.

<br>

## Vrew 데스크톱 앱 개발자
* C++에서 다형성을 어떻게 구현하는가?
  - virtual 키워드와 상속을 활용하여 구현
* Mutex Locks

