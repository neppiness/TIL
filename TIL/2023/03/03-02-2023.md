# **TIL on March 2rd, 2023**
### S3 to G3 Problems
#### [boj.kr/5582](../../../Problem%20Solving/boj/random%20defense/5582-02-22-2023.cpp): solved on 4th try (memory: 2156 kB, time: 68 ms, Code length: 792 B)
* 공간 복잡도를 낮추기 위해 길이별로 solve 함수를 시도하려 함.
  - substring의 비효율적인 동작 때문인지, 해쉬를 써도 시간 초과 발생.
* KMP를 활용할 생각이 들었음. lck의 앞 글자를 하나씩 떼면서 매칭을 시도.
  - 가장 길게 매칭된 기록을 남기는 방식으로 활용할 수 있을 것.
  - pop_front를 활용하는 경우, $O(N^2)$으로 동작하긴 할 것. 제곱하면 16,000,000이라 적지 않은 숫자긴 함.
  - 인덱스를 잘 조정해서 써보자.
* substr으로 앞글자를 하나씩 떼면서 매칭 시도함.
* 사실 DP 문제였음... 해쉬인 줄 알고 시도했던 게 계속해서 문제가 됐던 것.
  - 모든 길이에 대한 substr도 $O(N^2)$이고, 이에 전체적인 확인도 $O(N^2)$이라 될 것이라 판단했는데, 결과적으론 잘못 판단했던 것.
<br>

### 단계별로 풀어보기 | 백준: 기하 2
#### [boj.kr/20149](../../../Problem%20Solving/boj/Math/20149-02-13-2023.cpp): solved on 9th try (memory: 2020 kB, time: 0 ms, Code length: 2185 B)
* 재시도: 6번 WA 받은 상태

* int형 변수를 받고 내적을 하든 외적을 하든 하는 게 좋을 것 같음
* 혹시 0.001정도 되는 EPS 값을 더하고 캐스팅하지 않아서 틀릴 수 있으니 염두에 둘 것.

* 방향 벡터인 $(\vec{v_{2}} - \vec{v_{1}})$와 $(\vec{v_{4}} - \vec{v_{3}})$이 평행하지 않은 경우
  - $\vec{l_{1}}$ = $\vec{v_{1}} + p \times (\vec{v_{2}} - \vec{v_{1}})$, $\vec{l_{2}}$ = $\vec{v_{3}} + q \times (\vec{v_{4}} - \vec{v_{3}})$으로 두고 접근할 때, $p = {{(\vec{v_{3}} - \vec{v_{1}}) \times (\vec{v_{4}} - \vec{v_{3}})} \over {(\vec{v_{4}} - \vec{v_{1}}) \times (\vec{v_{4}} - \vec{v_{3}})}}$로 계산할 수 있음.
  - 이때 해당 값이 0이상 1이하인지 확인하는 로직으로 교점이 내부에 존재하는지 파악할 수 있으며, 벡터를 정수형 변수로 저장한 상태라면 해당 연산을 분자와 분모의 크기 비교를 통해 오차 없이 수행할 수 있다.
  - 마찬가지로 q를 찾고, p와 q 모두가 0이상 1이하라면 교점이 존재하는 것으로, 이를 계산해 출력한다.
* 방향 벡터인 $(\vec{v_{2}} - \vec{v_{1}})$와 $(\vec{v_{4}} - \vec{v_{3}})$이 평행한 경우
  * $(\vec{v_{2}} - \vec{v_{1}}) \times (\vec{v_{3}} - \vec{v_{1}})$이 0이 아닌지 확인.
    1. 0이라면 두 선분을 통해 삼각형이 만들어지지 않는 상태이므로, 일직선 상에 있다고 판단 가능.
    2. 0이 아니라면 만나지 않고 평행한 상태라 판단 가능.
  * 이 역시 정수형 변수의 연산만으로 확인 가능하기 때문에 온전한 판단이 가능함.
* 두 선분이 일직선 상에 위치한 경우
  - 벡터 1, 2와 벡터 3, 4의 대소 관계를 따져 판별.

* 구조체 생성자를 보자.
```cpp
struct vec {
  ll x, y;
  explicit vec(ll x_ = 0, ll y_ = 0): x(x_), y(y_) {}
};
```
  - 위와 같이, `vec(ll x_ = 0, ll y_ = 0)`로 구현하면 `vec a;`와 같은 방식으로 구조체를 선언해도 문제가 발생하지 않는다. 그리고 a.x와 a.y는 모두 0으로 초기화 된 상태가 된다.
  - 만약, `vec(ll x_, ll y_)`로 구현하면 `vec a;`만으로는 vec 구조체 a를 선언할 수 없게 된다(컴파일 에러).

* 7, 8번째 제출 WA.
```cpp
long long nu_p = v31.cross(v43);
long long nu_q = v31.cross(v21);
```
  - 이 둘의 값이 0인 경우 부호 비트가 반대인지 아닌지 따질 필요가 없었는데, 그에 대한 고려를 하지 못했음.
  - 이번에 구현한 로직이 깔끔한 게, 부동 소수점 연산에 대한 고민을 할 필요 없이 판정이 정확함. 이후 교점을 구할 때만 부동소수점 연산을 수행하면 됨.
  - 이를 수정한 뒤 9번째 제출 AC.