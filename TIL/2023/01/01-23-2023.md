# **TIL on January 22nd, 2023**
### BOJ step by step: 유니온 파인드
#### [boj.kr/4195](../../../Problem%20Solving/boj/Union%20find/4195-01-22-2023.cpp)
* 랭크를 사람 수로 갱신하면 무난하게 풀릴 듯함.

* 해쉬로 구현하니 메모리 초과.
  - 트라이로 구현해야 하는가?
  - 알파벳 대소문자를 사용하니 52개 문자고, 길이 20 이하의 문자열. 그렇게 많은 메모리가 들진 않을 것.
  - 이 가정이 잘못되었던 게, 해쉬는 필요한 문자열 길이 총합만큼 노드가 필요함. 그리고 그 노드가 52개의 인접 행렬을 가지고 있어야 되는 방식이라 무조건 메모리 초과임.
  - 따라서 해쉬보다 느리지만, 이진 트리 기반이라서 공간 효율이 좋을 map으로 구현해본다.

* map은 삽입, 검색 모두 O(lgN)에 수행하고, 그렇게 알고리즘 시간 복잡도가 O(NlgN)이 된다. 그러나 N이 200,000 정도이기 때문에 문제 없이 통과되리라 예상한다.
  - 시간으로는 문제가 없던 듯한데, map 역시 메모리가 초과됨.

* 조건을 잘못 사용했기 때문에 문제가 발생함.
  - 둘의 조상이 같을 때도 유니온(함수 merge)을 수행했음. 이를 방지하기 위해 `if(u == v) return;`를 추가함.
  - 하나 배운 것은 논리가 틀려도 메모리 문제가 발생할 수 있단 점.


### S3 to G3 random defense
#### [boj.kr/19637](../../../Problem%20Solving/boj/random%20defense/19637-01-23-2023.cpp): solved on 1st try (memory: 5540 kB, time: 56 ms, Code length: 464 B)
* 이분탐색 lower_bound를 구현해야 함.
* 이분탐색 조건에 대해 좀 더 이해가 필요할 듯.

```cpp
  while(st < en) {
    int mid = (st + en) / 2;
    if(x > lim[mid]) st = mid + 1;
    else en = mid;
  }
```

  - `x > lim[mid]`인 경우 lim을 높이기 위해 st를 mid + 1로 설정.
  - 그외에는 en을 점차 줄어드는 mid인 `mid = (st + en) / 2;`로 설정해 lower_bound를 구현함.


#### [boj.kr/9252](../../../Problem%20Solving/boj/Dynamic%20programming/9252-01-20-2023.cpp)
* LCS 풀이에서 복원 방법 고민 중.
  - 길이 갱신으로 접근해도 괜찮음. prv 배열을 만들고, 거기에 key 문자열의 인덱스를 저장하자.