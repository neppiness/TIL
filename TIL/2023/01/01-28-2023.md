# **TIL on January 28th, 2023**
### 비트마스킹 공부
* `x`번째 비트를 조작하는 방법에 대해 생각하자.
  - 한 번도 왼쪽으로 쉬프트 하지 않은 경우 1을 뜻하게 되며, 이는 1번째 원소이다.
  - `x`번째 비트를 조작하기 위해 켜진 1비트를 왼쪽으로 `x - 1`번 쉬프트해야 한다. 이를 `b`라고 두고 다른 연산들에 대해 서술하겠다.
  - `int b = (1 << (x - 1));`

* 정수형 변수 `cur`이 현재 상태를 나타내는 변수라고 생각하고, 변수 `b`를 활용해 아래 연산들을 구현하자.
  - `add x`: `cur |= b;`를 통해 `cur`에 `x`번째 원소가 있든 없든 있는 상태로 기록할 수 있음.
  - `remove x`: `cur &= ~b`. `~b`는 `x`번째 비트만 꺼져있는 상태기 때문에, AND 연산 수행 시, 해당 비트만 끌 수 있다.
  - `check x`: `(bool)(cur & b);`를 통해 확인할 수 있다. `cur & b`의 연산 결과는 `0` 또는 `b`이므로 주의가 필요하다.
  - `toggle x`: `x ^= b;`. 이는 XOR 연산이며, 두 곳의 상태가 다를 경우에는 1을, 같을 경우에는 0을 반환한다.
    * 100과 101의 XOR 시, 001이 나오는 것을 확인할 수 있다. 즉, x번째 비트 이외에는 `cur`의 상태를 정확하게 유지한다.
  - `all`: int 값을 20비트 부호 없는 정수 최댓값인 2^20-1로 대체: 1'048'575이며, `const int MX = (1 << 20) - 1;`로 계산 가능. `cur = MX;`를 통해 모든 비트를 켤 수 있다.
  - `empty`: int 값을 모든 비트가 꺼진 상태인 0으로 대체; `cur = 0;`


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1D 다익스트라 알고리즘
#### [boj.kr/1162](../../../Problem%20Solving/boj/Dijkstra%20algorithm/1162-01-28-2023.cpp): solved on 3rd try (memory: 10360 kB, time: 104 ms, Code length: 1170 B)
* 최단 거리 테이블을 20행짜리로 만들어서 DP식으로 활용
* 간선 정보에 포장 횟수도 함께 기록함.

* PR용 주석
```cpp
/*
도시 수가 10,000이고, 비용이 백만 이하기 때문에 int형 변수 범위를 벗어날 수 있으므로
최단 거리는 long long 변수로 선언합니다.

최단 거리 테이블을 포장 횟수에 따라 구분해 기록합니다.
이를 위해 간선 정보에는 포장 횟수 증가량(dk)을,
힙에는 현재까지 포장한 횟수(ck)를 기록합니다.

간선의 경우 포장을 수행하면 비용이 0이 되기 때문에
비용은 0, 포장 횟수 증가량(dk)은 1인 간선이라 기록합니다(27-28번째 줄).

이후 다익스트라 알고리즘을 활용해 최단 거리 테이블을 채웁니다.
힙에는 현재까지 포장한 횟수(ck)가 기록되기 때문에, 포장횟수 제한 값(k)을 초과하는 경우
해당 간선 정보를 무시하도록 구현합니다(46번째 줄).
*/
```

* 최단 거리가 long long 범위까지 증가될 수 있었음. 이런 실수 안 하도록 주의할 것.
* memset은 이상하게 정수형 변수에 할 수 없었음. 컴파일 에러남.


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1C 플로이드 알고리즘
#### [boj.kr/13314](../../../Problem%20Solving/boj/Floyd%20algorithm/13314-01-28-2023.cpp): solved on 3rd try (memory: 2060 kB, time: 0 ms, Code length: 423 B)
* [지구이의 코드: 답 확인을 위해 일부 수정](../../../Problem%20Solving/boj/Floyd%20algorithm/typo.cpp)
  - D는 첫번째 코드를 통해 얻은 최단거리 행렬: k가 1부터 N 미만인 값에 대해서 돌기 때문에 잘못된 것.
  - E는 두번째 코드를 통해 얻은 최단거리 행렬: k가 1부터 N 이하인 값에 대해서 계산 수행. 이것이 정답.

```cpp
for(int k = 1; k < N; k++)
  for(int i = 1; i <= N; i++)
    for(int j = 1; j <= N; j++)
      D[i][j] = min(D[i][k] + D[k][j], D[i][j]);

for(int k = 1; k <= N; k++)
  for(int i = 1; i <= N; i++)
    for(int j = 1; j <= N; j++)
      E[i][j] = min(E[i][k] + E[k][j], E[i][j]);
```

* 지구이의 코드는 경유하는 정점 번호가 N일 때를 고려하지 않는다. 즉, i -> N, N -> j 경로가 최단 경로로 고려되지 않는다. 따라서, 인접행렬 D의 N번째 행과 열에 다른 비용들보다 작은 값을 넣으면 된다.
* 특별히 9700개 이상의 비용이 달라야 하고, 그중에서 대각 성분은 모두 0이 되어야 한다. 또한, k행과 k열 비용들은 k를 경유하든 하지 않든 영향이 없기 때문에 9700개 이상의 데이터가 잘못되기 위해선 N은 100이어야 한다.


```cpp
#include<stdio.h>
#include<algorithm>

#include<stdlib.h>
#define WRONG { printf("WA"); exit(1); }
#define CORRECT {printf("AC"); exit(0); }
using namespace std;

const int MX = 105;

int D[MX][MX], E[MX][MX];

int main()
{
	int N;
	scanf("%d", &N);
	if( N < 1 || N > 100 ) WRONG;
	for(int i = 1; i <= N; i++){
		for(int j = 1; j <= N; j++){
			scanf("%d", D[i] + j);
			if( D[i][j] < 0 ) WRONG;
			if( i == j && D[i][j] != 0 || D[i][j] > 10000) WRONG;
			E[i][j] = D[i][j];
		}
	}
	for(int k = 1; k < N; k++){
		for(int i = 1; i <= N; i++){
			for(int j = 1; j <= N; j++){
				D[i][j] = min(D[i][k] + D[k][j], D[i][j]);
			}
		}
	}
	for(int k = 1; k <= N; k++){
		for(int i = 1; i <= N; i++){
			for(int j = 1; j <= N; j++){
				E[i][j] = min(E[i][k] + E[k][j], E[i][j]);
			}
		}
	}
	int cnt = 0;
	for(int i = 1; i <= N; i++){
		for(int j = 1; j <= N; j++){
			if( D[i][j] != E[i][j] ) cnt++;
		}
	}
	if( cnt >= 9700 ) CORRECT
	else WRONG;
}

* PR용 해설

```cpp
/*
지구이의 틀린 코드로 얻은 인접행렬을 D,
지구이의 올바른 코드로 얻은 인접행렬을 E라고 하자.

D와 E의 성분이 9700개 이상 다른 데이터를 출력해야 한다.
여기서 출력할 데이터는 dist 배열에 저장한다.

지구이의 첫번째 코드는 N번 정점을 경유하는 경로를 고려하지 않는다.
즉, i -> N, N -> j 경로가 최단 경로로 고려되지 않는다.
따라서, dist[i][j] > dist[i][N] + dist[N][j]인 경우에 D와 E의 성분이 달라진다.

위 코드에서는 dist[i][j]를 10000으로 두고
dist[i][N] = dist[N][j] = 4999으로 설정해 위 조건을 만족시켰다.

D와 E의 대각 성분은 모두 0으로 동일하다.
또한, N행 및 N열 성분들은 N번 정점을 경유하든 하지 않든 상관없다.
따라서 9700개 이상의 데이터가 잘못되기 위해선 N은 100이어야 한다.
실제로 위 데이터를 통해 서로 다른 D와 E의 성분을 세면 총 9702개다.
*/
```


### BOJ step by step: 동적 계획법 3
#### [boj.kr/1311](../../../Problem%20Solving/boj/Dynamic%20programming/1311-01-28-2023.cpp)
* 상태를 비트마스킹 기법으로 기록하면 될 것.
* 이제 그 상태를 어떻게 DP에 활용할 것인지 생각해보자.

* 상태를 어떤 식으로 기록할 것인가?
  - j번 일이 선택되었다면 1, 아니라면 0으로 상태를 기록하려 함.
  - 사람을 뽑는 순서는 1번부터 N번 사람까지 순차적으로 올라갈 것.

* `int topick = N;`으로 설정하면 뽑아야 하는 사람 수와 그 사람의 번호를 일치시켜 활용할 수 있다.
  - 사람을 뽑을수록 topick도 1씩 줄어들고, 이에 따라 뽑는 사람의 번호도 1씩 줄어든다.
  - 최종적으로 topick이 0이 되었을 때 함수 호출이 끝난다.
  - 그치만 인덱싱할 때는 1 감소된 값으로 인덱싱 해야해서 그리 좋은 건 아닐지도. 선택의 문제인 듯함.

* 함수가 의미하는 건 무엇인가?
  - `int solve(int cur, int i) { ... }`: `cur`의 비트 상태가 사람을 선택한 상태를 뜻하며, i번째 인원이 일을 고를 차례임을 의미. 현재까지 고른 비용의 최솟값을 반환한다.
  - 최종적으로 N명의 사람이 일을 선택해 모든 일이 선택된 상태(`st = MX;`)이며, 이때 비용의 최솟값을 구하는 함수.

* 호출을 자연스럽게 할 방법, 그리고 중복 연산을 막을 방법을 구상해보자.


#### [boj.kr/1854](../../../Problem%20Solving/boj/Dijkstra%20algorithm/1854-01-28-2023.cpp)
* K번째 최단경로 찾기. 최단 거리 테이블을 힙 배열로 선언. 최대 힙으로, 크기가 100을 넘지 않도록 제어.
  - 힙은 안에 동일한 값이 있는지 없는지 알 방법이 없음.
  - 대안으로 최단 거리 테이블을 set으로 활용. 이를 통해 자연스럽게 중복 제거.
  - set이 비어있으면 경로가 존재하지 않는 것.
* 그치만, 한 노드까지 가는 거리가 확정되질 않는데 다음 거리를 어떻게 계산할까?