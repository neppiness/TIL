# **TIL on March 11th, 2023**
### solved.ac Class 6 Problems
#### [BOJ #1948](../../../Problem%20Solving/boj/solvedac/1948-03-12-2023.cpp)
* 출발 도시에서 리프로 가고, 리프에서 도착도시로 가는 경로를 찾는데, 그 중에서 가장 많은 깊이를 오가는 경로를 찾으면 되는 문제.

#### [BOJ #19585](../../../Problem%20Solving/boj/solvedac/19585-03-10-2023.cpp)
* 트라이 문제인 듯. 색상에 대해 chk를 1로, 닉네임에 대해 chk를 2로 설정한 뒤, 1과 2가 순차적으로 나오는지 확인하면 될 듯함.
  - 색상에 대한 확인 후, 색상을 확인하면 해당 인덱스를 반환.
  - 반환받은 인덱스부터 확인하며 닉네임 2를 찾아봄. 
  - 다만, 닉네임이랑 컬러가 비슷할 수 있음. 그러니 주어진 문자열을 트라이 끝까지 파고들면서 확인해야 함.
<br>

### S3 to G3 Problems
#### [boj.kr/11060](../../../Problem%20Solving/boj/random%20defense/11060-03-12-2023.cpp): solved on 1st try (memory: 2024 kB, time: 0 ms, Code length: 501 B)
* BFS로 접근해도 좋을 것 같음. 먼저 도달할 수 있으면 그보다 빠르게 갈 수 없다는 것이니 dist에 값이 들어간 경우 무시하는 방식이라 생각할 수 있을 듯.
* 자잘한 구현 실수를 너무 많이함. 큐에 값을 넣고 뽑질 않는다든지, 확인해야 할 i값을 q.front()에서 가져오지 않는다든지.

#### [boj.kr/2343](../../../Problem%20Solving/boj/random%20defense/2343-03-12-2023.cpp): solved on 1st try (memory: 2412 kB, time: 8 ms, Code length: 565 B)
* 파라메트릭 서치 문제라고 생각됨. 제한 값을 던져놓고 배열을 하나씩 돌면서 확인.
  - 최대 16번의 확인을 해야하며, 그때마다 10만 번씩 연산한다고 해도 연산량 최댓값이 2천만임.
  - 다음 강의를 넣을지 말지 판단을 하는데, 넣으면 안 되는 경우 sum을 0으로 만들고 cnt를 늘림
  - cnt가 블루레이 개수 제한을 초과하면 이는 실패한 것.
  - 블루레이 최소 크기를 줄일수록 제한을 못 맞추게 됨. 이를 매개변수로 활용할 것.