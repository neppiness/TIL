# **TIL on April 16th, 2023**
### solved.ac Class 6 Problems
#### [BOJ #2243](../../../Problem%20Solving/boj/solvedac/2243-04-16-2023.cpp)
* 구간 트리로 접근하면 무난할 듯.
  - 사탕의 총 개수가 20억을 넘지 않는다는 조건 역시 int 형 변수로 처리할 수 있다는 걸 말해주고 싶었던 듯.
  - 구간 트리로 k번째 사탕을 찾는 것. 1부터 X까지 몇 개의 사탕이 있는지 이분 탐색으로 찾으면서 lg(1,000,000)으로 찾을 수 있음. lg(1,000,000) 연산을 lg(1,000,000)번 하게 되는 것으로 판단. 20 * 20 = 400번 연산하는 수준일 것으로 판단.

* 구현 좀 다듬어야 할 듯.


#### Random Defense
#### [BOJ #15990](../../../Problem%20Solving/boj/random%20defense/15990-04-16-2023.cpp): solved on 2nd try (memory: 7516 kB, time: 8 ms, Code length: 680 B)
* DP 문제. 마지막에 어떤 숫자를 사용했는지도 기록해야 함.
  - 0에 대한 처리는 어떻게 할까. 자연스럽게 풀이 상, sum이 1일 경우에 마지막에 더한 수가 2 또는 3일 수가 없음.

* solve 함수를 어떻게 정의할지 생각하자. 뭘 구하는 함수로 정의할까.
  - cache에 더해서 만든 현재 값 sum과 마지막으로 더했던 숫자 no를 기록함.
  - 이렇게 두고, 마지막에는 sum이 0이 되는데, 이 경우 1을 반환해서 하나의 경우의 수가 있다고 표현.
  - 재귀적으로 접근할 예정.

* solve 함수를 아래와 같이 설정함.
```cpp
int solve(int x) {
  return (((calc(x, 1) + calc(x, 2)) % MOD) + calc(x, 3)) % MOD;
}
```

  - calc끼리 더하는 과정에 MOD를 안 써서 1번째 제출 WA. 인트 오버플로우로 인함.


#### [BOJ #16926](../../../Problem%20Solving/boj/random%20defense/16926-04-16-2023.cpp)
* 배열 돌리기 하위버전. 간단히 풀어보자.