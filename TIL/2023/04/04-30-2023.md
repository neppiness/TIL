# **TIL on April 28th, 2023**

### Random Defense Using Java
#### [BOJ #1063](../../../Problem%20Solving/boj/random%20defense/1063-04-30-2023.java): solved on 1st try (memory: 14256 kB, time: 128 ms, Code length: 2348 B)
* 시물레이션 문제. 디버깅 필요.
* 아래 두 가지를 수정하고 AC 받음
  1. dx, dy 숫자 설정 실수.
  2. 출력 시 설정해 둔 x[1], y[1], x[2], y[2]를 쓴 게 아니라 0번 인덱스를 사용했었음.

```java
for (int i = 1; i <= 2; i++) {
    bw.write((char)(y[i] + 'A'));
    bw.write((char)(x[i] + '1'));
    bw.write('\n');
}
bw.flush();
```


#### [BOJ #1063](../../../Problem%20Solving/boj/random%20defense/1092-04-30-2023.java): solved on 3rd try (memory: 17404 kB, time: 432 ms, Code length: 1950 B)
* 연결 리스트를 활용한 그리디인 듯함.
  - 용량이 큰 트레인은 매분마다 들 수 있는 박스 중에 가장 무거운 박스를 잡으면 된다.
* 용량이 큰 크레인이 무거운 박스를 드는 것이 당연하다고 하기 위해 증명해야 할 것
  - 용량 큰 크레인이 가벼운 박스를 들어서 더 좋은 경우가 있는가?
  - 그렇지 않다. 어차피 용량이 작은 크레인은 작은 것밖에 들지 못하기 때문에, 다 들 수 있는 크레인이 무거운 박스를 먼저 처리한다고 해서 문제가 생기진 않을 것이다.
* 1번째 제출 WA. 예제는 다 맞게 나오는 상황
  - 아래 입출력에 대해서도 문제 없음.
```
입력:
3
6 8 9
5
2 5 2 4 10

출력: -1
```

* 2번째 제출 TLE. 로직을 명확히 했으나, 시간복잡도가 생각과 다른 듯함.
  - 연결리스트로 선언한 box에서 boxidx를 반복해서 확인해야 하니 문제가 생기는 듯함. 이 경우 매번 boxidx번 연산해야함. `box.get(boxidx)`
  - 이터레이터를 두고 이동하는 방식으로 구현하자.
  - 이터레이터 수정하고 시간 내로 풂. 이터레이터는 앞에 커서를 대고 있는 것 같아서, next()를 통해 다음 원소를 불러옴. remove()를 사용하면 previous()나 next() 메소드를 통해 호출했던 마지막 값을 지움. next() 메소드를 계속해서 사용하는 것으로 모든 원소에 대한 iteration이 가능하며, hasNext() 메소드를 통해 다음에 불러올 원소가 있는지 확인한다.


#### [BOJ #11441](../../../Problem%20Solving/boj/random%20defense/11441-04-30-2023.java): solved on 1st try (memory: 61092 kB, time: 700 ms, Code length: 1039 B)
* 단순 구간합 문제
  - 빠른 입출력 시, BufferedWriter를 쓰는 것보다 StringBuilder에 문자 이어 붙이면서 기록하고 System.out.println()으로 출력하는 게 훨씬 빠름. 중간에 String.valueOf를 통해서 계속 값을 문자열로 바꿔줘야 하기 때문에 발생하는 문제로 생각됨.


#### [BOJ #15552](../../../Problem%20Solving/boj/random%20defense/15552-04-30-2023.java): solved on 1st try (memory: 221636 kB, time: 832 ms, Code length: 589 B)
* 간단한 빠른 입출력 문제. StringBuilder로 풀이해보자.
  - 실행 시간이 864 ms에서 832 ms로 감소함.
  - 코드는 훨씬 간결해짐.


#### [BOJ #17779](../../../Problem%20Solving/boj/random%20defense/17779-04-30-2023.java): solved on 1st try (memory: 140852 kB, time: 620 ms, Code length: 3735 B)
* 엄청 고민할 필요는 없고 인자 변경하면서 구간 나눈 뒤 인구 차이 뽑아내면 되는 시뮬레이션 문제.
* 기준점은 최대 400개 중 한 곳이 될 수 있음. 이렇게 모든 기준점에 대해서 선거구를 설정한 후에 선거구의 연결성과 선거구 당 한 구역 이상을 포함하고 있는지를 확인해야 한다.
* d1, d2는 1보다 크거나 같아야 한다

* 왜 경계의 길이라고 표현할까?
  - 실제로 5번 선거구의 경계 길이가 되기 때문임. 노드가 4개 있으면 3구간이 되고, 이는 d = 3이라는 것을 의미함. d1은 1번과 4번 선거구와 5번 선거구의 경계선 길이고, d2는 2번, 3번 선거구와 5번 선거구의 경계선 길이가 됨.

* x, y는 5번 선거구의 최상단 기준점을 의미함.
  - 5번 선거구의 최하단 기준점은 `x + d1 + d2`, `y - d1 + d2`이다. 이 값은 
  - 이것 역시 400개 포인트에 대해서 확인하면 됨.
  - 5번 경계선을 세팅하자.

* 면밀한 판단을 위해서 d1과 d2의 범위를 결정하자.
  - 경계선의 x좌표 중 가장 큰 값은 x + d1 + d2, 경계선의 y좌표 중 가장 큰 값은 y + d2이다. 이 두 값은 N보다 작거나 같아야 한다.
  - 경계선의 x좌표 중 가장 작은 값은 x, 경계선의 y좌표 중 가장 작은 값은 y - d1이다. 이 두 값은 1보다 크거나 같아야 한다.
  - N >= y + d2, y - d1 >= 1: d1이 1이어도 y는 2보다 크거나 같아야 한다. 즉, y는 아무리 작아도 2보다는 크거나 같다. y는 d2가 최소 1이기 때문에 아무리 커도 N - 1을 넘을 수 없다.
  - N >= x + d1 + d2, x >= 1: d1과 d2가 최소여도 x는 N - 2보다 작거나 같아야 한다. x가 최소일 때는 1이다. 이 경우, N - 1 >= d1 + d2이다. d1은 1보다 크거나 같다. 따라서 N - 2 >= d2이다. 마찬가지로 N - 2 >= d1이다. 즉, d1과 d2 모두 N보다 작거나 같아야 한다.
  - 따라서 아래 풀이로 접근이 가능하다.

* x, y 400개에 대해서 d1, d2 400개를 설정한 뒤, 조건에서 벗어나는 경우를 다 제하는 방식으로 풀이하자.
  - 이러한 경계를 선택했을 때, 1번 선거구는 (1, 1), 2번 선거구는 (1, N), 3번 선거구는 (N, 1), 4번 선거구는 (N, N)을 반드시 포함하기 떄문에, 해당 지점에서부터 BFS를 활용해 영역을 결정할 수 있다.

* cpp로 정리해서 바킹독에 업로드하자.


#### [BOJ #20056](../../../Problem%20Solving/boj/random%20defense/20056-04-30-2023.java)
* 좌표는 0부터 n - 1까지로 설정해두고, MOD 값을 구하듯이 좌표를 구함.
```java
int nx = cx + s * dx[dir];
nx = ((nx % n) + n) % n;
```