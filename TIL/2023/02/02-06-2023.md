# **TIL on February 6th, 2023**
### S3 to G3 Pick and Solve
#### [boj.kr/1309](../../../Problem%20Solving/boj/random%20defense/1309-02-06-2023.cpp): solved on 1st try (memory: 9320 kB, time: 8 ms, Code length: 600 B)
* 상태를 다음과 같이 표현하자. n번째 행의 상태를 0, 1, 2로 표현한다.
  - 0: 배치 안 함, 1: 왼쪽에 배치, 2: 오른쪽에 배치

* 이전 행과 현재 행은 다음과 같은 관계를 갖는다.
  1. 현재 행에 배치를 안 하는 경우, 이전 모든 배치 상태를 경우의 수로 셀 수 있다.
  2. 현재 행의 왼쪽에 배치하는 경우, 이전 행에 배치를 안 한 경우와 오른쪽에 배치한 경우를 셀 수 있다.
  3. 현재 행의 오른쪽에 배치하는 경우, 이전 행에 배치를 안 한 경우와 왼쪽에 배치한 경우를 셀 수 있다.


#### [boj.kr/3055](../../../Problem%20Solving/boj/random%20defense/3055-02-06-2023.cpp): solved on 1st try (memory: 2172 kB, time: 0 ms, Code length: 1489 B)
* BFS. 조건을 어떻게 둘지 고민하자.
* 다음 시간에 물이 찰 예정인 곳을 갈 수 없으니, 물을 먼저 퍼뜨리자. 그러면 퍼질 곳을 예상하는 것과 같이 동작할 것으로 생각됨.

* code를 잘못 넣었음: `q.push({nx, ny, 1});`을 모든 경우에 대해 넣었음.
  - 좀 더 신경 써서 코드를 작성할 것.

#### [boj.kr/1890](../../../Problem%20Solving/boj/random%20defense/1890-02-06-2023.cpp): solved on 1st try (memory: 2144 kB, time: 0 ms, Code length: 809 B)
* solve 함수를 정의하자. 현위치에서 시작해서 끝에 도달할 수 있는 경우의 수라고 하자.
* 가장 오른쪽 아래 칸이 아니더라도 0이 나올 수 있음에 유념할 것.
* 함수 `ll solve(int i, int j) {}`는 i, j에서 n - 1, n - 1에 도달 가능한 경로의 수.


### BOJ Step by Step: 트리에서의 동적 계획법
#### [boj.kr/2213](../../../Problem%20Solving/boj/Tree/2213-02-06-2023.cpp)
* 



### BOJ Step by Step: 문자열 알고리즘 1
#### [boj.kr/1305](../../../Problem%20Solving/boj/KMP/1305-02-06-2023.cpp)
