# **TIL on May 28th, 2023**

### Random Defense Using C++
#### [BOJ #16918](/Problem%20Solving/boj/random%20defense/16918-05-28-2023.cpp): solved on 1st try (memory: 2580 kB, time: 52 ms, Code length: 1219 B)
* 모든 보드의 초 값을 더하면서 3초가 될 때 터뜨리는 방식으로 구현하면 될 듯함.


#### [BOJ #9659](/Problem%20Solving/boj/random%20defense/9659-05-28-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 134 B)
* 홀수면 상근이가 이기고 짝수면 창영이가 이긴다.


#### [BOJ #12891](/Problem%20Solving/boj/random%20defense/12891-05-28-2023.cpp): solved on 1st try (memory: 3680 kB, time: 16 ms, Code length: 639 B)
* 투 포인터로 간단히 풀 수 있을 듯.


#### [BOJ #16929](/Problem%20Solving/boj/random%20defense/16929-05-28-2023.cpp)
* 한 점에서부터 같은 색 점을 찾아 이동하며 거리를 확인. 가장 마지막에 시작점으로 돌아오는지 확인하면 됨.
* 깊이 우선 탐색으로 접근해야 할 듯함.
* 깊이 우선 탐색으로 무작정 설정하면 방향이 엉망이 될 수 있음. 자기 멋대로 방향 유지 안 하고 경로를 짤 수도 있다 생각함.
  - 그러나, 그런 식으로 덩어리지면 무조건 답이 Yes가 나와야 하기 때문에 무방할 듯함.
  - 그래도 이렇게 푸는 건 문제가 있는 듯함. 변으로 닫히는지 확인해볼까?

#### [BOJ #2688](/Problem%20Solving/boj/random%20defense/2688-05-28-2023.cpp): solved on 2nd try (memory: 2024 kB, time: 0 ms, Code length: 720 B)
* 계단 수 문제 풀이나 다를 게 없음. 숫자 앞에 0이 붙어도 상관 없으니 더 쉬움.
* 범위가 int를 초과하므로 long long으로 선언해야함. n = 64에 대한 확인 후 제출했어야 했음. 1번째 제출: WA.

#### [BOJ #2109](/Problem%20Solving/boj/random%20defense/2109-05-28-2023.cpp): solved on 2nd try (memory: 2676 kB, time: 4 ms, Code length: 779 B)
* 과제 문제와 유사함. n일 째에 할 수 있는 과제를 먼저 수행하는 식으로 접근.
  - 우선순위 큐로 간단하게 구현해봤음.
  - 1번째 제출 WA. 풀이 수정 필요. 로직이 확립이 안 된 상태에서 예제 답만 보고 제출했던 것. 수정할 게 많음.
* N이 1만이라, O(N^2)이어도 1억임. 무난히 풀 정도인 듯

* ~~n개의 강의 요청이 들어왔다면, 최대 n일부터 확인하면 됨. n일이면 모든 강연을 할 수 있음.~~
  - 최대 일수인 10000일부터 시작하는 게 좋긴 한 듯.
  - 10000일부터 내려오면서 그날이 기한인 과제들을 우선순위 큐에 넣기 시작. 어차피 그 전엔 수행해도 점수를 받을 수 없는 문제들이기 때문.

* cmp class를 정의하고, 우선순위 큐에 넣어 활용함.

* 바킹독 알고리즘 강의 발췌

> 이 비교 함수가 좀 오랜만에 등장을 했으니 좀 가물가물할 수도 있을 것 같습니다. 그래서 설명을 다시 드리면 비교 함수 이름을 cmp라고 할 때 cmp(앞에 위치해야 하는 원소, 뒤에 위치해야 하는 원소) = true가 되어야 합니다. 그리고 STL priority_queue는 최대 힙, 즉 가장 뒤의 원소를 높은 우선순위로 두는 STL이기 때문에 cmp 함수를 잘 설정해야 합니다.

  - 즉, 가장 뒤에 있는 원소가 우선순위가 높은 원소이기 때문에, 작은 값을 앞으로 가져오는 비교함수를 설정해야 한다.

```cpp
class cmp {
  public:
    bool operator () (pair<int, int> &lh, pair<int, int> &rh) {
      if (lh.first == rh.first)
        return lh.second > rh.second;
      return lh.first < rh.first;
    }
};
```
  - 이 `pair<int, int>`에서 first는 금액이고 second는 기한이다. 금액이 가장 큰 값이 우선순위가 가장 커야하기 때문에 `lh.first < rh.first`가 참이어야 first가 큰 값이 뒤에 위치하고, 가장 금액이 큰 원소의 우선순위가 가장 커진다. 필요하다면 좀 더 자세히 공부하자.