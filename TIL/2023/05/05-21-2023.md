# **TIL on May 21st, 2023**

### Random Defense Using Java
#### [BOJ #20058](../../../Problem%20Solving/boj/random%20defense/20058-05-21-2023.java)
* 구현 문제.
* 회전에 대한 정리
  - Essence of linear algebra에서 배웠듯이, 기저 벡터를 바꾸는 방법은 바꾸고자 하는 목적지를 선형 변환 값에 넣으면 된다.
  - 시계방향으로 90도 회전변환한다고 생각하자. x의 기저 벡터 i의 방향은 아래로 향하고, y의 기저 벡터 j의 방향은 오른쪽을 향한다고 두자.
  - 전체 좌표를 회전시키는 것만 생각하자: 시계방향으로 90도 회전변환하는 경우, i를 -j로 옮겨야 하며, j를 i로 옮겨야 한다. 따라서, `{i', j'}^T = [[0, 1], [-1, 0]]{i, j}^T`로 변환이 가능하다. 이는 곧, i' =  j가 되고, j' = -i가 된다.
  - 즉, 우리가 원 배열의 x, y를 옮긴다고 하면 해당 변환을 통해서 y, -x 인덱스로 이동하게 된다는 것이다. 단, -x는 범위를 벗어나므로, 최댓값인 (n-1)을 더하자.
  - 원 배열을 A, 이를 돌린 값을 받을 배열을 B라고 하면, `B[j][(n-1) - i] = A[i][j]`가 되는 것이다.
* 회전을 시킨 다음에, 원 좌표계에 맞춰서 인덱스가 벗어나지 않도록 평행이동하는 거라고 생각하면 될 듯함.
* 구현은 됐음. 예제 6번이 통과가 안 됨. 회전하는 로직 자체는 잘 짜여진 것으로 판단됨. 다른 조건 확인 필요.


#### [BOJ #1446](../../../Problem%20Solving/boj/random%20defense/1446-05-21-2023.java)
* 다익스트라로 풀 수 있을 듯함: Out of Index 발생. 5번 틀림
  - 시작점 u가 아예 고속도로 길이 바깥에서 출발하는 경우를 생각하지 않았었음. 이를 간선 입력 받을 때 고려하여 AC.
* 이 문제는 DP로 푸는 게 효율적일 것.


#### [BOJ #18428](../../../Problem%20Solving/boj/random%20defense/18428-05-19-2023.java): solved on 4th try (memory: 15000 kB, time: 140 ms, Code length: 2236 B)
* ArrayList로 구현하면 문제 없이 풀림. 조건과는 다르게, 선생님의 수가 5이하가 아닌 게 아닐까 하는 생각이 듦.