# **TIL on February 1st, 2023**
### S3 to G3 Random Defense
#### [boj.kr/1208](../../../Problem%20Solving/boj/random%20defense/2225-02-01-2023.cpp): solved on 1st try (memory: 2180 kB, time: 0 ms, Code length: 432 B)
* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램 작성

* 예제로 0부터 5까지의 정수 중 2개를 더해서 그 합이 5가 되는 경우의 수를 탐색한다고 하자.

|idx|0|1|2|3|4|5|
|---|-|-|-|-|-|-|
|1EA|1|1|1|1|1|1|
|2EA|1|2|3|4|5|6|

* 마찬가지로, 0부터 20까지의 정수 중 2개를 더해서 그 합이 20이 되는 경우의 수는

|idx|0|1|2|3|4|5|...|19|20|
|---|-|-|-|-|-|-|---|--|--|
|1EA|1|1|1|1|1|1|...|1 |1 |
|2EA|1|2|3|4|5|6|...|20|21|

  - 위 같은 계산 결과에 따라 21이 되는 것으로 파악됨.

* 반복문 돌려서 부분합 갱신하고, 10억을 넘는 값은 차감하는 식으로 구현함.


#### [boj.kr/16234](../../../Problem%20Solving/boj/random%20defense/16234-02-01-2023.cpp): solved on 2nd try (memory: 2060 kB, time: 76 ms, Code length: 1967 B)
* 시뮬레이션 문제로 생각됨.
  - 조건에 맞춰서 교환이 일어나도록 설정하고, 인접한 나라 몇 나라가 연합을 이루게 되는지 계산.
  - 루프를 한 번 더 돌기 전에 인접한 나라들의 인구 차이를 확인해야 함.

* 유니온 파인드를 활용하면 편할 것 같음.

* 작동 방식을 생각하자.
  - 이중 포문을 활용해서 모든 노드를 순회함.
  - 노드 넘버링은 좌에서 우로 움직이며 위에서 아래로 훑으면서 카운트함.
  - 플래그 변수(`bool needTrans;`)를 두고, 모든 노드를 순회하면서 인구 이동이 필요한 경우 `ans++;` 후 이를 진행하면 됨.
  - 인구이동은 부모 노드의 cnt 배열에 총 인구수를 기록
  - 부모 노드의 랭크가 곧 노드의 수가 됨.
  - 인구 재분배도 모든 노드를 순회하며 진행되어야 함. 그래도 부모를 바로 파악하고, 랭크와 인구수를 통해 바로 분배 가능.

* 실수 목록
  - `dir < 0`으로 for문 돌린 실수
  - setup에서 조건 실수
  - 예제를 착각해서 엄한 코드를 수정한 실수

* 예제는 다 통과했으나, 결국 1번째 시도 실패. 디버깅 필요.
  - merge 시에 cnt 배열에다 직접 계산한 것이 잘못임.
  - tmp에 cnt 배열 값들을 받아놓고 merge할 때 기록한 뒤에 spread 할 때는 tmp 값을 토대로 계산하여 cnt에 할당함.


### solved.ac Class 5 Essential Problems
#### [boj.kr/1208](../../../Problem%20Solving/boj/solvedac/1208-02-01-2023.cpp)
* Meet in the middle로 접근하면 풀릴 듯함.
  - set로 구현한 건 시간 초과. 2^20 해봐야 100만이니까, 배열로도 풀 수 있을 것 같음.
  - unique 기능 잘 써보기
* 그냥 vector 2개에 대해서 lower_bound와 upper_bound를 잘 활용하면 풀 수 있을 듯함.
  - 단, 공집합인 경우는 피해야 함: S는 0일 경우 딱 한 가지가 포함될 것이니 -1을 해주자.

* 디버깅 중. 심각한 반례 발생

```cpp
2 0
-5 5
```
```cpp
(5, -1414812757)
(0, 5)
```

* 5번 틀림. 한 번은 출력 초과임. 실수를 줄이자.

* 풀이가 잘못되었나?
  - 문제 조건을 완전히 잘못 이해해서 대참사 발생.
  - '크기가 양수인 부분수열', 즉 주어진 수열의 형태가 깨지지 않는 선에서 찾아야 하는 것임.

* 풀이 구상 중.
  - 투 포인터 활용?: 중간에 음수가 껴서 값이 오히려 작아지는 수열을 얻을 수도 있긴 함.
  - N이 40이면, N^2 풀이도 무난할 것 같은데..?
  - 부분합으로 접근하자.

* 6번째 오답: 부분 수열은 연속이 아니어도 된다. 단순 구간합 문제가 아님.
  - 그렇다면 그냥 원소 고르는 거랑 같지 않나? 원소 골라서 합이 S가 되는 부분수열 개수 구하는 거랑 같지 않나?
  - 풀이를 다시 고민해보자. 설명이 부족하니 부분수열의 정의부터 다시 찾아볼 것.

* 부분수열의 정의
  - 그냥 막 -3, -2, 5로 조합이 가능하다고 하면, -2, -3, 5와 같은 값은 경우의 수로 들어가지 않게 제어하면 되는 것으로 이해됨.

* 결국은 upper_bound 이해 부족으로 인한 것이라 확신함.
  - 현재 값이 들어갈 수 있는 가장 큰 값을 돌려주기 때문에, upper_bound - lower_bound로 구간 길이를 구할 수 있다.
  - 한 번 예제를 만들어서 적용해보자.

* 예제 1: 0, 1, 1, 1, 3에서 1의 lower_bound, upper_bound 값 차이 찾기
```cpp
vector<int> a = {0, 1, 1, 1, 3};
int x = 1;
auto ub = upper_bound(a.begin(), a.end(), x);
auto lb = lower_bound(a.begin(), a.end(), x);
cout << (ub - lb) << "\n";
```

```shell
3
```

* 예제 2: 0, 1, 1, 1에서 1의 lower_bound, upper_bound 값 차이 찾기
```cpp
vector<int> a = {0, 1, 1, 1};
int x = 1;
auto ub = upper_bound(a.begin(), a.end(), x);
auto lb = lower_bound(a.begin(), a.end(), x);
if(ub == a.end()) cout << "upper_bound is a.end()";
```

```shell
upper_bound is a.end()
```

  - upper_bound - lower_bound를 통해서 우리가 찾으려는 값이 몇 개 있나 알 수 있다.
  - 찾지 못하는 경우 upper_bound와 lower_bound가 아예 같은 곳을 가리키기 때문에 둘을 빼는 것으로 구간을 간단히 찾을 수 있다.

* ans는 무조건 long long 범위였어야 했음. 8번째 제출 시에 이를 수정했지만 WA.

input:
```shell
40 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

output:
```shell
1099511627775
```


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x10 다이나믹 프로그래밍
#### [boj.kr/9657](../../../Problem%20Solving/boj/Dynamic%20programming/9657-01-31-2023.cpp)
* 1, 3, 4 중 하나를 '반드시' 골라야 한다는 조건을 활용하자.

|0 |1 |2 |3 |4 |5 |6 |
|--|--|--|--|--|--|--|
|CY|SK|CY|SK|SK|  |  |

* SK는 첫번째 선택에서 반드시 1, 3, 4 중 하나를 골라야 한다.
  - 2는 CY가 고를 수밖에 없다.
* 그런데, 숫자는 누군가 가져갈 수밖에 없나?

* 이기기 위한 수를 두는 것을 어떻게 모사할 수 있을까?

* 최선의 수를 둔다: 먼저 도달할 수 있는 경우의 수가 하나라도 있다?
  - 먼저 도달하는 것과는 전혀 관계 없음.