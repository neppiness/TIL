# **Chapter 2. Domain Design**

## PCPart를 어떤 것으로 작성할지 고민
### interface로 작성하는 경우
* 구현해야 하는 메소드가 있다면 이렇게 해야겠지만, 그렇진 않음.
* 대신, 필요로 하는 값이 있는데, 이 경우 어떻게 해야 하는 건지 봐야할 듯.

### 부모 클래스로 구현하는 경우
* PCPart로써 필요한 값들을 부모 클래스에서 명시할 수가 있다.
  - 대표적으로 id, price
* 나머지는 상속해서 어떤 것과 어떤 관계를 가질지 로직을 작성해봐야 함.

### 수행하고 싶은 것.
* PC라는 객체에 setPart()라는 메소드를 놓고 쓰고 싶다면.
  - setPart(PCPart pcPart)와 같은 식으로 인자를 전달받을 것임.

### 선택한 방법
* 각 부품이 공유하는 게 없음.
  - 따라서, 상속이나 인터페이스를 통한 다형성 활용이 적절하지 않을 것으로 판단함.
* 이에 따라서 각 파트를 클래스로 만들 예정
  - DB에서는 클래스 역시 키의 하나로 들어감. 이를 통해 필요할 때 각 부품에 대한 쿼리를 수행할 것.

### 클래스 작성 시 Lombok 활용
* `@RequiredArgsConstructor`를 통해 필드를 자동으로 생성자로 만듦.
  - 이는 final로 지정된 필드나, 그밖의 `@NotNull`과 같이 반드시 값이 필요하게 되는 태그 등을 반영하여 생성자를 만듦

### 파트 클래스 공통 필드
* id, price, name, brand는 모든 부품에 공통된 것.

```java
final long id;
final long price;
final String name;
final String brand;
```

### 서로 다른 파트로 구성된 PC는 어떻게 만들 것인가?
1. 생성자 오버로딩을 통해서 여러 타입에 대해 생성이 가능하도록 만든다.
2. 하나의 생성자만 활용하지만, 사용되지 않는 파트에 null을 전달한다.
  - 처음에 이와 같이 만들고자 했었음.

### 2번 방안: 생성자는 하나의 로직으로 통일되지만, 사용되지 않는 파트에 null을 전달한다.
* PC
  - CPU
    + CPUCooler
  - GPU
  - RAM
  - HDD/SSD
  - PSU
  - Case
* 필수 조합
  - CPU, RAM, HDD/SSD, PSU, Case
* 옵션
  - GPU, CPUCooler
* 생성자에는 null을 넘길 수 있음.

### 인터페이스 활용하기로 결정
* PCPart라는 인터페이스를 활용함으로써 각 파트를 통합적으로 주고 받는 것이 가능해짐.
  - 이는 repository 로직을 작성할 때 도움이 될 것으로 기대.
