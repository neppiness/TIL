 **Grokking the Low Level Design Interview Using OOD Principles**

# Designing an Elevator System
## Getting Ready: Elevator System
### 문제 정의
* 엘리베이터는 멈춰있거나 상승 중이거나 하강 중일 수 있음.
* 승객은 일정 수까지 태울 수 있음
* 엘리베이터는 우선순위를 설정하는 알고리즘을 따라 움직임.

### 면접자에게 원하는 것
* 여러 개의 엘리베이터가 있는 경우 
    - 여러 대의 엘리베이터가 건물에 있을 수 있나?
    - 한 대의 엘리베이터만 있는 경우와 여러 대의 엘리베이터가 있는 시스템에서 사용자의 대기 시간과 운용 비용이 어떻게 달라지나?
* 시각화, 최적화

### 설계
* 가장 작은 요소부터 정의
* 작은 요소로부터 큰 요소를 설계
* 이를 전체 시스템 설계까지 반복함.

### 설계 패턴
* 전략 디자인 패턴
* 상태 설계 패턴
* 위임 설계(?) 패턴

<br>

## Requirements for the Elevator System 
### 요구조건 집합
* 층들과 엘리베이터 여러 대가 있음.
* 대기 상태에서만 문을 열고 닫을 수 있음.
* 외부 패널은 각 층마다 있으며, 이는 올라가거나 내려가기 위해 활용
* 위와 같은 조건으로 실제 설계할 엘리베이터 시스템의 기능을 정의.

<br>

## Use Case Diagram for the Elevator System
### 시스템
* 엘리베이터

### 활용하는 사람
* 1차 활용자: 승객
* 2차 활용자: 시스템 - 승객에 의해 동작함.

### 사용 사례
* 승객
    - 엘리베이터 내 패널 조작
    - 층의 패널 조작

### 관계
#### Generalization
* '엘리베이터 패널 버튼을 누르세요'라는 동작은 다양한 관계의 일반화
    - 층 요청, 문 개폐 요청, 비상 호출

#### Associations
* Actor들 간의 관계

#### Include
* 층에서 요청하는 경우는 엘리베이터를 움직이거나 멈추게 하는 사용 사례와 포함 관계에 있다.
* 문 개폐 요청은 문 여닫기와 포함 관계에 있다.

### Use case diagram
* 사용사례를 정의하고 이를 엘리베이터라는 시스템 안에서 표현
    - 그리고 승객과 시스템이 이 사용사례들과 어떻게 연결되는지 다이어그램으로 표현.

<br>

## Class Diagram for the Elevator System
### 엘리베이터 시스템의 구성요소
* 버튼
    - 버튼을 추상 클래스로 정의
    - 다양한 버튼이 있음. 엘리베이터 버튼과 층 버튼이 있음.
    - 상태는 눌려있거나 그렇지 않은 경우로 구분

### 엘리베이터 패널, 홀 패널

### 디스플레이
* 층을 보여줘야 하고, 방향, 그리고 현재 수용하고 있는 인원 정보를 담고 있어야 함.
* 디스플레이는 엘리베이터 디스플레이를 보여줘야 하며, 홀 디스플레이도 보여줘야 함.

### 문
* 문은 엘리베이터의 문을 나타냄.
    - 상태를 가지고 있어야 함.
    - 그리고 현재 문이 열려있는지 반환하는 메소드를 구현해야 함.

### 엘리베이터
* 엘리베이터는 문, 엘리베이터 상태, 디스플레이, 패널, 현재 층 등의 정보를 담고 있어야 함.
* 문을 닫거나 열고, 움직이거나 멈추는 등의 동작을 수행해야 함.

### 층
* 층은 디스플레이와 패널을 가지고 있음.
    - 현재 층이 최상층이거나 최하층이라는 것을 파악할 수 있게 메소드로 제공.

### 건물
* 건물은 층과 엘리베이터로 구성

### 엘리베이터 시스템
* 시스템은 빌딩을 총괄하며, 현재 상태를 나타내거나 최적의 엘리베이터를 지정해주는 역할을 수행.

### 클래스 간 관계
#### Aggregation
* 엘리베이터 시스템은 빌딩과 Aggregation 관계를 가짐

#### Composition
* 빌딩은 엘리베이터 카와 층으로 구성
* 엘리베이터 카는 문, 엘리베이터 패널, 디스플레이로 구성
* 층은 홀패널과 디스플레이로 구성
* 홀패널은 홀 버튼으로 구성
* 엘리베이터 패널은 엘리베이터 버튼으로 구성

### 클래스 다이어그램
* 이를 통해 클래스 다이어그램을 그릴 수 있음.

### 디자인 패턴
* 전략 설계 패턴을 활용하여 들어오는 요청을 처리할 수 있음.
* 상태, 위임 설계 패턴 또한 사용할 수 있음.

### 추가적 요구조건
* 시스템 대기 시간 최소화
* 승객 대기 시간 최소화
* 처리량 최대화
* 운용 비용 최소화

#### FCFS
* 선착순 전략 활용

#### SSTF
* 가장 가까운 엘리베이터 호출
* 처리량을 늘릴 수 있음.
    - 그러나, 먼 곳에 있는 엘리베이터는 호출이 잘 안 될 수 있음.

#### SCAN
* 엘리베이터가 전층을 돌아보게 하는 전략

#### LOOK
* 스캔 알고리즘과 유사
* 첫층부터 끝층까지 쭉 올라가는 식이 아니라 중간에 방향을 바꾸는 등의 동작도 수행.

<br>

## Sequence Diagram for the Elevator System
### 엘리베이터 호출
* 각각의 요소가 액터에 의해 어떻게 활용되는지 도식화.

<br>

## Activity Diagram for the Elevator System
* 동작 과정을 연결함.

<br>

## 코드
* 이후 위에서 설계한대로 동작하는 프로그램을 코딩.

<br>

# Designing a Library Management System
## Getting Ready: Library Management System
### 문제 정의
* 도서관 관리 시스템
* 새 책을 들이고, 대출 중인 도서와 이를 빌려간 회원, 그리고 반납된 책을 기록.

### 면접자에게 기대하는 것
* 효율적 검색
    - 책을 찾는 것은 도서관 관리 시스템의 가장 중요한 것 중 하나.
    - 서로 다른 방식으로 검색을 수행할 수 있음.
    - 책 이름으로 찾는 방법, 저자 또는 발행일을 통해 찾는 방법?
    - 책의 서로 다른 카테고리를 통해 찾는 방법?
* 다양한 활용성
* 책 예약
    - 책 예약의 메커니즘?
    - 이미 예약된 책에 대한 예약?
    - 책을 반납하면 책은 어떤 상태로 바뀌나?
* 대출 기한 연장
    - 어떻게 사용자가 이미 빌린 책을 연장할 수 있나?

### 설계 접근
* 클래식 OOD 방식

### 설계 패턴
* 팩토리 패턴, 위임 패턴, 관찰자 패턴을 적용할 수 있음.

<br>

## Requirements for the Library Management System
### 요구조건 서술
* 책을 구분하기 위한 고유 번호가 필요
* 책은 ISBN, 제목, 저자명, 주제, 발행일을 기록
* 사용자는 사서와 회원들로 구분
* 모든 사용자는 도서관 카드를 가지며, 이들은 각각 고유 번호를 가짐
* 사용자가 한 번에 대출 가능한 책 수를 설정
* 위와 같은 세부 사항을 요구조건으로 설정함.

<br>

## Use Case Diagram for the Library Management System
### 시스템
* 도서관

### 액터
#### 1차 액터
* 사용자, 사서.
* 각각이 그에 맞는 기능을 수행할 수 있음.

#### 2차 액터
* 시스템: 사용자와 사서를 통해 일을 처리

### 사용 사례
* 사서
    - 책의 추가, 삭제, 편집
    - 새 계정 등록
    - 회원 자격 박탈
    - 계정 갱신
    - 로그인/로그아웃
    - 회원에게 책 관련 정보를 알려줌
    - 예약 삭제
    - 책 예약
    - 계정 확인
* 회원
    - 책 검색
    - 회원 탈퇴
    - 로그인/로그아웃
    - 책 예약 및 예약 취소
    - 계정 상세 정보 열람
    - 책 반납
* 시스템
    - 연체 알림
    - 예약 가능 알림
    - 예약 취소 알림
    - 기타 사서 및 회원에 의한 동작들

### 관계
#### 일반화
* 책 검색은 주제를 통한 검색, 제목을 통한 검색, 저자명을 통한 검색, 그리고 발행일을 통한 검색의 일반화임.

#### 연합들(associations)
* 각 액터는 그들의 사용 사례와 연합을 이룸.

#### 포함 관계
* 1차 액터의 Add Book은 시스템의 Add book item 사용사례를 활용하므로 포함관계임.
* 그외에 책을 점검(checkout)하게 되면 예약이 취소되어야 하므로, 책을 점검한다는 예약을 취소하는 사용 사례를 포함함.

#### 종속관계
* 새 회원 등록은 Issue library card 사용 사례를 확장함.
    - 새 회원 등록을 통해 Issue library card가 호출될 수도, 안 될 수도 있다.
* 책이 반납되는 경우, 연체료를 낼 수도 안 낼 수도 있음.
    - 따라서 Return book <-- <<extend>>--- Pay fine

### 사용 사례 다이어그램
* 분석한 내용을 바탕으로 사용 사례 다이어그램을 그림.

<br>

## Class Diagram for the Library Management System
### 도서관 관리 시스템의 구성요소
#### 책과 책 아이템
* 책은 추상클래스. 같은 책이라면 가져야하는 공통 정보를 포함
    - 책 아이템은 개별적인 객체로, 언제 이를 빌렸는지, 얼마인지, 현재 어디에 놓여있는지 등 실제적인 정보를 담음.

#### 책장
* 책장은 번호가 매겨져있고, 어떤 구역의 몇 번째 책장인지 구분해야 함.

#### 사람과 저자
* 사람은 사람으로서 가질 공통 정보를 갖고 있음.
    - 이를 확장해 저자를 생성. 자신이 작성한 책의 정보를 담고 있도록 설계.
    - Person <-- <<extend>> --- Author

#### 사용자, 사서, 그리고 도서관 관리자
* 사용자를 추상 클래스로 둠.
    - 이후 사서, 도서관 관리자는 자신들이 수행할 특정 메소드와 필요한 정보를 기록.

#### 그외
* 도서관 카드, 책 예약, 책 대출, 알림 등도 클래스로 작성
* 검색은 제목으로 검색하거나, 저자로 검색, 주제로 검색, 발행일로 검색 등을 수행하는 인터페이스로 정의
    - 카탈로그는 필요한 정보를 저장하고, 검색 인터페이스에서 정의한 메소드들을 수행

### 클래스 간 관계
* 단방향 연합, 양방향 연합, 상속, 합성체, 혼합체 등...
* 위에서 정의한 클래스 간 관계를 정의

### 클래스 다이어그림
* 위에서 정의한 클래스 간 관계를 도식화.

### 설계 패턴
* 팩토리 패턴과 위임 패턴, 관찰자 패턴을 모두 활용하여 필요한 기능에 적용.
* BookFactory는 책 객체를 생성하는 데 활용
* 사서 클래스는 BookItem 클래스 관련 일을 대신해줌. 이는 위임 패턴
* 책이 활용 가능하게 되었을 때 알림을 주는 부분을 관찰자 패턴으로 구현

### 추가 요구사항
* 연체료를 지불하는 경우, 트랜잭션 객체를 만듦.
    - 이는 도서관 카드와 Composition을 이룸.
    - 연체료 트랜잭션은 도서관 카드에 포함되어야 함.

<br>

## Sequence Diagram for the Library Management System
### Issue a book; 이 경우 책의 대출을 뜻하는 것으로 판단됨.
* 회원이 책을 대출해달라고 요청
* 사서는 회원이 대출 가능한 상태인지 파악.
* 회원의 상태에 따라 다른 시퀀스 다이어그램이 전개됨.

### 책 반납
* 책 반납이 이루어질 때 사서와 회원 간의 어떤 일이 발생하는지 설명.

<br>

## Activity Diagram for the Library Management System
### 책 대출
#### 상태
* 회원이 책을 선택하고 이를 대출하고자 함.
* 최종 상태: 정상 처리되거나 대출 한도에 도달해 더 책을 빌릴 수 없음.

### 대출 연장하는 과정은 어떠한가?
* 퀴즈로 풀이
* 트랜잭션을 만든다는 의미가 잘 와닿지 않음.
    - 거래를 만든다는 의미.
    - 거래 내역을 생성시킨다는 의미로 활용된 듯함.

<br>

## Code of Library Management System
* 위에서 정의한 것들을 적용하여 프로그래밍.

<br>

# Designing the Amazon Locker Service
## Getting Ready: Amazon Locker Service
* 아마존 락커 시스템

### 면접자에게 기대하는 것
#### 라커 사이즈
* 라커 크기를 어떻게 결정할 것인지
* 화물 크기 제한이 있는지

#### 라커 선택
* 한 라커에 여러 명이 접근하지 못하도록 제한해야 함.
    - 이를 어떻게 제한할 것인지
* 고객이 직접 락커를 선택할 것인지, 아니면 시스템이 할당해 줄 것인지.
* 한 고객이 두 락커를 활용할 수 있게 할 것인지.

#### 락커 상태
* 락커 사용시간 제한을 둘 것인지
* 유효한 기간 내로 고객이 락커를 반납하지 않으면 어떻게 되는지.

### 설계
* OOD의 기본을 따라 바텀-업 방식으로 설계

### 설계 패턴
* 전략 패턴: 사물함 활용 정책을 주입하는 방식으로 여러 가지 정책을 적용하기 편리하게 만들 수 있을 것.
* 저장소 패턴

<br>

## Requirements for the Amazon Locker Service
### 요구사항 목록
* 배송을 받을 때 어떤 락커를 사용할 것인지 가장 가까운 락커를 선택하도록
* 서로 다른 크기의 락커를 둠
* 주문한 패키지가 오면 사용자를 인식할 수 있도록 OTP와 같은 인증을 거치도록
* 락커 이용 기한에 맞춰서 사용하도록
* 잘못 위치된 화물에 대한 환불 등을 수행할 수 있도록
* 위와 같은 요구사항들에 부합하도록 설계

<br>

## Use Case Diagram for the Amazon Locker Service
### 시스템
* 아마존 락커

### 액터
* 1차 액터: 고객, 배달부
* 2차 액터: 시스템

### 사용 사례
* 고객
    - 코드 입력
    - 상품 추가 및 삭제
    - 배송 알림
    - 반송 요청 제출
    - 기한 만료 알림
* 배달부
    - 코드 입력
    - 상품 추가 및 삭제
    - 반송 알림
* 시스템
    - 코드 유효성 검사
    - 락커 찾기
    - 문 닫기/열기
    - 반품 알림
    - 코드 생성
    - 적절한 락커 선정
    - 기한 만료 알림
    - 배송 알림

### 관계
#### Associations
* Use case와 액터 간의 관계를 매칭

#### Include
* 코드 입력은 시스템이 유효성을 검증하도록 만듦.
    - Enter code --- <<include>> --> Validate Code
* 코드 유효성 검사 후 락커 찾기 기능이 사용됨.
    - Validate code --- <<include>> --> Find locker
* 락커 찾기 후 해당 락커의 문을 여닫는 기능이 사용됨.
    - Find Locker --- <<include>> --> Door open/close
* include 내용 복습
    - 이 관계는 두 사용 사례의 관계를 나타내는 데 활용함.
    - 포함된 사용 사례는 기존 사용 사례가 실행될 때만 수행됨.
    - 점선 화살표로 표현. 포함된 사용 사례를 향해서 뻗음.

### 사용 사례 다이어그램
* 위에서 규명한 관계를 통해 사용 사례 다이어그램을 그림.

<br>

## Class Diagram for the Amazon Locker Service
### 아마존 락커 서비스 구성요소
#### 아이템
* 주문된 상품을 표현

#### 주문
* 주문에는 아이템이 들어감
    - 이는 컴포지션 관계로 들어갈 것.

#### 알림
* 주문자 아이디, 주문 번호, 락커 아이디, 그리고 인증 번호가 담긴 알림.
    - 이를 보내는 메소드와 함께 활용

#### 패키지와 락커패키지
* 택배가 있으면, 이를 락커에 넣는 경우 락커패키지에 들어가는 식으로 구현한 것으로 판단.
    - 택배는 부모 클래스, 락커패키지는 이를 상속 받는 자녀 클래스 관계.

#### 락커
* 락커는 아이디와 사이즈, 그리고 위치 정보 등이 담겨 있음.
* 여기에는 화물을 넣거나 뺄 수 있는 메소드가 들어감.

#### 락커 위치
* 락커 위치는 락커 관련 정보와 위도/경도 정보가 들어감.

#### 락커 서비스
* 락커 서비스는 서비스 전체의 메인 클래스

#### 열거형
* 열거형 변수는 락커상태와 락커 크기에 대한 값을 활용

### 클래스 간 관계
* 위에서 정의한 클래스들을 통해 상호 관계를 이끌어낼 수 있음.
* 이를 통해 다이어그램을 그림

### 디자인 패턴
* 전략 패턴을 활용
    - OTP 생성, RNG, 락커 할당, 락커 필터링 등에 활용
* 저장소 패턴
    - 락커 저장소, 패키지 저장소를 둠.

<br>

## Sequence Diagram for the Amazon Locker Service
### 반송 패키지
* 액터: 고객, 대상: 락커, 시스템
* 반송에 대한 시나리오를 작성함.

<br>

## Activity Diagram for the Amazon Locker Service
### 물품 수령
* 수령 절차를 도식화하는 것을 예시로 보여줌

## Code for the Amazon Locker Service
* 최종적으로 위에서 규정한 내용대로 코드를 작성.

<br>

# Designing a Vending Machine
## Getting Ready: Vending Machine
* 자판기에 대한 얘기

### 면접자에게 기대하는 것
#### 자판기 상태 정의
* 자판기가 어떤 기능을 수행할 것인가?
* 돈을 넣었을 때 시스템은 어떤 작업을 수행하는가?
* 누가 자판기 버튼을 누르고, 눌렀을 때 어떤 일이 일어나는가?

#### 돈 관련 처리
* 만약, 지불해야 하는 비용보다 더 많은 돈을 넣은 경우?
* 지불해야 하는 비용보다 적은 돈을 넣은 경우?

### 설계 패턴
* 상태 패턴, 싱글톤 패턴
* 패턴을 먼저 언급하는 건 좋은 인상을 준다.

<br>

## Requirements for the Vending Machine
### 요구사항 목록
* 자판기를 돈을 넣지 않은 상태, 돈을 넣은 상태, 물품을 제공하는 상태로 구분
* 액터: 사용자, 관리자
* 사용자는 돈을 넣을 수 있다.
* 시스템은 사용자가 물품을 선택할 수 있도록 해야함.
    - 보관대 번호와 매칭하여 연결
* 사용자는 기계에 현금을 넣을 수 있다.
* 시스템은 사용자가 해당 물품을 구매할만큼 금액을 넣었는지 확인해야 한다.
* 등, 위와 같은 요구 조건들을 서술함.

<br>

## Use Case Diagram for the Vending Machine
### 시스템: 자판기
### 액터
#### 1차 액터
* 고객, 기계

#### 2차 액터
* 시스템

### 사용 사례
#### 고객
* 상품 확인
* 상품 선택
* 금액 투입
* 상품 수령
* 거스름돈 수령

#### 기계
* 상품 추가, 제거
* 현금 반환

#### 시스템
* 상품 검색
* 금액 유효성 확인
* 상품 전달
* 거스름돈 반환

### 관계
* 고객이 원하는 동작을 오퍼레이터가 모두 수행
    - 따라서, 오퍼레이터는 고객과 일반화 관계에 있음.

#### 포함
* Select products는 Search product로 이어짐
    - Select products --- <<include>> --> Search product

#### 확장
* 금액의 유효성을 확인한 뒤, 거스름돈을 반환할 수도, 안 할 수도 있음.
    - Validate money <-- <<extend>> --- Return change

### 사용 사례 다이어그램
* 이런 use case들을 종합하여 다이어그램을 그릴 수 있음.

<br>

## Class Diagram for the Vending Machine
### 자판기 구성요소
#### 상태
* 상태는 자판기의 현재 상태를 나타내는 인터페이스
* 상태를 구현하는 구현체로 세부 상태들이 존재
    - 돈이 투입되지 않은 상태, 돈이 투입된 상태, 상품을 줘야하는 상태

#### 제품
* 제품 클래스는 제품 정보를 담음

#### Rack
* 보관대 클래스는 보관대 정보를 담음
    - 비었는지 안 비었는지를 반환하는 메소드를 탑재.

#### 인벤토리
* 인벤토리 클래스는 자판기 내부의 서로다른 위치에서 활용할 수 있는 상품 리스트를 담고 있음.
* 이 클래스는 자판기에 제품을 넣을 책임이 있음.

#### 자판기
* 자판기는 위에서 서술한 클래스들의 컴포지션.

### 클래스 간 관계
* 랙은 자판기와 컴포지션 관계
* 프로덕트는 인벤토리와 컴포지션 관계
* 상태는 자판기와 aggregation 관계
    - 세 상태 중 하나만 갖고 있으면 되기 때문인가?
    - 정확히 aggregation이 갖는 속성이 어떤 건지 확인할 필요가 있을 듯.
* 상태 인터페이스는 부모 역할을, 하위 구현체 상태 클래스들은 자녀 역할을 수행
    - 둘은 상속 관계에 있음.

### 클래스 다이어그램
* 위 관계들을 도식화

### 디자인 패턴
* 상태를 여러 가지 구현체로 구현한 것을 상태 설계 패턴이라고 하는 듯함.

### 추가 요구사항
* 환불, 또는 주문 취소
* 돈이 들어있는 상태에서만 동작하도록 주의.

<br>

## Activity Diagram for the Vending Machine
### 자판기에서 상품 구매
* 고객이 자판기에 금액을 투입
* 이후 고객이 원하는 상품을 제공
* 위 두 상태 간 전환을 위한 액티비티 다이어그램을 작성

<br>

## Code for the Vending Machine
* 위 내용들을 종합하여 코드 작성
* 이정도는 직접 처음부터 끝까지 해보는 것도 나쁘지 않을 듯함.

<br>

# Designing an Online Blackjack Game
## Getting Ready: Online Blackjack Game
* 21이 최고 값이 블랙잭 게임

### 면접자에게 기대하는 것
* 게임 플레이어
    - 몇 명이 블랙잭을 플레이 할 것인가?
    - 플레이어들이 서로 상대할 수 있나?
* 점수 관련
    - 점수 얼마까지 플레이어 또는 딜러가 카드를 받을 수 있나?
    - 딜러와 플레이어가 같은 점수면 어떻게 되나?
* 카드 제한값
    - 한 플레이어가 받을 수 있는 카드 수 제한이 있나?

### 설계
* 카드, 플레이어와 같은 가장 작은 요소부터 덱, 컨트롤러와 같은 큰 요소로 발전시킴

### 설계 패턴
* Iterator 패턴
* 상태 패턴: 상태를 기본적으로 인터페이스로 둔 뒤, 각 세부 상태를 구현하는 방식으로 진행할 듯함.

<br>

## Requirements for the Online Blackjack Game
### 요구사항
* 블랙잭 게임은 하나 또는 여러 개의 카드덱을 활용
* 한 덱 당 52개 카드가 들어있음.
* 점수 계산 방식에 따라 카드 별 값을 지정해줌.
* 플레이어는 베팅하고 시작함.
* 플레이어 카드 두 개 모두 오픈하고 시작함.
    - 딜러는 한 카드를 엎어두는 듯
* 점수가 21점을 넘으면 죽음
* 플레이어가 도중에 나가면 딜러가 이긴 것으로 처리됨.

<br>

## Use Case Diagram for the Online Blackjack Game
### 시스템
* 블랙잭

### 액터
* 1차 액터: 플레이어
* 2차 액터: 딜러

### 사용 사례
#### 플레이어
* 플레이어는 게임에 참가할 수 있음.
* 베팅을 할 수 있음.
* 열린 카드를 볼 수 있음.
* 게임을 떠날 수 있음.
* 카드를 더 받을 수 있음.
* 더 카드를 안 받을 수 있음.
* 계정을 만들 수 있음, 갱신할 수 있음.
* 비밀번호를 초기화할 수 있음.
* 회원권을 취소할 수 있음.
* 로그인/로그아웃을 수행할 수 있음.

#### 딜러
* 새 게임을 만들 수 있음.
* 열린 게임들을 볼 수 있음.
* 손패를 만들 수 이씀.
* 카드를 뽑을 수 있음.
* 판의 돈을 모으거나 판의 돈을 승자에게 줄 수 있음.
* 멤버를 블락할 수 있음.
* 그외 플레이어와 같은 계정 관련 기능을 활용할 수 있음.

### 관계
#### Include
* Create hand와 Hit는 Draw card를 포함함.
* Stand는 Collec or payout으로 이어짐

#### Extend
* Cancel membership와 block member는 modify member를 활용하는 기능
    - modify member <-- <<extend>> --- block member, cancel membership

### 사용 사례 다이어그램
* 위 내용을 도식화

<br>

## Class Diagram for the Online Blackjack Game
### 블랙잭 구성 요소
* 카드, 덱, 손패, 플레이어
* 플레이어는 블랙잭 플레이어와 딜러의 추상 클래스
    - 블랙잭 플레이어와 딜러는 플레이어 클래스를 상속받음
* 블랙잭 컨트롤러
* 블랙잭 게임 뷰
* 블랙잭 게임

### 클래스 다이어그램
* 기타 정보를 종합하여 도식화

### 설계 패턴
* 상태 설계 패턴을 활용
    - 제한된 상태를 가지고 있기 때문.
* 몇몇 상태의 예시는 아래와 같음.
    - 덱을 섞음
    - 카드를 뽑아 딜러가 가짐
    - 카드를 뽑아 플레이어에게 줌
    - 카드를 전달함
    - 플레이어 hit/stand
* 위와 같은 상태를 정리해서 전체 시스템을 돌리는 것으로 생각됨.

<br>

## Activity Diagram for the Online Blackjack Game
### 블랙잭 게임플레이
#### 상태
* 플레이어가 게임을 시작
* 플레이어가 이기는 몇몇 상태와 비기는 상태, 플레이어가 지는 상태를 둠.

#### 동작
* 게임을 진행하면서 일어나는 일을 서술.

<br>

## Code for the Online Blackjack Game
* 위에서 따라갔던 내용대로 블랙잭 게임 코드를 작성.
