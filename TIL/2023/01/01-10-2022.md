# **TIL on January 10th 2023**
### Problem Solving Using C++
#### BaaaaaaaarkingDog Practical Algo. Lecture: 0x12 Math
##### [boj.kr/1735](../../../Problem%20Solving/boj/Math/1735-01-10-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 395 B)
* 단순 gcd, lcm 구현 및 응용

#### BOJ step by step: Stack 2
##### [boj.kr/3015](../../../Problem%20Solving/boj/Stack/3015-10-17-2022.cpp)
* 이전에 시도했을 때 시간 초과가 났던 문제.
* `(현재 스택 사이즈) - 1`이 곧 만들 수 있는 쌍의 수임
  - 그렇게 될 때 숫자가 하나면 0개의 쌍을 반환함
  - 5개가 같은 숫자라 생각하자. 일단 가장 작은 인덱스의 숫자를 포함해 만들 수 있는 쌍의 수는 4개. 그 다음은 3개. 이렇게 총 4 + 3 + 2 + 1개의 쌍을 만들 수 있으며, 총 10개의 쌍을 만들 수 있음.

* 이제 스택을 어떤 식으로 활용할지 생각해보자. 물론 스택 활용에 틀어박혀 생각하면 안 되고, 자연스러운 풀이를 고민하자.

* 제약이 되는 쪽은 키가 작은 쪽이다. 그러니 키가 작은 쪽을 버리고 다음으로 넘어가는 방식을 고민하자.

#### solved.ac Essencial Problems
##### [boj.kr/9252](../../../Problem%20Solving/boj/solvedac/9252-01-09-2023.cpp)
* 최대 증가 부분 수열 문제 응용이고, 이를 역추적해 최장 공통 부분 수열을 뽑아내는 건데, 풀이 과정이 아직도 안 익숙해서 기본 문제 구현이 안 됨(boj.kr/9251). 다시 한 번 공부하고 접근할 필요가 있음.
  - 차분히 지금 뭘 구현해야 하는지 명확하게 따지면서 접근하자.
* 이전까지 만든 가장 긴 수열에다 현재 문자 붙여서 새로운 공통 수열 만들기.

* 9251번 정답 코드는 만들었지만, 여전히 점화식 의미가 모호함. 엄밀하게 풀이 작성할 것. 그래야 인덱스 추적해서 9252번을 풀 수 있을 듯.