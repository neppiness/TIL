# **TIL on June 26th, 2023**

## Random Defense Using C++
### [BOJ#17175](/Problem%20Solving/boj/random%20defense/17175-06-23-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 408 B)
* 자기 자신의 호출 횟수를 더해서 이전 호출 횟수들을 더하면 되는 DP 문제.



### [BOJ#10422](/Problem%20Solving/boj/random%20defense/10422-06-23-2023.cpp)
* 괄호가 어디에 붙을 수 있는지 생각해보자. 타일과 비슷한 문제처럼 생각할 수도 있을 듯함.
  - 올바른 괄호 문자열 좌우에 하나씩 배치해서 닫는 문자열을 만드는 경우나, ()에서 이어주는 경우. 이렇게 두 가지를 생각할 수 있음.
* 홀수 길이 괄호 문자열은 옳은 문자열이 될 수가 없음. 짝이 맞지 않기 때문.
* O(N^2) 레벨에서 이전 문자열을 싹 돌아보면서 옳은 문자열을 만들 수 있을 것.
  - () -> (()), ()() -> ()(()), (())(), (()()), ((())), ()()()
  - 2개짜리에 4개짜리를 붙일 수도 있고, 역으로 4개짜리를 2개짜리에 붙일 수도 있음.
  - 각 길이별로 특별하다 할 수 있는 건... 처음과 끝에 괄호 배치해서 전체를 감싸주는 것.


### [BOJ#10800](/Problem%20Solving/boj/random%20defense/10800-06-20-2023.cpp)
* 크기 2천짜리 배열을 20만 개 만드는 것은 그냥 메모리 초과임.
* set에 pair를 넣는 방식? 세트가 20만 개긴 하지만, 안에 원소가 별로 안 들어갈 것이라 문제는 없을 것으로 판단됨.
* 누적합 구하는 방법에 대해서 생각해보자면
  - 정렬을 하고, 하나씩 꺼내면서 자신에 해당하는 값이 없으면 삽입하고, 자신과 같은 값이 있다면 그 값에 크기를 합산하는 방식으로 구현하면 될 듯함.
* 나중에 다시 논리 차근차근 살펴볼 것.


### [BOJ#16120](/Problem%20Solving/boj/random%20defense/16120-06-22-2023.cpp)
* 간단한 문자열이기 때문에 P이다, 아니다로 접근해서 성립될 수 없는 위치에 A가 오는 경우를 파악할 수 있음.
* 확인된 PPAP는 인덱스 0의 P가 되며, 이후 인덱스 1번을 확인하는 로직을 따라 확인하게 된다.
* 좀 더 풀이를 다듬고 시도할 필요가 있을 듯함.

### [BOJ#17136]()
* 큰 색종이부터 붙일 수 있는지 판단하며 붙였다 뗐다를 수행해야 할 문제로 판단됨.