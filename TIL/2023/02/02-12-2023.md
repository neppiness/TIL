# **TIL on February 12th, 2023**
### solved.ac Class 5 Problems
#### [boj.kr/16724](../../../Problem%20Solving/boj/solvedac/16724-02-12-2023.cpp): solved on 1st try (memory: 7884 kB, time: 32 ms, Code length: 1232 B)
* 100만짜리 유니온 파인드로 풀이.
  - 이동하라는 대로 이동하면서 만나는 노드가 같은 부모를 가지고 있으면 패스, 다른 부모를 가지고 있으면 유니온. 이후 모든 정점을 확인하면서 부모 수만큼 safe zone을 만드는 풀이로 접근.

<br>

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1E KMP
#### [boj.kr/4354](../../../Problem%20Solving/boj/KMP/4354-02-10-2023.cpp): solved on 6th try (memory: 7588 kB, time: 204 ms, Code length: 812 B)
* $F(|S| - 1)$ 값을 보자. 이 값이 $|S|$의 약수가 아니라면, 이 값으로 매칭을 시도할 필요가 없다. 만약에 이러한 매칭이 실패했다고 하면, $F(F(|S|-1)-1)$를 확인하는 방식으로 매칭을 이어나간다.
  - 아래와 같은 예시를 보자.

|i|0|1|2|3|
|-|-|-|-|-|
|S|a|a|a|a|
|F|0|1|2|3|

* 이 경우, |S| = 4로, 접두사와 접미사가 매칭하는 최대길이인 $F(|S| - 1) = 3$은 절대로 문자열 제곱을 만족시킬 수 있는 $a^n$의 a가 될 수 없다.
  - 그렇기 때문에, 이의 해당 매칭이 실패했을 경우 가져오는 실패함수인 $F(F(|S| - 1) - 1) = F(2) = 2$값을 가져와 확인한다.
  - 이는 S의 접미사인 aaa의 자기 자신이 아니고 서로 일치하는 접두사이자 접미사의 최대 길이가 2이며, 그것이 aa임을 의미한다.
  - 이 2는 4의 약수이기 떄문에 aa는 $S = aa^(4/2)$가 될 수 있다. 매칭을 시도하고 성공 시 n의 최댓값을 늘린다.
  - 마지막으로 aa의 실패함수를 가져오자. a는 aa의 최대 길이로 서로 일치하는 접두사이자 접미사이다. 또한, |S| = 4의 약수이기 때문에 이를 통한 매칭을 시도한다. 매칭되며, n을 새로 갱신한다.
* 혹시 이보다 더 간단하게 할 수 있는 방법이 있을까?
  - aa가 매칭이 된다면 a로 매칭이 가능하다는 것은 자명하다.
  - abaabaaba의 경우엔 F가 001123456으로 주어지기 때문에, aba가 매칭되는 것을 확인한 후, a에 대해서도 매칭을 시도하게 되지만 이는 실패한다. 
  - 따라서, 다 확인해보는 거라 생각하고 구현하자.
* 물론 KMP를 활용할 수도 있겠지만, 매칭여부는 단순하게 계속해서 MOD 값을 확인해가면서 인덱스를 조절하는 방식으로도 구현할 수 있다.

* 매칭 시도는 아래와 같이 구현하였다.

```cpp
int try_match(int len) {
  int j = 0, cnt = 0;
  for(int i = 0; i < s.size(); i++) {
    if(s[i] != s[j]) return 0;
    j++;
    if(j == len) { j = 0; cnt++; }
  }
  return cnt;
}
```

<br>

### 백준 단계별로 풀어보기: 트리에서의 동적 계획법
#### [boj.kr/2213](../../../Problem%20Solving/boj/Tree/2213-02-06-2023.cpp)