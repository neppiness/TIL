# **TIL on April 18th, 2023**

### solved.ac Class 6 Problems
#### [BOJ #3176](../../../Problem%20Solving/boj/solvedac/3176-04-18-2023.cpp)
* 세그먼트 트리를 활용한 LCA를 통해서 구할 수 있을 것으로 생각됨. 이에 대한 설명은 아래 링크에 있음.
  - [[알고리즘] 최소 공통 조상 LCA 트리 - DP & 세그먼트 트리](https://loosie.tistory.com/m/364)
* 종만북 749페이지부터 서술되는 트리의 최소 공통 조상 찾기 절에서도 해당 내용을 확인할 수 있음. 이에 대해서 공부해보자.

#### [BOJ #1014](../../../Problem%20Solving/boj/solvedac/1014-04-18-2023.cpp)
* 상태트리로 내려간다고 하면 2^100의 상태에 대해 확인해야 할 듯함.
* 당연히 DP로 접근해야 할 문제긴 함. 역으로, 한 자리에 학생을 배치했을 때, 배치할 수 없는 자리가 생김.

### Random Defense
#### [BOJ #20055](../../../Problem%20Solving/boj/random%20defense/20055-04-18-2023.cpp): solved on 1st try (memory: 2732 kB, time: 316 ms, Code length: 1039 B)
* 1은 올리는 위치고, N은 내리는 위치이다.
* 벨트와 로봇이 함께 회전한다.
* 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다.
  - 로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1이상 남아 있어야 한다.
* 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.
* 내구도가 0인 칸의 개수를 세서 K개 이상이 되면 종료하자.

* `if(!move()) { cout << t; return 0; }`

* 내구도는 로테이션 돌림. 1부터 N - 1까지에 있는 로봇들을 옮김. 이는 N - 1을 N으로 옮기면서 시작하면 될 듯함. 그리고 내구도가 0인 칸의 개수를 세는 건 과정의 마지막에 수행하는 것이 좋을 듯함.
* 나온 과정대로 수행하자. 자료 구조에 대한 고민은 크게 안 해도 될 듯함. 내구도 배열을 만들고, 로테이션 하면서 수행해야 하는 명령을 수행하는 것으로. 그리고 지금 몇 번째 인덱스에 로봇이 있는지 표현하는 길이 N짜리 점유 여부 bool 배열도 있으면 무난할 듯함.

* 0번 인덱스는 올리는 곳, N - 1번 인덱스는 내리는 곳으로 지정하자.

* rotate 명령 잘못 사용했었음. 조심할 것.
* cur을 높은 숫자에서부터 내려오는 for문으로 작성했는데, 습관적으로 cur++을 해서 seg_fault 발생. 주의할 것.

* move()를 마친 로봇이 n - 1번 인덱스에 도달한 경우, 이를 제거해줘야 함. 이는 아래 로직을 통해 구현됨.

```cpp
void move() {
  for(int cur = n - 2; cur > 0; cur--) {
    int nxt = cur + 1;
    if(!is_bot[cur] || is_bot[nxt]) continue;
    if(a[nxt] == 0) continue;
    if(--a[nxt] == 0) cnt++;
    is_bot[cur] = 0; is_bot[nxt] = 1;
  }
  is_bot[n - 1] = 0; // 위에서 설명한 로직.
}
```

<br>

### 스프링 핵심 원리 - 기본편
#### 섹션 7. 의존관계 자동 주입