# **TIL on February 7th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x10 다이나믹 프로그래밍
#### [boj.kr/9657](../../../Problem%20Solving/boj/Dynamic%20programming/9657-01-31-2023.cpp): solved on 4th try (memory: 2056 kB, time: 0 ms, Code length: 538 B)
* 최상의 플레이를 한다는 것은 '내가 현 숫자에서 -1, -3, -4 숫자 중 하나라도 부르지 않는다면 이긴다는 뜻으로 생각할 수 있다. 따라서 0: CY, 1: SK로 둔 후에 bool처럼 활용해서 not 값을 가져오고자 함.

* 직감적으로 한 번이라도 SK가 -1, -3, -4 중 하나라도 가져갈 수 있다면 이길 거라 생각했는데 그게 맞는 풀이였음.
  - 선을 잡기 때문에 최선을 다해서 조절할 수 있고, 어쩔 수 없이 가져가지 못하는 수를 제외하고(대표적으로 2)는 모두 SK가 조절해서 가질 수 있다고 보는 게 옳다.


### S3 to G3 Pick and Solve
#### [boj.kr/17413](../../../Problem%20Solving/boj/random%20defense/17413-02-07-2023.cpp): solved on 1st try (memory: 2300 kB, time: 4 ms, Code length: 513 B)
* 공백을 만나면 스택에 넣어놨던 글자들을 출력. 태그가 있다면 그냥 출력.
* 태그의 처음과 끝을 확인해야 한다.
* `<`와 `>`에 따라서 분기를 적당히 나눠서 풀이함. 되는대로 하지 말고, 정확한 풀이를 구상하고 푸는 게 좋을 듯함.

#### [boj.kr/2589](../../../Problem%20Solving/boj/random%20defense/2589-02-07-2023.cpp): solved on 3rd try (memory: 2172 kB, time: 136 ms, Code length: 1269 B)
* 트리의 지름을 구했을 때와 유사하게 임의의 점에서 출발해서 가장 먼 곳을 찾고, 그곳에서부터 다시 BFS를 해서 최장거리를 찾아야 한다.
* 1, 2번째 제출 WA. 무엇이 잘못됐나 파악해보기.

* 다른 뾰족한 수가 없다면 3면이 OOB 또는 W인 L 블럭에 대해서 BFS를 수행해야할 듯.
  - `int adj = 0;`을 선언하고, nx, ny가 유효할 때마다 인접한 정점의 수인 adj를 증가시킴. adj < 2인 정점은 후보로 저장함.
  - 이후 후보들에 대해서 bfs를 수행하고, 가장 긴 경로를 ans 값으로 출력한다.


### 이전에 틀렸던 문제 재시도
#### [boj.kr/20955](../../../Problem%20Solving/boj/Tree/20955-re-02-07-2023.cpp): solved on 1st try (memory: 2412 kB, time: 24 ms, Code length: 546 B)
* 간선을 입력 받으면서 서로 부모가 같은 경우 해당 간선을 잘라야 하기 때문에 필요한 연산 횟수를 증가시킴
* 이렇게 잘라야 하는 간선 수를 입력받으면 주어진 간선 수인 M에서 cnt만큼 줄어듦
  - 정점의 수를 $N$이라 하면 트리는 $(N-1)$개의 간선을 갖기 때문에 `(N - 1) - (M - cnt)`만큼 간선 연결 작업을 해야함.

* 위 풀이가 옳은지 검증해보자.
  - 간선을 받는 도중 부모가 같은 경우가 있다면, 이미 두 노드를 잇는 경로가 존재한다는 것. 그 중 무엇을 자르든 연결 상태가 달라지진 않는다.
  - 이후 부족한 간선 수만큼 이어주는 연산을 수행한다.

* 이 풀이를 구현해보자.
  - m - cnt개는 현재 이어진 간선 수.
  - merge 과정에서 싸이클이 생기지 않도록 간선을 걸렀기 때문에 n개 이상이 될 수 없음.
  - 총 연산 횟수는 `cnt + (n - 1) - (m - cnt)`이다: `cout << n - m - 1 + 2*cnt;`로 구현.


### BOJ Step by Step: 문자열 알고리즘 1
#### [boj.kr/1305](../../../Problem%20Solving/boj/KMP/1305-02-06-2023.cpp)
* 실패함수는 접두사와 접미사 매칭을 시도하고, 자기 자신을 제외한 최대 길이를 반환하는 함수.

* 실패함수의 정의부터 다시 찬찬히 살펴보자.



### S3 to G3 Pick and Solve
#### [boj.kr/17425](../../../Problem%20Solving/boj/random%20defense/17425-02-07-2023.cpp)
* 소인수분해 한 뒤 값들을 백트래킹으로 재조합해서 합을 구하는 편이 빠를 듯함.
  - ~~소인수분해의 시간복잡도는 log 레벨로 떨어지는 것으로 알고 있음.~~
* $g(x) = g(x - 1) + f(x)$를 활용해서 N = 1,000,000까지 계산한 뒤, 입력되는 테스트 케이스에 대해 답을 출력하는 방식으로 구현할 예정.
* 백만이 $2^{20}$ 수준이기 때문에 21번의 연산으로 1, 2, 4, 8, ... , 524288, 1048576까지 얻을 수 있고, 이를 더하는 것도 21개 항만 더하면 된다.

* 소인수분해의 시간복잡도는 $O(\sqrt{N})$임. 따라서 이전 계산 결과를 쓰지 않으면 단순 계산으론 힘듦.