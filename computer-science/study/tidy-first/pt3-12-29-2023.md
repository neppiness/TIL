# **Tidy First? A Personal Excercise in Empirical Software Design**

## Part III. Theory
* 왜 정리를 해야하는지에 대해 얘기하고자 한다.
* 이 파트에서는 다음 질문들을 다룸
    1. 소프트웨어 디자인이 뭔가?
    2. 소프트웨어 디자인이 어떻게 소프트웨어 동작 및 개발 비용에 영향을 미치고, 소프트웨어 개발 및 운용 비용은 어떻게 소프트웨어 설계를 이끄는가?
    3. 소프트웨어 구조에 투자하지 않는 것과 투자하는 것은 어떤 트레이드-오프가 있는가?
    4. 어떤 요인들을 구조 변경 시에 참고할 수 있나?
        + 구조를 어떻게 변경해야 하는지, 구조를 변경하긴 해야하는 건지.

### Chapter 22. Beneficially Relating Elements
* 소프트웨어 디자인이 무엇인가?
    - Beneficially Relating Elements
    - 이점을 주도록 관계되는 요소들

* Elements
    - (의미를 갖는) 토큰들 -> 표현 -> 선언 -> 함수 -> 객체/모듈 -> 시스템
    - 자연적 계층들은 균일하지 않다.
* Relatings
    - 한 함수가 다른 함수를 호출한다: "호출/호출되는" 관계
    - 소프트웨어 디자인에선 다음과 같은 관계를 갖는다.
        + Invokes: 불러내다(호출)
        + Publishes: 발표하다
        + Listens: 듣다
        + Refers: 참조하다
* Beneficially
    - 상호 연관 관계를 조정하여 서로를 이해하는 데 이익을 줌.
* Beneficially Relating Elements
    - 설계자들은 다음과 같은 일을 한다.
        + Create and delete elements
        + Create and delete relationships
        + Increase the benefit of a relationship
    - 시스템의 구조를 얘기할 때는 다음과 같은 것들을 논한다.
        + 요소 계층
        + 요소 간 관계
        + 그런 관계를 만듦으로 얻는 이점

### Chapter 23. Structure and Behavior
* 소프트웨어는 두 가지 방법으로 가치를 만든다.
    - 오늘 수행하는 서비스
    - 미래에 만들 새로운 것의 가능성
* 오늘 수행하는 동작은 시스템의 동작임.
* 동작(Behavior)는 두 가지 방법으로 특징화할 수 있음.
    - Input/output pairs
    - Invariants: 불변의 것
        + 대변과 차변의 합이 같아야 한다-는 조건에 대한 것인 듯.
* 1달러 어치 전기를 통해서 20 달러를 내는 기계가 더 가치 있는 기계. 이를 어떻게 이룰 수 있을까?
* 소프트웨어 가치를 떨어뜨리는 몇 가지 시나리오가 있다.
    - 핵심 인재가 관두는 경우, 며칠이 걸릴 일을 몇 달에 걸쳐 수행해야 할 수 있다.
    - 고객과 거리가 멀어서 가치를 내기 위한 대안을 검토 받는 빈도가 낮아진 경우.
    - 변화를 주는 데 많은 비용이 드는 경우, 적은 옵션을 검토하게 되며, 가치는 줄어든다.
* 구조는 동작에 영향을 미치지 않는다.
    - 다만, 좋은 구조를 갖는 경우 확장하기 쉬워진다.
    - 이는 곧 가치와 직결된다.
* 하지만, 코드 구조에 대한 투자는 그 영향을 실감하기 어렵다.

### Chapter 24. Economics: Time Value and Optionality
* "돈의 흐름대로 노를 저으면 배가 빠르게 나아간다."
* 오늘의 1달러는 내일의 1달러보다 가치있다.
    - 일찍 벌고 나중에 쓰자.
* 혼란스러운 상황에서 옵션들이 더 가치를 발휘한다.
    - 따라서, 불확실한 상황에선 선택지를 더 만들라.

### Chapter 25. A Dollar Today > A Dollar Tomorrow
* 언제, 그리고 얼마나 확실히 얻을 수 있는 돈인지가 중요.
* 내일의 돈은 오늘의 돈 보다 가치가 더 낮다. 왜?
    - 그걸 활용해서 지출할 수 없기 때문
    - 그걸 활용해 투자할 수 없기 때문
    - 받을 수 있을지 불확실하기 때문
* 내가 소프트웨어를 갖고 있다 하면 구매자는 이 소프트웨어의 무엇을 보게 되나?
    - 소프트웨어의 현금 흐름을 모델링할 수 있어야 한다.
        + 얼마가 오고 가는지, 그리고 그 날짜는 언제인지.
* 당장 동작을 바꿔 돈을 벌 수 있다면, 이를 먼저 수행하고 나중에 정리를 하는 게 낫다.
    - 그러나, 이 원리만 있는 게 아니라고 말하고 싶은 듯.
* 시간 가치와 선택 가치는 종종 충돌한다.

### Chapter 26. Options
* 현금흐름할인법(Discounted Cash Flow)
    - 일찍, 더, 높은 가능성으로 돈을 번다.
    - 적게, 늦게, 낮은 가능성으로 돈을 쓴다.
* 그 외에도 가치의 원천인 선택권(optionality)이 있다.
    - 다음으로 어떤 동작을 구현할까?
        + 직접 동작을 구현하기 전이라 해도, 이는 가치를 높여줌.
        + 이는 지금까지 구현해둔 것들보다 가치 있을 수 있음.
        + 내 옵션이 실제로 가치가 있나 없나는 크게 중요하지 않음. 내가 계속 이를 구현하는 데 신경을 쓰고 있다면.
        + 내 예측이 불확실할수록, 선택권은 더 큰 가치를 가짐.
* 재정적 선택지는 아래와 같은 매개변수를 갖는다.
    - 우리가 살 것 그 자체
    - 가격의 휘발성을 포함한 근본적인 것의 가격
    - 옵션의 부가가치, 또는 오늘 지불할 가치
    - 옵션의 지속 기간
* 소프트웨어 디자인은 변화에 대한 준비다.
    - 오늘 하는 설계는 우리가 내일의 동작변화를 구매하는 옵션을 사는 것이다.
* 옵션을 만드는 것과 동작을 변경하는 것에 대한 균형은 아래와 같은 사항들을 고려하여 이루어진다.
    - 잠재적 동작 변경의 가치가 불확실할수록 더 좋다.
    - 내가 더 오래 개발할수록 더 좋다.
    - 나중에 개발할 수 있다면 더 싸지만, 이는 가치의 일부일 뿐이다.
    - 옵션을 만들기 위해 설계일을 덜할수록 더 좋다.
* 그러나, "옵션을 만드는 것과 동작을 변경하는 것에 대한 균형"에 대해 까다로운 문제를 여전히 직면해야 한다.

### Chapter 27. Options Versus Cash Flows
* 현금흐름할인법에 따르면 더 일찍, 더 확실하게 돈을 버는 것과 더 늦게, 덜 확실하게 돈을 쓰게 된다.
    - 그러니 정리부터 시작하지 말 것. 이는 돈을 일찍 쓰고, 늦게 버는 것과 같다. 정리를 아예 할 필요가 없을 수도 있다.
* 선택은 돈을 지금 사용하여 나중에 더 벌라고 한다.
    - 이에 따라 정리를 먼저한다. 정리를 사후에도, 나중에도 해라.
* 그래서 정리를 먼저 해야 하나? 그렇기도 하지만, 아니기도 하다.
* 아래와 같은 경우에는 정리를 먼저 해야한다.
    - cost(tidying) + cost(behavior change after tidying) < cost(behavior change without tidying)
* 그러나, 염려해야 하는 상호아은 다음과 같다.
    - cost(tidying) + cost(behavior change after tidying) > cost(behavior change without tidying)
* 만약 옵션을 만드는 가치가 당장에 잃는 확실한 돈보다 크다면 현금흐름할인법을 적용해도 정리를 먼저하는 게 이치에 맞다.

### Chapter 28. Reversible Structure Changes
* 구조 변경과 동작 변경: 구조 변경은 되돌리기 쉽다.
* 되돌리기 쉬운 결정들은 가볍게 진행할 수 있다.
    - 그렇지 않은 결정은 더블체크, 트리플체크까지도 하면서 신중히 해야한다.

### Chapter 29. Coupling
* 비싼 프로그램은 하나의 요소를 수정하기 위해 다른 요소들을 수정해야 한다.
* 상대적으로 싼 프로그램은 국지적으로만 변경하면 된다.

* 이같은 속성을 연관성(coupling)이라고 명명하였다.
    - 한 요소의 변경이 다른 요소의 변경을 요구하는 것
* 단순하게 caller() 메소드가 called() 메소드를 호출하는 경우
    - called() 메소드의 이름을 변경하면 이를 호출하는 caller() 메소드의 called() 메소드 호출문도 변경되어야 함.
    - 다만, 변경이 절대 일어나지 않을 부분이 연관되어 있는 경우, 이는 문제가 되지 않는다.
* 1-N
    - 한 요소는 다른 요소들과 얼마든지 연관될 수 있다.
* Cascading
    - 변경 사항은 한 요소에서 다른 요소로, 그리고 그 변경 사항은 또다시 다음 변경 사항들을 유발할 수 있다.
* 하나의 서비스가 다른 서비스를 호출하는 것만으로는 둘이 연관되었다고 할 수 없다.
* 시스템이 복잡하다고 말하는 건 변경 사항들이 예상치 못한 결과를 일으킨다는 것이다.

### Chapter 30. Constatine's Equivalence
* 70%의 개발 비용이 유지보수에 들어간다고 함.
* cost(software) ~= cost(change)
* 그러나 아웃라이어에 해당하는 거대한 변경사항이 변경에 대한 비용의 대부분을 차지한다.
    - cost(change) ~= cost(big changes)
* 그렇다면, 어떤 것들이 변경 사항을 비싸게 만드나?
    - 연관성이 변경을 힘들게 만든다.
    - cost(big changes) ~= coupling
* 그러므로, 콘스탄틴의 등식은 아래와 같다.
    - cost(software) ~= cost(change) ~= cost(big changes) ~= coupling
* 또는, 결과적으로 `cost(software) ~= coupling`이 된다.
    - 따라서, 소프트웨어의 비용을 줄이기 위해선 연관성을 줄여야 한다.
    - 그러나, 연관성을 없애는 것은 공짜가 아니고, trade-off가 있다.

### Chapter 31. Coupling Versus Decoupling
* 왜 우리는 모두의 연관성을 없애지 않는가?
    - 작성하다보면 다 인지한 상태로 할 수가 없다.
* 간단하게 연관되게 로직을 작성할 수 있고, 길고 더 비싼 디커플링 구현이 있다 하면
    - 경제적으로 연관된 로직을 작성하는 게 합리적이다.
* 연관된 시스템을 작성하는 게 지금껏 문제가 아니었다가 나중에야 문제가 되는 경우가 있다.
* 커플링이 반드시 필요한 경우가 있다.
* 결국 왜 커플링이 이루어지는지는 중요하지 않다.
    - '지금' 어떤 비용을 지불할지 선택해야 하기 때문.
* 디커플링 역시 많이 할수록 비용이 비싸진다.
    - 따라서, 커플링과 디커플링 비용을 적절히 지불할 만한 균형점을 찾아야 한다.

### Chapter 32. Cohesion
* 연관성을 고려할 때, 응집력 또한 고려해야 한다는 내용으로 들림.
    - 연관성을 제거한 메소드들을 한 곳에 응집시켜 두는 방식도 해법 중 하나.

### Chapter 33. Conclusion
* 정리를 먼저해야 하는지에 대한 대답을 할 준비가 되었다.
* 매번 조금씩 다르지만, 결국 같은 힘에 영향을 받게 된다.
    - Cost: 정리가 비용에 어떤 영향을 미치나
    - Revenue:정리가 수익에 어떤 영향을 미치나
    - Coupling: 정리가 적은 요소를 변경하게 만들어주나
    - Cohesion: 정리가 변경 사항이 좁고 집중된 영역의 요소를 바꾸게 해주나?
* 결국 다른 사람과의 상호작용도 중요하다는 말을 하고 싶은 듯
