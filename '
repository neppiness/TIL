# **Grokking Modern System Design Interview for Engineers & Managers**

# Week #1: 10.01.2023.
## Introduction
* 시스템 설계 컨셉의 구성
  - 분산 시스템(distributed systems)
  - 컴퓨터 네트워킹(computer networking)
  - 병렬 연산(parallel computing)
* 시스템 설계를 통해 목표하는 것
  - Reliable
  - Effective
  - MaintainableByzantine

<br>

## System Design Interviews
* 어떤 컴포넌트를 도입할 때의 트레이드 오프에 대해 말할 것.
  - ex) SQL & noSQL
* 좋은 질문을 해야함(ask refining questions)
* 해결 과정
  - 문제를 정제(refine)함
  - 면접관과 토의(discuss)할 것

<br>

## Abstractions
* 추상화를 통해서 디테일은 감춤.
  - 어떤 일을 하는지만 드러냄
  - 데이터베이스의 트랜잭션
  - 분산 시스템의 추상화
* RPC
  - IPC와 유사. Inter-Process Communication
  - 단지 local에서 일어나는 게 아니라 인터넷을 통해 일어난다는 게 다름
  - 이를 통해 개발자는 내부적으로 어떤 일이 일어나는지 몰라도 분산 시스템을 활용해 프로그램을 개발할 수 있다.
* Spectrum of Consistency Models
  - CAP 이론에 따르면, consistency와 accessibility, parition tolerance는 동시에 높은 수준을 달성할 수 없다고 함.
  - Eventual consistency에서부터 linearizable consistency에 이르기까지 많은 단계의 항상성 레벨이 있음.
  - 어떤 정보를 처리하는가에 따라 이 항상성 수준은 달라진다.
    + 패스워드의 경우, 새롭게 설정하면 곧장 모든 분산 DB에 대해서 갱신이 되어야 한다.
    + 그렇지 않으면, 유저가 장애를 겪을 수도 있고, 이미 알려진 이전 비밀번호로 계정에 접근하는 경우가 발생할 수 있음.
* Spectrum of Failure Models
  - Fail-stop: 노드 하나가 멈춤. 감지 가능.
  - Crash: 노드 하나가 조용히 멈춤. 감지 불가.
  - Omission failures: 메시지를 주거나 받을 때 누락이 발생하는 경우
  - Temporal failures: 계산해서 넘겨주지만 이 정보가 더이상 쓸모 없는 경우
  - Byzantine failures: 에러 등으로 인한 복잡한 실패

<br>

## Non-functional System Characteristics
* Availability: 활용성
  - ((Total time) - (Amount of time service was down)) / (Total time)
  - 산정 방법이 다를 수 있음.
  - 9가 몇 개인지로 표현함: 90%, 99%, 99.9%, ...
* Reliability: 신뢰성
  - 서비스 다운 시 이를 얼마나 신속히 복구하는지-에 대한 지표
  - 높은 신뢰성을 목표로 함
* 활용성과 신뢰성: 둘 다 높은 서비스를 목표로 함.
* Scalability
  - 3가지 확장성
    + Size: 유저나 데이터 수의 증가에 대한 확장성
    + Administrative: 하나의 분산된 시스템을 통해 여러 기관이나 유저가 접근 가능한지에 대한 확장성
    + Geographic: 지리적으로 넓은 영역에 대한 확장 가능성
  - 확장성의 다른 접근
    + 수직적 확장성: 하나의 서버의 성능을 높이는 것
    + 수평적 확장성: 여러 서버를 활용하는 것. 다만, 이들이 하나의 서버처럼 동작해야 함.
* Maintainability
  - 유지보수성의 3가지 속성
    + 동작성: 일반적인 상황에서 잘 동작해야 함. 추가적인 유지보수 필요가 발생하지 않도록 해주는 것.
    + 명료성: 코드가 단순해야 유지보수를 빠르게 수행할 수 있음.
    + 변경용이성: 유지보수를 수행할 때 빠르게 변경이 가능해야 함.
  - 유지보수성 측정
    + 한 건의 유지보수 당 고치는 시간으로 산정
* Fault Tolerance
  - 문제에 대한 내성
  - 사본을 만듦으로 오류에 대응
  - 체크포인팅을 통해 계산을 수행한 내용을 순차적으로 저장하는 등을 수행Put Back-of-the-envelope Numbers in Perspective
    + 이 경우, 관찰하는 시간 간격에 따라서 값이 꾸준히 갱신이 될 수도, 그대로 유지될 수도 있음.
    + 이에 대한 내용은 그림으로 나옴.

<br>

## Back-of-the-envelope Calculations
### Put Back-of-the-envelope Numbers in Perspective
* 대략적으로 서버가 얼마의 일을 처리할 수 있는지 계산하는 과정 설명
* 서버를 웹 서버와 어플리케이션 서버, 스토리지 서버로 나눔.
  - 각각에 필요한 기능에 따라서 메모리 및 CPU 코어 수가 다르게 활용될 수 있음을 설명.

### Example of Resource Estimation
* Twitter의 예로 Outgoing bandwidth와 Incoming bandwidth, 그리고 1년에 증설해야 하는 데이터 사이즈를 가늠함.

<br>

## Building Blocks
### Introduction to Building Blocks for Modern System Design
* 16개 빌딩 블록에 대한 정의

<br>

* 이후로 이어지는 DNS에 대한 내용.

<br>

# Week #2: 10.08.2023.
## Databases
### Introduction to Databases
* DB를 활용하지 않으면 발생하는 문제
  - 파일을 통해 정보를 관리한다고 하면 발생하는 문제들.
    + 직접 생각해보면서 나열된 항목을 떠올려보자.
* DB는 아래와 같은 특성이 있다.
  - 큰 데이터의 저장
  - 데이터 조작이 용이
  - 권한이 있는 사용자만 접근 가능
  - 확장성: 샤딩 등의 기술에 의해서 서버를 늘리는
  - 가용성(availability)이 좋다.

### Types of Databases
* 관계형 데이터베이스
  - ACID 특성.
  - 트랜잭션을 통해서 해당 변화를 커밋할 것인지, 아니면 롤백할 것인지 결정
    + 버전 컨트롤 시스템과 유사하다 생각함.
    + 단, 전후관계를 기록한다고 이해함.
  - 데이터 중복 방지
    + join과 같은 기능을 통해 여러 테이블을 엮을 수 있음.
    + 합친 테이블을 따로 저장하지 않아도 되니 중복도 방지됨.
    + 또한, 합친 테이블의 내용과 그 전 테이블의 내용의 불일치가 발생할 걱정이 없음.
  - 내용을 싹 기록하고 있어서, 문제가 생겨도 이전 내용을 import 하거나 export 하는 게 가능함.
  - 다만, 데이터베이스에 기록할 수 있는 자료형이 한정되기 때문에, 우리가 사용하는 언어의 자료형들보다 형태가 제약된다.

### Data Replication
* 데이터 사본을 만드는 데에는 몇 가지 전략이 있음.
1. Single leader/primary-secondary replication
  - read-heavy한 경우 유효
2. Multi-leader
3. Peer-to-peer
  - All-to-all 전략을 통해 데이터 항상성 유지
  - Quorums를 통해서 최신 데이터를 구할 수 있음.
  - DynamoDB에서는 여러 노드의 데이터를 가져오고, 그 안에서 최소 하나 이상의 최신 데이터를 얻는 식으로 접근
* 각 데이터 레플레이케이션 방법이 갖는 특징이 있음.

### Data Partitioning
* 샤딩 유형
  - 수직 샤딩(Vertical Sharding)
  - 수평 샤딩(Horizontal Sharding)
* 샤딩 방식
  - 수동
  - 자동
* Primary key에 의한 샤딩
* Secondary indice에 의한 샤딩
  - 모든 노드에 Secondary indice에 대한 쿼리를 수행하면 굉장히 비효율적으로 동작함
  - 따라서, 중간에 매핑 역할을 해줄 별도의 노드가 필요함.
* 노드 재분배에 대한 요청 경로 찾는 방법
* 주키퍼

### Trade-offs in DataBases
* 중앙화시스템
  - 장점
    + 관리가 쉬움
  - 단점
    + 1개 노드가 고장나면 시스템 붕괴
    + 데이터량이 많아지면 성능 저하
* 분산시스템
  - 장점
    + 데이터량이 많아도 부하 분산 가능
    + 한 개 노드에 문제가 발생해도 시스템은 유지됨
  - 단점
    + 데이터 항상성 유의
* 분산 투명성 수준
  - Location Transparency: 데이터를 여러 노드에서 받아왔다는 걸 몰라도 됨
  - Parition Transparency: 데이터가 여러 개의 표에 나뉘어 있단 걸 몰라도 됨
  - Replication Transparency: 데이터가 여러 개 있단 걸 몰라도 됨
  - 위와 같은 것을 왜 '투명성'이라 하는지 모르겠음. 추상성이라는 단어가 더 어울릴 듯함.

<br>

## Key-value Store
### System Design: The Key-value Store
* 단순 해싱에 대한 이야기 아닐까?

### Design of a Key-value Store

### Ensure Scalability and Replication
* Consistent hashing에서 virtual node의 활용까지
  - 이를 통해 서버의 연산력에 부합하는 부하를 줄 수 있게 됨
* Data replication
  - Primary-secondary approach
  - Peer-to-peer approach
    + peer-to-peer를 활용하여 총 5개 노드가 있다면 3개 노드에 대해서 쓰기를 수행.
    + (이를 통해 데이터를 확인하려 할 때는 3개 노드에서만 뽑아도 됨)

### Versioning Data and Achieving Configurability
* Vector clock과 Quorums를 활용하여 Configurability 확보
  - 정확하게 이해하진 못함. Configurability라는 게 뭔지도 애매함.

### Enable Fault Tolerance and Failure Detection 
* Handle temporary failures
  - Quorum-based approach를 통해 시스템 실패(failure)를 관리함
* Handle permanent failure
  - Merkle tree
    + 리프의 값이 바뀌면 부모 노드를 찾아 올라가면서 해쉬값을 갱신.
    + 이를 통해 값이 바뀌었는지 판별할 수 있음.
    + 관리할 노드의 범위가 바뀌었다면 Merkel tree에서 확인하여 갱신할 수 있음.
  - Virtual node를 통한 실패(failure) 확인
    + gossip protocol을 잘 설계해서 노드를 배정.
    + 이를 통해서 본인의 failure 여부를 확인하는 상황이 발생하지 않도록 제어

* Key-value Store
  - 유저 정보나 세션 정보를 활용해 key-value store를 사용한다면, 실시간 추천 등의 로직을 구현할 수 있다.

<br>

## Content Delivery Network (CDN)
### System Design: The CDN
* 큰 데이터를 하나의 노드를 통해서 전달하는 서비스는:
  - 큰 지연시간(latency)에 직면하게 된다.
  - 또한, 노드 하나가 다운되면 서비스가 먹통이 된다.
* Netflix, Amazon Prime 등, 매우 큰 데이터를 전달하는 CDN은 굉장히 큰 인터넷 트래픽을 발생시킴.
  - 이를 효율적으로 다루는 것은 서비스 품질 측면에서 중요.

### Introduction to a CDN
* Proxy 서버를 활용하여 레이턴시 감소
  - 캐싱해둔 데이터를 유저들에게 짧은 레이턴시로 전송해줌.
  - 넷플릭스 같은 경우 90% 수준의 영상을 캐싱할 수 있지만, 유튜브는 그럴 수가 없다.
  - CDN이 갖춰야 할 요소들
    + ...
    + Availability
    + Scalability
    + Security and 

### Design of a CDN
* CDN 구성요소
  - Clients, Routing System, Scrubber servers, Proxy servers, Distribution system, Origin servers and Management system.
* Workflow
  - Setup
    + 본 서버에서 루팅 시스템에 모든 URI 정보 제공
    + 본 서버가 각 컨텐츠를 프록시 서버에 뿌림
    + 분산 현황을 요청 루팅 시스템에 전달
  - 클라이언트 요청 시작
    + URI에 대해 루팅 시스템에 요청. 가장 가까운 프록시 서버를 안내 받음
    + scrubber 서버를 통해 걸러짐
    + 프록시 서버에 도달. 관련 통계를 관리 시스템에 전달.
    + 만약 프록시 서버에 컨텐츠가 없다면 본 서버로 이동.
* API Design
  - Retrieve: 프록시 서버에 컨텐츠에 대한 탐색을 요청은 경우
  - Deliver: 본 서버가 프록시 서버에 요청
  - Request: 클라이언트가 프록시 서버에 수행
  - Search: 프록시 서버가 동료 프록시 서버에게 해당 컨텐츠가 있는지 확인
  - Update: 프록시 서버가 동료 프록시 서버에 이미지 크기 변경, 영상 해상도 변환 등을 요청

### In-depth Investigation of CDN: Part 1
* Content caching strategies in CDN
  - Push CDN: 원 서버에서 프록시 서버로 컨텐츠를 넣어줌
  - Pull CDN: 프록시 서버가 유저의 요청에 따라 원 서버에서 필요한 자료를 찾아 끌고옴
  - Push CDN은 가용성이 높다. / Pull CDN은 저장공간이 적게 든다. / 보통 이 둘을 같이 쓴다.
* Dynamic content caching optimization
  - 동적 컨텐츠는 프록시 서버에서 활용하는 게 효과적이다.
  - ESI와 같은 것으로 압축하여 원형 템플릿을 공유할 수 있다.
* Multi-tier CDN architecture
  - Tree 형태로 프록시 서버를 둠
  - 원 서버는 루트: 이 원 서버는 여러 대의 서버로 되어 있음.
  - 2계층이라고 하면 원 서버를 부모 노드로 갖는 상위 프록시 서버가 있음
  - 하위 프록시 서버는 상위 프록시 서버의 자녀 노드
* Find the nearest proxy server to fetch the data
  - 그래서 어떻게 전세계적인 요청을 가장 가까운 프록시 서버가 받을 수 있게 할 것인가-
  - Important factors that affect the proximity of the proxy server
    + 거리 개념을 정립: 네트워크 거리(network distance), 요청 부하(request load)
  - DNS redirection
    + 부하가 적은 곳으로 유저를 보냄
    + 서비스가 다운되지 않은 상태로 각각의 서버를 보수할 수 있게 해줌.
  - Anycast
    + 서로 다른 위치의 서버가 동일한 IP를 활용하는 Anycast라는 방법이 있음.
    + 이를 일반적인 IP에 따라 동작하게 하려면 Border Gateway Protocol이 필요하다.
  - Client multiplexing
    + 활용할 수 있는 여러 서버 목록을 넘겨줌. 그리고 클라이언트가 고르게 함.
    + 클라이언트가 최적의 결정을 하기 힘들기 때문에 좋지 않은 결과로 이어질 수 있다.
  - HTTP redirection
    + 원 서버에 요청을 하면 클라이언트를 적절한 곳으로 리디렉션하는 방식

### In-depth Investigation of CDN: Part 2
* Content consistency in CDN: 
  - Periodic polling: 주기적으로 원 서버에서 컨텐츠를 가져옴
  - Time-to-live (TTL): 원 서버에서 컨텐츠마다 TTL을 설정해서 보내줌. 만료 시 프록시 서버는 업데이트 여부를 확인해야 함.
  - Leases: 임대하는 식으로 사용. TTL 개념과 크게 다른 점은 모르겠음.
* Deployment: 프록시 서버 배치
  - Placement of CDN proxy servers
    + 구글과 같이 TCP를 활용한 새로운 인프라를 활용할 수도 있음.
    + ISP 내부에 서버를 위치시켜서 이점을 가져가기도 함.
    + IXP 근처에 서버를 위치시켜서 지연시간을 단축시키기도 함.
    + ProxyTeller와 같은 툴을 활용해 어디에 프록시 서버를 두는 게 좋은지 판단함.
* CDN as a service
  - CDN 서비스를 제공하는 회사들이 있음.
  - 이들을 활용해서 CDN을 쓸 수도 있지만, 이들의 상황에 따라 제약이 발생할 수 있음.
* Specialized CDN: Open Connect Appliance (OCA)를 통해서 캐싱한 데이터 제공
  - Why Netflix built its CDN
    + 데이터 집중적(data-intensive)인 넷플릭스의 요구를 공적 CDN이 따라갈 수가 없었음.
    + 본인들의 목적에 상충했기 때문에 새롭게 CDN을 구축했고, 더 빠르게 TCP 연결을 맺고, 높은 캐시 적중률을 얻었음.

### Evaluation of CDN's Design
* 위와 같은 설계를 통해서 짧은 지연시간에 많은 트래픽을 처리할 수 있게 됨.
* 수평적 확장성도 확보할 수 있음.
* 하나의 실패가 시스템 다운으로 이어지지 않음.
* 컨텐츠가 자산이므로, 이것이 다른 곳에 유출되지 않도록 막을 수 있음.

<br>

## Sequencer
### System Design: Sequencer
* Motivation
  - 이벤트 추적을 위해 고유 식별자(unique ID)를 활용하고자 함.
  - 그러나, 분산 시스템에서 이를 활용하는 것은 어렵다.
  - 이에 대한 방법을 소개하고자 함.

### Design of a Unique ID Generator
* Requirements for unique identifiers
  - 유일성, 확장성, 가용성, 64-bit 숫자 ID
* First solution: UUID
  - Cons: 유일하지 않음(중복 가능성이 거의 없지만), 64비트 숫자가 아님.
* Second solution: using a database
  - 중복 가능성이 있고 확장성도 없음.
* Third solution: using a range handler
  - Pros
  - Cons
