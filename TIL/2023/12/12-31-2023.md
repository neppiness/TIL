**TIL on December 31st, 2023**

## Problem Solving
### BOJ#1459: 걷기
* (대각선 걷기) < 2*(한 블록 가로지르기)라면 대각선 걷기를 최대로 활용
    - 좌표만 int 범위인 거지, 걸리는 시간을 곱하면 무조건 long long 범위로 풀어야 함.
* 대각선 걷기가 아무리 저렴해도, 너무 앞으로 가면 돌아가는 데 비용이 많이 듦.
* 대각선 걷기를 지속할 수 있음.
    - 이를 통해서 억지로 근처까지 갈 수 있음.
    - 좌표 합이 짝수가 아닌 경우에만 대각선 걷기로 영원히 가까워질 수 없음.
    - 좌표 합이 짝수인 경우 최소 몇 번 대각선 걷기를 해야하는지 계산해야 함.
* 대각선 걷기를 하다 말 수도 있음.
* 모든 경우를 다 계산하고 최솟값을 찾는 식으로 풀이하면 깔끔함.
* 1번째 제출 AC
    - 메모리: 2020 kB, 시간: 0 ms, 코드 길이 412 B

### BOJ#11812: K진 트리
* 적은 에너지 방법으로 트리를 구성하는 경우
    - N(1부터 시작)층의 시작 원소, 끝 원소는 다음과 같이 계산해야 함.
* 1층부터 N층까지 원소 총합: 1층은 K^0개, 2층은 K^1개, N층은 K^(N-1)개의 원소를 가짐.
* Sigma_(i = 0)^(N - 1) { K^i }
    - 등비수열의 합과 같음.
* 일반항 K^(i - 1)
    - (총합) = (K^N - 1) / (K - 1)
* 검산: K는 3인 경우
    - 1층은 (3 - 1) / (3 - 1)
    - 2층 마지막 원소는 (3^2 - 1) / (3 - 1) = 8 / 2 = 4
    - 3층 마지막 원소는 (27 - 1) / 2 = 13
* 그래서 N층의 몇 번째 원소인지 기록할 필요가 있음.
    - 원소가 x층에 있는 것으로 확인되면 (x - 1)층의 마지막 원소 번호로 뺀다.
    - 이를 통해 N층의 M(M >= 1)번쨰 원소라는 것을 확인할 수 있음.
* 그리고 이제 거슬러 올라가는 과정이 중요한데,
    - 1부터 시작해버리면 결국 1을 뺴야하는 귀찮은 상황이 발생함.
    - 그러니 층도 인덱스도 0부터 시작하는 게 좋음.
* 부모노드를 구하는 과정을 생각해보자.
    - N층의 M번 인덱스 요소는 누구의 자식 노드일까?
* 삼진 트리의 노드 2를 생각해보자.
    - 2는 1층의 0번 노드.
    - 현재 층을 3등분해야 함.
        + 1층의 경우, 현재 층의 요소가 3개이기 때문에, 1로 나눈 몫이 기준이 됨.
    - 현재 층을 3등분한다는 것은, 전층의 원소 수로 나눈다는 의미기도 함.
        + 그러나, 현재 층의 원소 수를 파악하는 게 더 편함.
        + 현재 층의 마지막 노드 번호와 이전 층의 마지막 노드 번호의 차이로 구할 수 있음.
        + 이를 구한 뒤 3등분하면 됨.
    - 9는 2층의 4번 노드.
        + 4를 3으로 나눈 몫은 1임.
        + 따라서, 1층의 1번 노드(3)의 자식
* long long 범위를 넘어가지 않으리란 보장이 있나?
    - 시작 번호가 10^15이라 하더라도, 무조건 끝 번호가 10^18 이내로 들어옴.
    - 따라서 이 부분이 문제는 아님.
* K진 트리가 일진 트리인 경우가 문제.
    - 이 경우, (K - 1)로 나누는 코드가 모두 오작동함.
    - 따라서, 해당 예외를 따로 처리해주는 식으로 구현함.
* 3번째 제출 WA
