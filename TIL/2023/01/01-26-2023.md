# **TIL on January 26th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1B 최소 신장 트리
#### [boj.kr/2887](../../../Problem%20Solving/boj/Minimum%20spanning%20tree/2887-01-26-2023.cpp): solved on 3rd retry (memory: 14104 kB, time: 96 ms, Code length: 1232 B)
* 간선을 받으면서 비용을 저장. 이후 MST를 구축하며 가중치 합을 출력
* 1번째 시도 실패. N이 100,000인데, 100,000 * 100,001 / 2 만큼 간선 정보를 저장하게 만듦.
  - 공간 복잡도를 낮출 수 있는 키가 있을 것. 아마 비용에 대한 식이 아닐까 싶음.
* 2번째 시도 실패. 풀이가 성립하는지 생각해볼 것.
* 3번째 시도 성공. i번째 행성이라고 기록하지 않고 정렬을 했기 때문에 문제가 발생한 것.
  - i번 행성에 대해 i번 행성이라 기록하고(`x[i] = {cx, i};`) 정렬을 수행.
  - 이후, 1부터 n - 1까지 확인하면서 앞뒤에 있는 값들의 차의 절대값을 cost로 활용.
  - 해당 cost가 어떤 행성과 어떤 행성을 잇는 터널의 cost인지도 기록하고 간선 정보를 e에 추가함.
  - 나머지는 크루스칼 알고리즘을 따라 최소 신장 트리를 구한 뒤 가중치 합의 최솟값을 출력함.

* PR을 위해 작성한 해설은 아래와 같음
```cpp
/*
모든 행성 간 간선을 계산하고 저장하면
최악의 경우 약 50억 개의 간선 정보를 저장해야 합니다.
따라서 꼭 필요한 간선 정보만 추려낼 논리가 필요합니다.

i번째 행성의 좌표 정보를 받아
pair<int, int> x, y, z 배열에 저장합니다.
이 배열은 좌표 값과 행성 번호를 기록합니다.

이 좌표 배열들을 정렬하면(47-49번째 줄)
좌표의 차이가 적은 좌표 값들을 앞뒤 인덱스에 둘 수 있습니다.
이를 활용해 좌표 값 간의 차이를 절대값으로 계산해 간선의 비용을 계산하고,
간선이 잇는 두 행성의 번호를 간선 정보로 함께 저장합니다(51-55번째 줄).

이후 크루스칼 알고리즘을 따라
간선 정보를 비용에 대해 오름차순으로 정렬하고,
비용이 작은 간선부터 확인하며 MST를 구축합니다.
이 과정에서 간선 가중치 총합의 최솟값을 계산하고 그 값을 답으로 출력합니다.
*/
```


#### [boj.kr/17472](../../../Problem%20Solving/boj/Minimum%20spanning%20tree/17472-01-26-2023.cpp): solved on 3rd retry (memory: 2076 kB, time: 0 ms, Code length: 2081 B)
* BFS로 섬 구분.
* 좌에서 우, 위에서 아래로 긁으면서 바다인 곳 수를 세고, 간선 비용으로 기록하면 어떨까? 그러면 O(NM)에 섬에서 섬으로 가는 다리 수를 구할 수 있음
* 이후 크루스칼 MST를 통해 다리 길이 최솟값 출력하고 종료.
* 간선 개수가 (섬 개수 - 1)을 만족 못하는 경우 -1 출력.

* find_edge 로직을 아래와 같이 작성함

```cpp
void find_edge() {
  for(int i = 0; i < n; i++) {
    int cnt = 0, no = 0;
    for(int j = 0; j < m; j++) {
      if(!board[i][j]) { cnt++; continue; }
      if(no && cnt >= 2) e.push_back({cnt, no, board[i][j]});
      no = board[i][j];
      cnt = 0;
    }
  }

  for(int j = 0; j < m; j++) {
    int cnt = 0, no = 0;
    for(int i = 0; i < n; i++) {
      if(!board[i][j]) { cnt++; continue; }
      if(no && cnt >= 2) e.push_back({cnt, no, board[i][j]});
      no = board[i][j];
      cnt = 0;
    }
  }
}
```

  - 다리 길이가 2 이상이어야 한다는 조건을 깜빡했어서 이를 추가함(`cnt >= 2`).
  - 가로 방향, 세로 방향 탐색에 대해 같은 로직을 for문 도는 변수 순서만 바꿔서 재활용. 코드가 길어지지만, 다른 구현법을 떠올릴 필요가 있는지 잘 모르겠음.


### solved.ac Essential Problems
#### [boj.kr/9328](../../../Problem%20Solving/boj/solvedac/9328-01-26-2023.cpp): solved on 1st try (memory: 2048 kB, time: 4 ms, Code length: 1759 B) 
* `h * w`의 총합은 백만 이하임
* `bool key[26];`: 상근이가 소지한 열쇠를 기록함
* 벽이 아닌 곳을 통해 들어갈 수 있다고 했으니, 둘레로 이동 가능한 공간을 board 상에 추가할 것. 이후 (0, 0)에서부터 BFS를 시도하면 자연스럽게 모든 통로를 탈 수 있음.
* BFS로 모두 방문한 뒤에 처리할 방법을 생각하는 것도?
  - BFS가 끝나지 않은 상태에서 문에 도달한다면 이를 열 수 있는지 여부가 결정되기 전까지 유보해도 괜찮을 듯

* 잠긴 문에 도달하면, `vector<pair<int, int>> door[26]`로 저장을 해뒀다가, 키를 발견하면 그 위치를 큐에 넣음.
  - 원래 키를 가지고 있는 경우엔, 잠긴 문에 도착했을 때 키 소지 여부를 확인하여 처리.

* isupper와 islower는 따로 구현할 필요가 없음. C++ 내장 함수로 존재하니, 구현하는 데 시간 쓰지 말고 활용할 것. 반환 값은 true 또는 false
  - A value different from zero (i.e., true) if indeed c is an uppercase alphabetic letter. Zero (i.e., false) otherwise.(from https://cplusplus.com/reference/cctype/isupper/)


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1C 플로이드 알고리즘
#### [boj.kr/17182](../../../Problem%20Solving/boj/Floyd%20algorithm/17182-01-26-2023.cpp): solved on 1st try (memory: 2020 kB, time: 4 ms, Code length: 737 B)
* 모든 행성을 탐사하는 데 걸리는 최소 시간 계산하기
* 간단한 플로이드 구현 문제
* PR용 해설로 아래와 같이 주석을 작성함

```cpp
/*
N이 10으로 모든 순열을 계산할 만하기에 
행성에서 다음 행성으로 이동하는 경로를 next_permutation으로 확인합니다.
시작 행성인 st를 제외한 나머지 행성 번호는 comb에 추가합니다.
플로이드 알고리즘으로 한 행성에서 다른 행성으로 이동하는 최소 시간을 구합니다.
이후 모든 순열을 확인하며 모든 행성을 탐사하는 데 걸리는 최소 시간을 계산합니다.
*/
```

#### [boj.kr/13168](../../../Problem%20Solving/boj/Floyd%20algorithm/13168-01-26-2023.cpp)
* 인접행렬 10억으로 초기화. `i == j`인 경우에만 0으로 넣음.
* 인접행렬 2개를 사용해서 내일로 사기 전과 산 경우에 대한 비용을 입력할 것.
* M개의 도시를 해당 순서대로 방문하는 것으로 보임.
* 해시를 사용해서 도시와 번호를 매칭.
* 티켓 비용을 정확히 계산해야 하는데, 의도적으로 0.5 더하기 0.5를 시키려고 함. 이를 방지하기 위해 모든 비용을 2배로 만들고 50% 할인을 하더라도 정수로 딱 계산되게 수정함.

* PR용 주석은 아래와 같이 작성함
```cpp
/*
도시 이름으로 도시 고유 번호를 불러올 수 있도록 해시를 활용합니다.
목적지는 해시를 통해 도시 고유 번호를 불러와 해당 번호를 저장합니다.
인접행렬 2개를 사용해서 내일로 사지 않은 경우와 산 경우를 구분해 비용을 입력 받습니다.
인접행렬에 기록된 값과 현재 입력된 값 중 최솟값을 비용으로 저장합니다.
내일로를 구매한 경우, 문제 조건에 따라 할인된 금액을 저장합니다.
정수 범위로 정확히 값을 산정하기 위해 모든 비용은 2배를 큰 값으로 둡니다.
인접행렬의 모든 값을 0x3f3f3f3f로 초기화합니다.
그 후 `i == j`인 경우에만 0을 넣습니다(42-46번째 줄).
diff는 (내일로를 구매한 총 여행비용) - (내일로를 구매하지 않은 총 여행비용)을 의미합니다.
따라서, 경로를 돌면서 내일로를 구매하지 않은 이동 비용은 diff에서 차감하고,
내일로를 구매한 경우의 이동 비용은 diff에 더합니다.
이렇게 계산된 diff는 답을 출력할 때 활용됩니다.
- diff < 0인 경우 내일로를 사는 게 유리한 경우이기 때문에 Yes를 출력합니다.
- diff >= 0인 경우 내일로를 사는 게 이득이 없거나 불리한 경우이기 때문에 No를 출력합니다.
*/
```


### BOJ step by step: Stack 2
#### [boj.kr/3015](../../../Problem%20Solving/boj/Stack/3015-10-17-2022.cpp)
* 아직까지 직관적인 풀이를 떠올리기 힘듦
