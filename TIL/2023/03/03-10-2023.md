# **TIL on March 10th, 2023**
### solved.ac Class 6 Problems
#### [BOJ #14942](../../../Problem%20Solving/boj/solvedac/14942-03-10-2023.cpp): solved on 2nd try (memory: 16788 kB, time: 88 ms, Code length: 1308 B)
* req 배열에는 굴의 길이를 기록. 부모 노드에 대한 희소 테이블(sparse table)을 이용해서 이동 시 필요한 연산을 줄여주고, 최대로 올라갈 수 있는 노드를 찾아 반환하면 됨.

* 구현 주의: `if(p[cur][0] == nxt) continue;`
```cpp
void treeSetup(int cur) {
  for(auto [co, nxt] : adj[cur]) {
    if(p[cur][0] == nxt) continue;
    p[nxt][0] = cur;
    req[nxt] = req[cur] + co;
    treeSetup(nxt);
  }
}
```

* 구현 주의
  - 현 위치에서 ROOT로 올라가기 위한 비용과 2^j번 이동한 부모 노드에서 ROOT로 올라가기 위한 비용의 차이로, 해당 부모 노드로 이동하기 위해 필요한 에너지량인 r을 얻음. 이 r을 현재 남아있는 에너지와 비교하는 로직. 
  - 이를 아래와 같이 구현함.
```cpp
  for(int i = 1; i <= n; i++) {
    int cur = i, e = en[i];
    for(int j = LMX - 1; j >= 0; j--) {
      int pcur = p[cur][j];
      int r = req[cur] - req[pcur];
      if(pcur == -1 || e < r) continue;
      cur = pcur;
      e -= r;
    }
    cout << cur << '\n';
  }
```
<br>

#### [BOJ #3176](../../../Problem%20Solving/boj/Tree/3176-03-09-2023.cpp)
* 유일한 경로가 있는데, 그 경로 상의 가장 긴 '도로'와 가장 짧은 '도로'를 찾는 문제.
* 경로는 LCA를 활용해서 찾아야 함. 정점 u, v와 그 LCA를 w라고 하면 u-w-v가 유일한 경로가 되며, 이 경로 안에서 가장 짧은 도로와 가장 긴 도로를 구해야 함.