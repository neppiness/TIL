# **REST API Design Rulebook**

## Preface
* Representational State Transfer (REST)

## Chapter 1. Introduction
### Web Architecture
* 로이 필딩(Roy Fielding)이 주요 제한사항들에 의해 확장성이 좌우된다는 것을 파악함.
    - 이 제한사항들은 6가지 카테고리로 구분됨.
    - 그리고 이들은 웹의 구조적 스타일로 언급됨.
        1. 클라이언트-서버
        2. 유니폼 인터페이스 
        3. 레이어드 시스템
        4. 캐시
        5. 무상태성(스테이트리스, stateless)
        6. Code-on-demand

### Client-Server
* 웹은 클라이언트-서버에 기반을 둔 시스템임.
    - 어떤 언어나 기술로도 구현할 수 있음.
    - 결국 그에 무관하게 균등한 정보를 주고받을 수 있기 때문.

### Uniform Interface
* 웹의 구성요소들 간 상호작용은 그들의 인터페이스 동일성에 달려있다.
    - 어떤 것이든 이를 깨게되면 웹의 통신 시스템이 무너진다.
* 웹의 구성요소들은 유니폼 인터페이스의 네 가지 제약 조건을 통해 지속적으로 함께 동작한다.
    1. Identification of resources
        + URI를 통해 리소스를 식별
    2. Manipulation of resources through representations
        + identifier와는 별개로 클라이언트에 따라 응답을 다르게 처리
    3. Self-descriptive messages
        + 전달하는 메시지가 그 자체로 자신을 설명해야 한다.
        + 메시지의 메타데이터 역할. HTTP의 헤더가 이와 같은 역할을 수행.
    4. Hypermedia as the engine of apaplication state (HATEOAS)
        + 리소스의 상태에 관련된 리소스들을 포함해야 한다.
        + page에서 활용할 수 있는 링크들이 있는 건 리소스 현 상태의 중요한 요소이다.

### Layered System
* 네트워크 기반 중계자들이 클라이언트와 서버 사이에 투명하게 배치되어야 한다.
* 네트워크 기반 중계자들은 보안을 강화하거나 캐싱을 하고 로드 밸런싱을 수행한다.

### Cache
* 캐싱을 통해 클라이언트가 인지하는 지연시간을 줄이고, 어플리케이션의 가용성과 신뢰성을 향상시킨다.
* 서버가 직접 캐싱할 수도 있고, CDN이나 클라이언트 자신이 캐싱을 수행할 수도 있다.

### Stateless
* 무상태성은 웹 서버가 클라이언트 어플리케이션의 상태를 기억할 필요가 없게 한다.
* 클라이언트 자신이 자신의 상태를 기억하게 하여 서버는 더 많은 클라이언트를 상대할 수 있게 된다.

### Code-On-Demand
* 서버가 무거운 계산을 하지 않고, 일시적으로 클라이언트에 실행 가능한 프로그램을 전달해준다.
    - 요구하는 주체에게 코드를 실행하게 넘겨준다는 의미로 이해됨.

### Web Standards
* 웹의 표준화를 위해 HTTP/1.1을 새로 작성함
    - URI에 대한 작성 방식도 RFC 3986에 공식화함.

### REST
* 2000년에 필딩이 웹의 구조적 스타일에 대해 박사 학위논문을 설명함.
* 위에서 언급한 제약사항들을 웹의 구조적 스타일을 REST라고 함

### REST APIs
* 클라이언트 프로그램은 웹 서비스들과 통신하기 위해 API를 활용
* REST API는 리소스의 집합으로 구성됨.
    - 이런 리소스의 집합을 REST API의 리소스 모델이라 함.

### REST API Design
* REST API를 설계하기 위해선 아래와 같은 질문에 답을 해야함.
    - When should URI path segments be named with plural nouns?
        + 복수형 명사를 언제 쓰는 게 좋을지
    - Which request method should be used to update resource state?
        + 리소스를 업데이트할 때 어떤 메소드를 사용할지: put인가 post인가
    - How do I map non-CRUD operations to my URIs?
        + CRUD를 제외한 특별한 동작에 대해서 어떤 URI를 활용할 것인지
    - What is the appropriate HTTP response status code for a given scenario?
        + 해당 코드가 실행되었을 때 어떤 응답 코드가 적절한지
        + 권한이 없는 경우에 Not found와 Unauthorized 중 어떤 것을 선택할지.
    - How can I manage the versions of a resource’s state representations?
        + 리소스 상태 표현 버전을 어떻게 관리할 것인지
    - How should I structure a hyperlink in JSON?
        + 하이퍼링크를 어떻게 JSON으로 구성할 것인지

### Rules
* 2, 3장에 표준적인 규칙에 대해 설명.
* 합의 없는 자신의 규칙에 대해 4, 5장에 서술했다는 것으로 이해됨.

### WRML
* Web Resources Modeling Language (WRML)
* 이를 통해 좀 더 균일한 구조를 갖는 정보를 교환할 수 있게 하고자 했던 것.
    - JSON은 동일한 구조를 제공하지 않기 때문.
    - 그러나 이를 알고 사용하고 있는 사람이 있을지는...

### Recap
* Architectural constraint
    - 시스템 구성요소의 동작을 제한하고, 우리가 원하는 형태로 균일하게 강제하는 제한 사항.
* Architectural style
    - 로이 필딩이 시스템의 상호 연결된 구성요소의 동작을 제한하는 제약 조건들 집합을 이와 같이 불렀음.

<br>

## Chapter 2. Identifier Design with URIs
### URIs
* REST API 설계자는 클라이언트 개발자를 위해서 URI가 REST API의 리소스 모델을 연관지을 수 있도록 설계해야 함.

#### URI Format
* RFC 3986에서는 URI 문법을 아래와 같이 정의함
    - `URI = scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]`

#### Rule: Forward slash separator (/) must be used to indicate a hierarchical relationship
* 리소스의 계층적 구분을 위해서 정방향 슬래시를 사용

#### Rule: A trailing forward slash (/) should not be included in URIs
* REST API에서는 덧붙이는 정방향 슬래시를 활용하지 않는다.
    - 많은 서버에서 아래 두 URI를 동일하게 처리한다.
        + `http://api.canvas.restapi.org/shapes/`
        + `http://api.canvas.restapi.org/shapes`
    - 그러나, 하나의 URI는 하나의 고유한 리소스에 접근할 수 있도록 해야하기 때문에 이같은 것은 허용하지 않도록 한다.
    - Code 301: Moved Permanently를 넘겨주고 리다이렉트하는 것도 좋은 방법이다.

#### Rule: Hyphens (-) should be used to improve the readability of URIs
#### Rule: Underscores (_) should not be used in URIs
* 하이픈을 활용하여 단어를 구분하자.
* 이에 반해 언더스코어는 사용하지 않는다.

#### Rule: Lowercase letters should be preferred in URI paths
* url에서는 소문자만 사용하도록 한다.
    - http://api.example.restapi.org/my-folder/my-doc
        + 이 URI는 문제 없음.
    - HTTP://API.EXAMPLE.RESTAPI.ORG/my-folder/my-doc
        + 이 URI는 위의 URI처럼 수정해야 함.
    - http://api.example.restapi.org/My-Folder/my-doc
        + 이 URI는 위나 아래 URI와 같지 않아 혼동을 초래할 수 있음.

#### Rule: File extensions should not be included in URIs
* http://api.college.restapi.org/students/3248234/transcripts/2005/fall.json
    - 파일 확장자는 URI에 포함되지 않도록 한다.
* http://api.college.restapi.org/students/3248234/transcripts/2005/fall
    - REST API 클라이언트는 HTTP에서 제공하는 포맷 선택 메커니즘을 활용해야 한다.
    - 이는 Accept 요청 헤더를 통해 이루어지는 듯.

### URI Authority Design
* 이 섹션에서는 인가에 대한 REST API 네이밍 컨벤션에 대해 다룬다.

#### Rule: Consistent subdomain names should be used for your APIs
* 최상층 도메인과 첫 서브도메인 이름은 서비스 오너를 가리키게 설계해야 한다.
* API의 전체 도메인 이름은 첫 서브 도메인 이름으로 api가 들어가야 한다.
    - `http://api.soccer.restapi.org`

#### Rule: Consistent subdomain names should be used for your client developer portal
* API가 개발자 포털을 제공한다면, 첫 서브 도메인 이름으로 developer가 들어가야 한다.

### Resource Modeling
* 정방향 슬래시의 경우, 구분되는 모든 경로가 다 고유의 리소스로 연결되어야 한다.
* 예를 들어: http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet의 경우, 아래와 같은 하위 URI들도 리소스를 제공해야 한다.
    - http://api.soccer.restapi.org/leagues/seattle/teams
    - http://api.soccer.restapi.org/leagues/seattle
    - http://api.soccer.restapi.org/leagues
    - http://api.soccer.restapi.org
* URI 경로를 설계하는 데 앞서, 먼저 REST API의 리소스 모델에 대해 생각해보자.

### Resource Archetypes
* API의 리소스를 모델링할 때에는 기본 리소스의 원형(archetypes)부터 정의한다.
* REST API는 4가지 리소스 원형들을 갖는다.
    - 문서(document), 모음집(collection), 스토어(store), 그리고 컨트롤러(controller)
    - 위와 같은 컨셉으로써 URI를 작성할 수 있다는 의미이다.

#### Document
* 오브젝트 인스턴스나 데이터베이스 기록과 동등한 단일 컨셉이다.
* docroot라는 최상층 도메인에서부터 계층적으로 세부사항으로 들어감.

#### Collection
* 콜렉션 컨셉은 서버가 관리하는 리소스 디렉토리이다.

#### Store
* 저장소(store) 컨셉은 클라이언트가 관리하는 리소스 저장소이다.
* 저장소형 리소스에서는 새로운 URI를 생성하지 않고, 클라이언트가 지정하는 URI를 따른다.

#### Controller 
* 컨트롤러 리소스는 절차적 컨셉을 모델화한다.
* CRUD를 제외한 다른 처리들을 컨트롤러가 돕는다.
* 컨트롤러 이름은 URI 경로의 마지막 구간에서 하위 리소스 계층 없이 쓰인다.
    - `POST /alerts/256723/resend`

### URI Path Design
* 각 구간이 의미 있는 값으로 채워지는 것은 의미를 분명하게 하기 좋다.
* 아래 내용은 의미 있는 URI 경로를 작성하기 위한 규칙들이다.

#### Rule: A singular noun should be used for document names
* 문서 이름으론 단수 명사를 활용한다.

#### Rule: A plural noun should be used for collection names
#### Rule: A plural noun should be used for store names
* 콜렉션의 경우 복수 명사를 활용한다.
    - 예시: `http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players`
* 스토어 이름도 마찬가지다.

#### Rule: A verb or verb phrase should be used for controller names
* 컴퓨터 프로그램의 함수와 같이, 컨트롤러 리소스를 식별하는 URI는 해당 동작을 가리키는 동사가 되어야 한다.

#### Rule: Variable path segments may be substituted with identity-based values
* URI 경로 중에는 변수들이 있다.
    - 변수 경로들은 식별자 기반 값으로 대체되어야 한다.

#### Rule: CRUD function names should not be used in URIs
* CRUD는 모두 요청 메소드를 통해 구분한다.
    - 예: DELETE /users/1234
* 아래는 좋지 않은 사례들을 나타낸다.
    - GET /deleteUser?id=1234
    - GET /deleteUser/1234
    - DELETE /deleteUser/1234
    - POST /users/1234/delete
        + POST를 통해 delete를 수행하고자 함.

### URI Query Design
* URI 쿼리는 RFC 3986에 따라 `?`로 수행한다.
    - http://api.college.restapi.org/students/morgan/send-sms
        + sms를 보내는 컨트롤러 리소스
    - http://api.college.restapi.org/students/morgan/send-sms?text=hello
        + text가 hello인 sms를 보내는 컨트롤러 리소스
* 쿼리 요소는 클라이언트에게 추가적인 상호작용을 가능하도록 하기 때문에, REST API의 클라이언트에게 투명하게 드러낼 수 있다.
* 전체 리소스 URI는 HTTP 캐시와 같은 중계자들에서 드러나지 않도록 해야한다.

#### Rule: The query component of a URI may be used to filter collections or stores
* 콜렉션이나 저장소에서 특정 정보를 필터링하는 데 활용된다.
    - `GET /users`
    - `GET /users?role=admin`

#### Rule: The query component of a URI should be used to paginate collection or store results 
* 콜렉션이나 저장소를 페이지네이션 할 때, 그 페이지를 찾는 데 쿼리 파라미터를 활용할 수 있다.
    - `GET /users?pageSize=25&pageStartIndex=50`
* search라는 컨트롤러 메소드를 따로 둬서 다소 복잡한 처리를 하도록 하라.

<br>

## Chapter 2. Interaction Design with HTTP
###
