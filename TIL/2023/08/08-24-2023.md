**TIL on August 24th, 2023**

## PS Using C++
### BOJ#16964: DFS 스페셜 저지
* 간선을 만들어두고, 마찬가지로 dfs를 수행하듯이 주어진 방문 순서를 따라 순회
* 만약 주변에 노드가 없는 경우 해당 노드에 대한 순회를 멈춤
* 이같은 로직으로 순회가 끝났을 때 큐에 남은 정점이 있다면 잘못된 DFS 순회 순서
* 정점을 다 셀 필요는 없을 듯.
* 1번째 시도에 해결
  - 메모리 16612 kB, 시간 76 ms, 코드 길이 612 B
* 서브 함수를 선언해도 exit(0) 명령을 통해서 메인 프로그램을 종료할 수 있음.

<br>

### BOJ#2942: 퍼거슨과 사과
* 공약수를 모두 구한 후 set에 넣고, 순회하면서 주어진 R과 G를 나누면 되는 문제.
* 최대공약수를 로그 시간 안에 구할 수 있음.
* 이후에는 소수 판정하듯이 확인해야 함.
* sqrt 내로 확인이 가능함
  - 이후에 나눠지면 로그 시간으로 떨어지니 문제는 없어보임.
* 1번째 시도에 풀이함: 2024 kB, 0 ms, 444 B

<br>

### BOJ#1670: 정상회담 2
* 재귀적으로 풀 수 있을 듯함. 이전에 풀었던 부분 문제를 활용해서 해결.
* long long 범위에서 곱셈을 수행해야 하는데 이를 간과함.
* 2번째 시도 AC: 메모리 2284 kB, 시간 100 ms, 코드 길이 498 B

<br>

### BOJ#10422: 괄호
* 정상회담 2 문제와 같이 카탈린 수로 풀 수 있을 듯함
* 범위 설정을 잘못해서 추가 오답을 받음
* 6번째 시도에서 AC. 메모리 2060 kB, 시간 20 ms, 코드 길이 572 B

<br>

### BOJ#2157: 여행
* 첫 도시에서 방문한 도시 수를 1로 설정하고 시작
* 가장 큰 점수를 내보내야 함.
  - 어차피 단방향으로 간선을 설정할 것이기 때문에, 우선순위 큐로 큰 값을 내보내는 식이어도 문제는 없을 것으로 판단됨.
* 첫번째 시도: 시간 초과. 무엇이 문제인지 파악이 안 됨.

<br>

## Typing
* 1: 왼손 새끼, 2: 왼손 약지, 3: 왼손 중지, 4: 왼손 검지, 5: 왼손 검지
* 6: 왼손 검지, 7: 오른손 검지, 8: 오른손 검지, 9: 오른손 중지, 0: 오른손 약지


## Some insight
### [Clean Code is SLOW But REQUIRED? | Prime Reacts](https://youtu.be/fqoi_c8-eOc)
* 실무에서 20개짜리 key-value 매칭을 만들겠다고 map을 두는 건 보통 굉장히 비효율적이다.
  - 차라리 배열을 선언하고 꺼내 쓰는 게 낫다고 함.
* 두 수준의 go-to-definition-jump를 수행해야 한다면 이는 본질적으로 너무 복잡하게 만든 것이라 주장함.
* 유지보수성이랑 클린코드의 연관성이 별로 없다고 얘기함.
* 그냥 코드를 평면적이고 직관적이게(plane, straightforward passion) 작성해라.
  - 이를 통해 성능 문제를 없앨 수 있다.
* Don't abstract until you have a damn good reason to
* SOLID 원칙은 보편적으로 좋다고 함.
* 협업하는 사람들이 하는 대로 따라가라.

> 그렇다면 어떻게 코딩하는 것이 좋을까? 예시가 없기 때문에 다들 문제라고 지적하는 게 어떤 건지 생각해볼 필요가 있다.
> 부스트캠프 진행하면서 너무 많은 걸 외부화한다고 지적을 받았는데, 이에 대해서 좀 더 진지하게 생각해보게 된다.
