인터뷰 준비

### RESTful API?
* REST라는 건 웹 서비스를 개발하기 위한 건축학적 양식
    - Representational State Transfer: 대표적 상태 전송
* 리소스의 식별, 조작을 직관적으로 이해할 수 있는 URI를 통해 수행할 수 있도록 설계된 API

### MSA
* 의미
* 장점

### 객체지향 특징
* 상속
* 다형성
* 캡슐화
* 추상화

### 절차지향 vs. 객체지향
* 절차지향은 일의 순서대로 코드를 작성
* 객체지향은 바텀업 방식으로, 문제를 구현하는 데 필요한 요소들을 정의하고 이들 간의 관계로 프로그래밍

### 스택 vs. 힙
* 스택
    - 함수 호출 시에 지역변수 등이 들어감.
    - 호출된 함수가 프레임 단위로 들어가서 쌓임
    - 메모리 주소가 높은 곳부터 낮은 곳으로 채워짐
* 힙
    - 런타임에 동적으로 할당된 변수를 저장
    - 메모리 주소가 낮으 곳에서 높은 곳으로 채워짐

### 프레임워크와 라이브러리 차이
* 프레임워크는 하나의 프로그램을 만드는 데 필요한 틀을 갖춰줘서 사용자가 이에 맞게 구현하도록 함.
* 라이브러리는 그 안에 있는 요소들 중에 필요한 것들을 사용자가 활용할 수 있도록 하는 것.

### 동기 vs. 비동기
* 하나의 함수가 다른 함수를 호출하는 경우를 생각
    - 동기는 호출된 함수가 반환값을 보내기 전까지 기다림
    - 비동기는 호출된 함수가 반환값을 보내기 전에도 다른 일들을 순차적으로 처리

### MVC 패턴
* Model-view-controller 패턴으로, 컨트롤러와 서비스 로직, 시각화를 담당하는 서비스를 따로 두는 것으로 이해.

### 폭포수 방법론과 애자일 방법론
* 폭포수 방법론은 큰 개발흐름으로 수행
* 애자일 방법론은 폭포수 방법론을 여러 번 반복하며 

### 애자일 방법론 장점
* 현재 상태에서 모든 걸 파악할 수 없다는 한계를 인정
* 디자인 -> 개발 -> 테스트 과정을 반복하며 최종 배포 단계까지 진행
    - 신속성과 유연함이 장점

### 자바 언어의 특징
* 객체지향적.
* C++과 문법이 유사
* 컴파일 언어
* JVM을 활용하여 가상 런타임에서 동작
* 세대별 GC를 수행(Major GC, minor GC)

### JAVA vs. C
* C는 메모리 단위에서 처리해야 하는 게 많음
    - 기본적으로 절차지향적임
    - 메모리를 사용자가 수동으로 관리해야 함.
* 자바는 최대한 사용자가 직관적으로 이해할 수 있는 메소드들을 제공
    - 객체지향적
    - 메모리 관리는 자동으로 이루어짐

### 자바 reflection
* JVM이 클래스 정보를 클래스 로더를 통해 읽어와 JVM 메모리에 저장
    - 저장된 클래스 정보가 실체 클래스의 투영이 되기 때문에 reflection이라 함.

### 자바의 GC
* 객체의 생애주기(Life Cycle) 상, 짧은 기간 동안에만 활용되는 객체가 많음
* 더이상 활용되지 않는 객체가 차지하는 메모리를 자동으로 지워줘 유저의 수고를 덜어줌.

### 다형성, 캡슐화, 상속
* 상속은 

### Overriding과 Overloading의 차이
* Overriding은 인터페이스 등에서 이름이 명시되어 있는 메소드의 구현체에서 가져오는 것.
    - 런타임에서 이루어짐.
    - 동적 다형성이라고 불림.
* Overloading은 동일한 이름으로 다른 인자를 전달받는 메소드를 만드는 것
    - 연산자에도 활용할 수 있음.
    - 컴파일 타임에 결정돼 정적 다형성이라고 불림

### 정렬 알고리즘 시간복잡도
* 선택정렬
    - 최적, 평균, 최악 모두 O(N^2)
* 버블정렬
    - 이미 정렬되어 있는 경우 O(N)
    - 평균, 최악은 O(N^2)
* 힙정렬
    - 최적, 평균, 최악 모두 O(NlgN)
* 병합정렬
    - 최적, 평균, 최악 모두 O(NlgN)
* 퀵소트
    - 최적, 평균은 O(NlgN)
    - 최악은 O(N^2)

### MVC의 장점?

### 우선순위 큐 직접 구현
* 배열을 선언하여 구현
    - 현재 배열 크기를 가리킬 cursor를 하나 둠.
    - 삽입이 발생하면 가장 아래에 두고 부모를 확인하면서 교환
    - 삭제가 발생하면 가장 아래에 있던 원소를 위로 올린 뒤 자녀들을 확인하면서 교환
