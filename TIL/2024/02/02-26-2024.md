**TIL on February 26th, 2024**

# Problem Solving
## BOJ#9471: 피사노 주기
* 1 0이 나왔을 때 0은 주기의 끝.
    - 이후는 1 0 1 1로 이어짐
* k(M)의 총합이 50만 이하이므로 O(N)으로 끝내면 됨
* 1번째 제출 AC
    - 메모리: 2020 kB, 시간: 4 ms, 코드 길이: 404 B

 <br>

# 면접 준비
## Blockchain Interworking
* 사이드 체인을 게임에서 어떻게 활용하는 걸까?

## 세마포어 vs. 뮤텍스락
* 세마포어
    - 스레드 간에 공유되는 변수
    - 자원의 개수를 의미하기도 함.
        + 해당 값이 줄어들면 가용한 자원이 줄어드는 것.
        + 해당 값이 늘어나면 가용한 자원이 증가하는 것.
* 뮤텍스락
    - 자원에 대한 접근을 동기화하기 위해 사용하는 상호 배제 기술
    - Locking 메커니즘으로 락을 건 스레드가 자원을 점유하고, 임계영역을 나갈 때 락을 해제함.
    - 이진 세마포어를 사용
    - 자원을 다 활용한 스레드가 Locking을 해제하는 코드를 동작시키며 큐 상에 있는 대기 중인 프로세스를 가져옴(wakeup).

## 컴파일러 이론
* 토크나이저
    - 구문을 토큰화
* 렉서
    - 쪼개진 토큰들의 의미를 분석
* 렉시컬 분석
    - 토크나이저를 거쳐 의미 있는 단위로 쪼개지고, 렉서를 거쳐 그 결과의 의미를 분석하는 과정을 렉시컬 분석이라 함.
* 파서
    - 렉시컬 분석된 데이터를 구조적으로 나타냄
    - AST를 구축하게 됨.

## 프로세스 메모리 모델
* TEXT(code)
    - 실행할 프로그램의 코드가 저장됨
* GVAR(data)
    - 전역변수와 정적변수가 저장됨
* HEAP
    - 동적 데이터 영역
    - 런타임에 크기가 결정됨
* STACK
    - 지역변수, 매개변수, 리턴값 반환 주소 등을 임시로 저장

## 프로세스와 스레드
* 프로세스
    - OS에서 메모리 영역을 할당받아 실행되는 독립적 프로그램 인스턴스
    - 하나의 프로세스는 별도의 메모리 공간을 할당 받아 사용
* 프로세스 상태
    - 프로세스가 CPU를 서로 차지하기 위해서는 상태 정보가 필요
* 스케쥴링 전략
    - OS가 수행
    - FCFS: 순서대로 먼저 큐에 들어온 것을 끝까지 실행하는 방식
    - Round-Robin: 큐에 있는 프로세스를 정해둔 단위 시간씩 처리해줌. 완료되면 큐에서 제거, 미완료 시 큐에 다시 넣음
    - Priority 스케쥴링: 우선순위 큐에 넣고 나온 프로세스를 먼저 처리
* 스레드
    - 스택을 할당 받아 실행되는 독립적 단위
    - 멀티스레딩 시 자신만의 스택을 가지되, TEXT, GVAR, HEAP 영역은 공유
    - 스레드를 새로 만드는 건 자원 소모가 많으므로, 생성한 뒤 풀에 넣어 두고 필요에 따라 꺼내 씀

## SaaS
* 클라우드 기반의 소프트웨어 제공 모델
* 클라우드 제공업체가 클라우드 어플리케이션 소프트웨어를 개발 및 유지 관리하고, 자동 소프트웨어 업데이트를 제공
* 인터넷을 통해 Pay-as-you-Go 방식으로 고객에게 소프트웨어를 제공
* 클라우드 제공업체가 미들웨어, 어플리케이션 소프트웨어, 보안 등 모든 하드웨어 및 전통적 소프트웨어를 관리

## 정렬 알고리즈
### 선택 정렬
* 전체 배열 범위에서 가장 큰 요소를 찾아 가장 마지막에 배치
* 이후 배열 범위를 하나 줄이고 그 안에서 가장 큰 요소를 찾아 가장 마지막에서 한 자리 앞에 배치하는 식으로 접근

### 버블 정렬
* 현재 요소와 다음 요소의 크기를 비교하고, 현재 요소가 더 큰 경우 두 값 위치를 바꿈
* 이와 같은 과정을 반복하면서 요소 간 위치의 교환이 일어나지 않는 때까지 반복함.
* 최선의 시간 복잡도는 O(N)이 됨.

### 삽입 정렬
* 한 요소씩 선택하여 이전에 정렬을 수행한 배열 중에 어디에 위치할지 찾아가는 방식

### 병합 정렬
* 정렬된 두 배열을 크기 순으로 넣으며 두 배열을 합친 길이만큼의 정렬된 배열을 얻어가는 방식

### 퀵 소트
* pivot을 두고, 커서 l은 피벗보다 작은 값, 커서 r은 피벗보다 큰 값이 위치하게 하는 것
    - 커서 l은 오른편으로, 커서 r은 왼편으로 이동하면서 값을 확인
    - 커서 l에서 pivot 값보다 큰 값을 찾고, 커서 r에서 pivot 값보다 작은 값을 찾으면 교환을 수행
    - 이와 같은 방식으로 커서를 이동시키다가 l과 r의 위치가 바뀌면 r의 값과 pivot의 값을 교환함.
    - 왜냐하면, pivot 이후부터 l과 r의 위치가 바뀌는 순간 직전의 l 위치까지의 값들은 모두 pivot 보다 작기 때문.
* 최악의 시간 복잡도는 O(N^2)이 됨.
    - pivot 값이 중간에 위치하는 값이 아니라 배열 중 가장 큰 값이나 가장 작은 값에 쏠리는 경우
    - 오름차순이나 내림차순으로 정렬된 배열의 경우 최악의 시간복잡도로 동작함
