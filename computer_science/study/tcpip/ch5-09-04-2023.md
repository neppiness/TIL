# **Chapter 5. NIO**

* 이 장에선 "New I/O" 패키지에 대해 다룬다.
* 여기엔 두 가지 중요한 부분이 있다.
  - `java.nio.channels` 패키지: `Selector`와 `Channel` 추상화를 도입
  - `java.nio` 패키지: `Buffer` 추상화 도입
* NIO가 풀기 위한 문제에 대해서 설명한다.
  - 이를 사용하지 않고 고성능 서버를 만들고자 하면 겪는 문제


## 5.1 Why do we need this?
* 자바소켓은 작은 스케일의 시스템에선 잘 동작한다.
  - 그러나, 수천의 클라이언트를 동시에 감당해야 하면 문제가 발생한다.
* 4장에서 다수의 연결을 처리하기 위한 방법들에 대해 언급했다.
  - 스레드와 클라이언트의 일대일 대응 방식 및 스레드 풀 방식
  - 양쪽 다 문제가 있다.
* 클라이언트끼리 메시지를 주고 받는 서비스의 경우, 스레드 풀의 크기를 늘려도 소용이 없다.
  - 스레드 풀 크기에 따라 연결할 수 있는 클라이언트 수가 달라지는 건 맞음
  - 그러나, 스레드 풀 크기를 키워도 성능이 나아지진 않음.
  - 단순히 연결을 유지하는 데만 스레드가 사용되기 때문이라고 이해됨.
* 그러나 위의 문제들이 전부가 아니다.
  - 스레드의 확장성을 고려하면 문제가 더 민감해진다.
* 개발자는 스레드를 컨트롤 할 수 없다.
  - 단지 스레드에 우선순위를 부여할 뿐이며, 이마저도 참고정도만 될 뿐이다.
  - 만약 어떤 연결을 우선 시 해야할 경우엔 스레드를 사용할 수 없다.
* 여기에 동시성 문제가 발생하면 스레드로는 처리하기 굉장히 어려워진다.
  - 동기화 문제가 발생하고, 다른 하나가 덮어쓰려는 데이터를 또 쓰게될 수도 있다.
  - 스레디드 서버(threaded server)에서 공유 상태에 대한 동기화된 접근은 정확성과 성능 측면에서 굉장히 고려되기 어렵다.
* 그래서 싱글 스레드 서버를 사용하게 된다.
  - nonblocking I/O를 사용하여 처리함
  - 서버 소켓 인스턴스의 경우, accept() 메소드를 호출했을 때, 연결 대기 중인 클라이언트가 있다면 즉시 반환하고, 아닌 경우 시간이 초과되거나 연결이 들어오기 전까지 블락하게 된다.
  > 이런 경우 연결 대기 중인 클라이언트를 게속해서 확인해야 하기 때문에 많은 리소스가 들어가고, 그에 따라 'busy waiting'이라 하는 것으로 이해됨.
* 그러므로, 이를 한꺼번에 수행할 수 있는 방식이 필요하다.
  - 이는 NIO의 선택자(Selector)와 채널(Channel)의 역할이다.
  - 채널은 뽑을 수 있는(pollable) I/O 대상(소켓 등)을 나타낸다.
  - 채널은 Selector 클래스의 인스턴스를 등록할 수 있다.
  - select() 메소드는 선택자를 통해 필요로 하는 채널을 얻을 수 있게 한다.
* NIO의 주된 기능 중 하나는 버퍼(Buffer) 클래스다.
  - 버퍼는 스트림보다 좀 더 예측 가능한 I/O가 되어준다.
  - 스레드를 사용하면 스트림의 리소스 낭비가 구현에 묻혀서 제어하거나 예측할 수 없게 된다.
  - 이는 구현은 쉽게 만들지만 성능을 제어할 수 없게 만든다. 
  - 여기에 자바 소켓을 쓰면 스트림 밖에 쓸 수가 없다.
* 버퍼는 정해진 크기의 데이터를 받으며, 이 배열에 대한 포인터를 표현한다.
  - 이를 통해서 두 가지 주된 이점을 얻을 수 있다.
    1. 오버헤드에 관한 것들을 제어할 수 있게 된다. 이를 통해 성능 향상을 꾀할 수 있다.
    2. Buffer의 map 연산을 통해 버퍼의 기반 플랫폼의 연산을 직접 수행하도록 할 수 있다.

