# **TIL on March 17th, 2023**
### Pick and solve
#### [boj.kr/2211](../../../Problem%20Solving/boj/random%20defense/2211-03-17-2023.cpp): solved on 2nd try (memory: 6700 kB, time: 72 ms, Code length: 1016 B)
* 1번째 WA. MST로 풀었음.
* 다익스트라 간선 복원 문제. ST 전까지만 cur과 prv[cur]을 간선으로 등록하면 되는 문제.
  - `pq.push({dco, nxt});` 로직을 중간에 한 번 잘못 썼었음. 주의바람.

### Class 5 Problems | solved.ac
#### [boj.kr/14939](../../../Problem%20Solving/boj/solvedac/14939-03-07-2023.cpp): solved on 2nd try (memory: 2020 kB, time: 0 ms, Code length: 1609 B)
* (0, 0)을 누른다/누르지 않는다부터 시작해서 좌측과 상단을 확인하며 풀이하자.
* 좌측은 별로 상관 없는 것처럼 보이긴 함.
  - 좌측의 경우 바로 아래에서도 제어가 가능함. 한 번 제어가 안 되기 시작하면 따져야 하는 건 상단에 있는 전구라고 생각해도 될 듯. 다만, 이 상단에 있는 전구가 oob인 경우, 무관하게 여길 수 있을 듯. 그건 좌측도, 우측도, 하단도 마찬가지.
  - `const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1};`에 대해서 생각을 하되, 상단에 위치한 전구를 끌 수 있는가로 판단하자.
* 최상단 1줄에 대해서 총 경우의 수 2^10에 대해 전구를 눌러보는 경우를 생각하고, 이후 아랫줄들은 최상단 상태를 따라 해당 전구를 끄는 방식으로 진행하는 게 괜찮은 방법일 듯함.
  - 구현은 next_permutation으로 수행.

### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1F 트라이
#### [boj.kr/5446](../../../Problem%20Solving/boj/Trie/5446-03-12-2023.cpp)
* 풀이 정립 후 재시도 바람.