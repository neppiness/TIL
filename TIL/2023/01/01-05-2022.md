# **TIL on January 5th 2023**
### Problem Solving Using C++
#### BOJ step by step: stack 2
##### [boj.kr/17299](../../../Problem%20Solving/boj/Stack/17299-01-05-2023.cpp): solved on 1st try (memory: 13740 kB, time: 224 ms, Code length: 641 B)
- Ai의 등장 횟수를 나타내는 F(Ai) 배열은 크기 1'000'001로 선언하여, 1이상 1,000,000 이하 범위 Ai의 값들을 받아두자. 이로써 F(Ai)를 확인해야 할 때, O(1)로 인덱싱해 값을 확인할 수 있다.
- 오등큰수 배열은 `ans[MX]`로 선언하고, -1로 초기화하자.
- 주어진 배열 A의 가장 큰 인덱스부터 차차 내려오는 방식으로 i를 이동한다. 이때, i번째 원소를 보고 있다고 하자. 스택이 비지 않는 동안에 스택의 top 값을 확인하면서 pop한다.
  * 중간에 top에 자기 보다 빈도가 큰 애가 나오면 `ans[i]`를 해당 값으로 채운 뒤 자신을 스택에 넣는다. 이후 다음 인덱스로 넘어간다.
  * 스택이 비었다면 자기 자신을 스택에 넣고 다음 인덱스로 넘어간다.
- 스택 문제들은 아직 직관적으로 와닿지 않아 여전히 까다롭다. 자연스럽게 수학적 모델을 떠올리는 방법을 훈련하자.
- 이것으로 백준 총 500문제를 풀었다.

#### BOJ step by step: Dynamic programming
##### [boj.kr/11066](../../../Problem%20Solving/boj/Dynamic%20programming/11066-12-28-2022.cpp): solved on 1st try (memory: 3992 kB, time: 164 ms, Code length: 726 B)
* 이 문제는 최적 부분 구조가 성립한다. 지금까지 밟아온 루트가 최종적으로 모든 항의 합에 이르기까지 도달하기 위한 최소 코스트와 아무런 관계가 없기 때문이다.

* 1월 4일에 고민했던 내용과 다른 풀이를 생각해보자.
  - 파일 합치기는 파스칼의 삼각형이나 정수 삼각형 문제와 닮은 듯함.
  - 정수 삼각형 역시 경로를 내려오면서 갱신함.
  - `long long solve(int st, int en)` 함수를 다음과 같이 정의하자: st부터 en까지 배열을 합치는 최소 비용을 반환하는 함수
    * st와 en으로 캐시 배열을 만들 수 있다: `cache[502][502] // cache[st][en] = (min. value)`
    * 기저 사례: `st == en`이면 `0`을 반환. 합칠 때 발생하는 비용을 부분 합을 통해 계산하고 반환하는 방식으로 구현함.
    * 한 조각씩 떼어내며 캐시에 값을 갱신하는 방식
  - 부분 문제를 잘못 떼어냈던 사실 기억하기. 엄밀하게 할 필요가 있음.