# **TIL on January 28th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1C 플로이드 알고리즘
#### [boj.kr/23286](../../../Problem%20Solving/boj/Floyd%20algorithm/23286-01-29-2023.cpp): solved on 1st try (memory: 2376 kB, time: 36 ms, Code length: 787 B)
* 플로이드로 싹 경유하면서 각 경로 당 높이 최솟값을 저장하자.
* 비용은 높이 최댓값인 1,000,000 이하로 제어되기 때문에, int로 저장 가능.

* 플로이드 알고리즘에 활용된 식은 아래와 같음

```cpp
for(int k = 1; k <= n; k++)
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			h[i][j] = min(h[i][j], max(h[i][k], h[k][j]));
```

* 여기서 `h[i][i] = 0;`는 있든 없든 영향 없음. 단방향 그래프가 주어져 돌아올 수 없는 경우도 있을 수 있고, 계산을 위해 0으로 설정해야 하는 경우도 있으니 어느 쪽이 옳다고 판단해야 할지는 잘 모르겠음.

* PR용 주석은 아래와 같다.
```cpp
/*
현재까지 계산된 i에서 j로 가는 길목의 허들 높이를 h[i][j]라 하자.

플로이드 알고리즘을 통해 N개 노드를 경유하면서
h[i][j]를 아래 두 값 중 작은 값으로 갱신한다(31번째 줄).
  1. h[i][j]의 현재 값
  2. i -> k -> j 경로로 갈 때의 길목 상 최대 허들 높이
    - h[i][k], h[k][j] 중 큰 값
*/
```


### Silver 3 to Gold 3 Random Defense
#### [boj.kr/19948](../../../Problem%20Solving/boj/random%20defense/19948-01-29-2023.cpp): solved on 5th try (memory: 2156 kB, time: 0 ms, Code length: 800 B)
* cin은 공백문자 입력을 무시한다. 따라서 getline 뒤에 나오는 cin은 정상동작한다.
* 2번째 시도까지 틀림. 일단 한 번은 스페이스 두 번 나온 경우에 정답 벡터로 스페이스가 빨려들어갔기 때문이라 하지만, 100%에서 한 번 틀림.
* 시의 내용과 시의 제목이 Enter키로 구분된다고 함: 이 조건은 의미 없는 게, 입력으로 *첫 줄*에 시의 내용이 주어진다고 했기 때문.
* 문제 조건 잘 읽자. 제목도 타이핑 해야함. 따라서 제목을 기록할 문자는 사용 가능 횟수를 2만큼 차감해야 함.