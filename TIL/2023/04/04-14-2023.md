# **TIL on April 14th, 2023**
### Random Defense
#### [BOJ #1850](../../../Problem%20Solving/boj/random%20defense/1850-04-14-2023.cpp)
* 일단 수학적으로, 2^N - 1과 2^M - 1의 최대공약수를 생각해보자. 그리고 2^N - 1이 더 큰 수라 하자.
  - 2^N - 1 = gn, 2^M - 1 = gm이라 하자. 그러면, 2^N - 2^M = g(n - m)이며, n과 m은 서로소이다.
  - 2^M으로 묶으면 2^M(2^(N-M) - 1)이 된다. 즉, n과 m은 2^(N-M)과 1일 수밖에 없다.
  - 하지만, 예외가 있는데, N과 M이 같은 경우에는 최대공약수가 자신이 된다. 이것만 유의해서 구현하면 된다.
* 풀이가 이상했음. 어디에도 이진수라는 말이 없는데 이진수로 생각하고 풀었음. 수정 필요.
* 재귀적으로 풀어들어가야 할 듯. 예를 들면 N = 3000, M = 1일 경우 같은 걸 생각해보자.

#### [BOJ #17140](../../../Problem%20Solving/boj/random%20defense/17140-04-14-2023.cpp)
* 100X100 배열에 대해서 100번의 정렬을 수행하면 되기 때문에, 시간 복잡도는 O(10^6)으로 100만 수준임. 충분히 시간 내로 풀 수 있음.
* 디버깅 필요. 배열 관련 문제.

### Pick and solve
#### [BOJ #2167](../../../Problem%20Solving/boj/random%20defense/2167-04-14-2023.cpp): solved on 1st try (memory: 2732 kB, time: 12 ms, Code length: 629 B)
* 단순 구간합 응용 문제.