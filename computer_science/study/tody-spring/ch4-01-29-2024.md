**토비의 스프링 3.1**

# 4장: 예외
## 4.1 사라진 SQLException
* JdbcTemplate으로 바뀐 뒤 SQLException을 던진다고 메소드 시그니쳐에 표시하지 않게 되었음.

```java
public void deleteAll() {
    this.jdbcTemplate.update("delete from users");
}
```

* SQLException은 JDBC API의 메소드들이 던지는 것이므로 있어야 함.
    - 그래서 이 SQLException은 어디로 갔는가?

### 4.1.1 초난감 예외처리
#### 예외 블랙홀
* 예외를 잡고 아무것도 하지 않는 코드.

```java
try {
    // statements
} catch (SQLException e) {
}
```

* 또는 화면에 출력하는 식으로 처리하는 경우
    - `System.out.println(e);` or `e.printStackTrace();`
* 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 예외 관련 정보를 통보해야 함.
    - 예외를 잡아 따로 취할 조치가 없다면 잡지 말아야 함.

#### 무의미하고 무책임한 throws
* 단순히 throws Exception으로 모든 예외를 포괄하는 애매한 시그니쳐는 좋지 않다.

### 4.1.2 예외의 종류와 특징
* 자바에서 throws를 통해 발생시킬 수 있는 예외는 크게 세 가지
    1. Error
        + java.lang.Error 클래스의 서브클래스들
        + 자바 VM이 발생시키는 것.
        + OutOfMemoryError, ThreadDeath 에러는 catch로 잡아도 조치를 취할 수가 없음.
    2. Exception과 체크 예외
        + java.lang.Exception 클래스와 그 서브클래스
        + 개발자들이 만든 어플리케이션 코드의 작업 중 예외상황이 발생했을 때 사용
    3. RuntimeException과 언체크/런타임 예외
        + 런타임 예외는 catch로 잡거나 throws로 명시하지 않아도 된다.
        + 런타임 예외는 프로그램의 오류가 있을 때 발생하도록 의도된 것.
* NOTE
    - 체크 예외와 체크되지 않은 예외
        + 체크 예외: Exception 클래스의 서브클래스이면서 RuntimeException을 상속하지 않은 것.
        + 체크되지 않은 예외: RuntimeException을 상속한 클래스
    - 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 함.
        + 사용할 메소드가 체크 예외를 던진다면 catch 문으로 잡든지, throws를 정의해서 메소드 밖으로 던져야 함.

### 4.1.3 예외처리 방법
#### 예외 복구
* 예외상황을 파악하고 문제를 해결하여 정상 상태로 돌려놓는 것.
    - 재시도를 하는 경우가 간단한 복구 코드

```java
int maxRetry = NO_OF_MAX_RETRY;
while (maxRetry-- > 0) {
    try {
        // 예외가 발생할 가능성이 있는 시도
        return;
    } catch (SomeException e) {
        // 로그 출력, 정해진 시간만큼 대기
    } finally {
        // 리소스 반납. 정리 작업.
    }
}
throw new RetryFailedException();
```

#### 예외처리 회피
* throw로 예외를 던져버리고, 이를 호출한 측에서 처리하도록 만드는 것.

#### 예외 전환
* 어떤 상황에 예외가 발생했냐에 따라서, 예외를 바꿔서 던짐으로 좀 더 명확한 정보를 주고자 의도한 것.

```java
public void add(User user) throws DuplicatedUserIdException, SQLException {
    try {
        // JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는
        // 그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
    } catch (SQLException e) {
        // ErrorCode가 MySQL의 "Duplicate Entry(1062)"인 경우 예외 전환
        if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) {
            throw DuplicatedUserIdException();
        } else {
            throw e;
        }
    }
}
```

### 4.1.4 예외처리 전략
#### 런타임 예외의 보편화
* 체크 예외는 예외처리를 강요하기 때문에, 최근에는 반드시 복구 가능한 예외가 아니면 언체크 예외로 두는 경향이 있다고 함.

#### 어플리케이션 예외
* 시스템 또는 외부의 예외상황이 원인이 아니라 어플리케이션 자체의 로직에 의해 의도적으로 발생시키는 예외
* 출금을 시도했을 때 잔고를 확인한다고 하자
    - 정상 출금이 되었을 때와 잔고가 부족한 경우를 반환값으로 결정한다고 하면, if문으로 이를 걸러야 함.
        + 만약 사전에 협의가 잘 되지 않은 상태라면 혼동의 여지가 있음.
    - 만약 정상 흐름은 그대로 두고, 예외가 발생할 때 비즈니스적인 의미를 띤 예외를 던지도록 하면 깔끔해질 것.
        + 이때 사용하는 예외는 의도적으로 체크 예외로 만들어서 반드시 예외상황에 대한 로직을 구현하도록 강제할 것.

### 4.1.5 SQLException은 어떻게 됐나?
* SQLException은 코드 레벨에서 복구할 방법이 없다.
    - DAO 밖에서 SQLException을 다룰 수 있는 가능성은 거의 없다.
    - 따라서, 이에 대한 예외를 바ㅓㅇ치하지 않고 언체크/런타임 예외로 전환해줘야 한다.
