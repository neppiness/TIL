# **TIL on May 11th, 2023**

### [MVC 패턴 관련 지식 공부](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1)


### Random Defense Using Java
#### [BOJ #15658](../../../Problem%20Solving/String/15658-05-11-2023.java): solved on 1st try (memory: 16208 kB, time: 144 ms, Code length: 1461 B)
* 완전 탐색 문제. 연산자 횟수를 기록하고 이에 대한 백트래킹을 재귀적으로 구현함.


#### [BOJ #13023](../../../Problem%20Solving/boj/random%20defense/13023-05-11-2023.java)
* 최장거리 구하는 식으로 다익스트라 풀이가 가능하지 않을까?
  - 이 아이디어는 반복되는 경로를 피할 수가 없어서 안 됨.
  - DFS 스패닝 트리를 만드는 방법을 고려했었는데, 여기서 약간의 조정을 하면 풀이를 고안할 수 있지 않을까?

* BFS로 최단 거리를 구하듯이 접근하고, 혹시 이미 방문한 노드 중에 연결이 확인되는 데가 있다면 그 중 최댓값을 갖는 방식으로 구현해보자.
  - 그러나, 만약 갱신이 필요한 노드를 찾는다고 하면 그로부터 갱신되는 값들을 이전 값에 반영할 방법이 마땅찮은 듯.

* DFS 트리를 구현하고, 


#### [BOJ #2812](../../../Problem%20Solving/boj/random%20defense/2812-05-11-2023.cpp): solved on 1st try (memory: 2912 kB, time: 8 ms, Code length: 527 B)
* 9부터 0까지 문자를 찾으면서 스킵한 문자 수를 카운트함. 스킵이 이루어지지 않아서 마지막에 현재 스킵할 수 있는 문자수가 남았다고 하자. 이 스킵 가능한 문자수를 k라고 할 때, 문자열은 no.size() - k보다 작은 데까지 출력해야 한다.
  - 4 2 / 1000을 입력해보고 정상작동 되는지 확인하면 됨.
* 1, 2번 제출 WA. 위 부분이 반영되지 않아 버그 발생.


#### [BOJ #1783](../../../Problem%20Solving/boj/random%20defense/1783-05-11-2023.java)
* 4가지 움직임을 모두 활용해야 한다는 조건은 어떻게 만족시킬 수 있을까
  - 비트마스킹을 활용할 수 있을 듯함.
* 이건 DP문제가 아님. N과 M이 20억보다 이하의 자연수이므로, 다른 풀이를 생각해봐야 함.
* 간단하게, 4번 이상 움직이게 되면 오른쪽으로 6칸은 반드시 이동해야 함.
  - M의 크기에 정비례한 답이 나올 것.
  - N은 이동 제약으로 작용함. N이 1이라면 이동이 불가능. N이 2이고, 4회 이하로 움직인다면 강제 조항이 발동하지 않으니, 오른쪽으로 2칸씩 이동하면서 위로 한 칸, 아래로 한 칸 이동할 수 있음. 이는 세 번까지만 가능함.
  - N이 3이라면 4회 이상 이동도 무난해짐. 그때는 최대 M-2칸을 방문할 수 있음.
* 1번째 제출 WA. 세부 케이스 확인하기.


#### [BOJ #6581](../../../Problem%20Solving/boj/String/6581-05-08-2023.cpp)
* 오답 이유를 잘 모르겠음.