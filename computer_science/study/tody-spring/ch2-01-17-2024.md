**토비의 스프링 3.1**

# 2장: 테스트
* 스프링은 객체지향과 테스트에 가치를 둔다.
* 테스트는 작성한 코드를 확실할 수 있게 해준다.

## 2.1 UserDaoTest 다시 보기
### 2.1.1 테스트의 유용성
* 테스트를 통해 결과가 원하는 대로 나오는지 확인함.
* 이를 통해 디버깅을 수행 가능.
    - 모든 과정을 마친 후 확인된 결함을 전부 제거했다고 확신할 수 있다.

### 2.1.2 UserDaoTest의 특징
* 책에 나와있는 테스트 코드의 내용을 정리하면 아래와 같은 작업을 수행하고 있다.
    - 자바에서 가장 손쉽게 실행 가능한 main() 메소드를 이용한다.
    - 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
    - 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
    - 테스트의 결과를 콘솔에 출력해준다.
    - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.
* main() 메소드를 이용해 테스트 수행을 쉽게했다는 점과 테스트 대상인 UserDao를 직접 호출해서 사용한다는 점에 주목하자.

#### 웹을 통한 DAO 테스트 방법의 문제점
* 보통은 DAO를 테스트하기 위해선 제반 사항이 다 갖춰져 있어야 함.
    - 호출을 수행해보고 DAO 작업 과정을 거쳐, 다른 API로 호출해보며 결괏값을 확인해보는 식이라고 하자.
* 이 경우, DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
    - 심지어 문제가 발생하더라도 어떤 게 오작동했는지 파악하기가 굉장히 어렵다.

#### 작은 단위의 테스트
* 테스트하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
* 테스트는 가능하면 작은 단위로 쪼개야 한다.
    - 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
* 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트라고 한다.
* 단위는 작을수록 좋다.
    - 단위를 넘어서는 코드들과 무관하게 테스트가 동작할 수 있으면 좋다.
* DB가 초기화된 상태에서 테스트를 통해 DB가 온전히 조작된다면 단위테스트라고 할 수 있는 모양.
* 때로는 API의 통합적인 테스트를 수행해야 하는 경우도 있다.
* 개발자가 코드를 작성하는 시기에 테스트도 같이 수행하는 편이 맥락을 잊어버리지 않고, 세심하게 테스트하기 좋다.

#### 자동수행 테스트 코드
* 테스트를 위한 클래스를 따로 작성함.
* 테스트는 자동으로 수행할 수 있어야 함.
    - 수동으로 일일이 어떤 폼에 어떤 값을 작성하고 이를 서버에 전달하는 과정을 확인하는 등, 번거로운 작업을 해야한다면 굉장히 어려운 일이 됨.

### 2.1.3 UserDaoTest의 문제점
* 수동 확인 작업의 번거로움
    - 정상적인 결과가 출력된 것인지 눈으로 일일이 확인해야 한다.
* 실행 작업의 번거로움
    - 이와 같은 테스트 방식을 활용하면 main() 메소드를 존재하는 DAO 개수만큼 동작시켜야 함.

<br>

## 2.2 UserDaoTest 개선
### 2.2.1 테스트 검증의 자동화
* 테스트 검증하는 로직을 조금 수정함
    - 메소드가 오류를 내지 않고 동작하는 것도 중요하지만, 이를 통해 버그를 잡아낼 수는 없음.
    - 따라서 기대하는 값과 실제 얻은 값이 같은지 확인하는 과정이 필요함.
* 자동화 과정이 없으면 검증이 불안해짐.
* 검증이 제대로 되지 않으면 작업을 마치고도 불안할 수밖에 없음.

### 2.2.2 테스트의 효율적인 수행과 결과 관리 
* JUnit을 통한 자바 단위테스트 작성

#### JUnit 테스트로 전환
* 프레임워크가 흐름을 제어하기 때문에 main() 메소드 없이도 동작시킬 수 있는 테스트를 작성할 수 있음.

#### 테스트 메소드 전환
* main() 메소드를 사용하지 않고, `@Test` 어노테이션과 `public` 접근 제어자가 필요
    - 그러나 JUnit5에서는 더이상 `public` 접근 제어자가 필요 없다.


```java
// import statement

public class UserDaoTest {

    @Test
    public void addAndGetTest() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        // and so on...
    }

}
```

#### 검증 코드 전환
* `assertThat(user2.getName(), is(user.getName()));`
    - 이와 같은 방식으로 검증이 가능하다.
* 최근에는 assertj.core.api의 Assertions 상 API를 통해서 아래와 같이 작성

```java
int a = 5;
Assertions.assertThat(a).isEqualTo(5);
```

#### JUnit 테스트 실행
* 예전에는 JUnit 프레임워크를 시작시켜줘야 했던 것으로 보임.
    - 현재는 간단하게 run test 조작 하나만으로 테스트가 가능.

<br>

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
### 2.3.1 JUnit 테스트 실행 방법
#### IDE
* 이클립스 쓰던 시절 얘기
    - run as 항목 중에 JUnit Test를 선택하면 테스트가 자동으로 실행된다고 함.
* JUnit5만 가지고 테스트를 작성한다고 하면, 이에 대한 동작은 어떻게 실행시켜볼 수 있을까?
    - 사실은 run으로 간단하게 테스트를 돌려보는 것도 IntelliJ가 제공하는 기능인 것 아닐까
    - 우리가 실제로 테스트를 실행하려면 더 복잡한 로직으로 이를 호출해야 할지도 모르겠다.

### 2.3.2 테스트 결과의 일관성
* 현재 코드는 코드에 변경사항이 없을 때에도 DB 상태에 따라 실패할 수도, 성공할 수도 있는 코드다.
* 좋은 테스트는 코드에 변경사항이 없다면 항상 동일한 결과를 내야 한다.

#### deleteAll()과 getCount() 추가
* 적당히 활용할 새로운 기능을 추가함.

#### deleteAll()과 getCount()의 테스트
* deleteAll()과 getCount()의 정상적 동작을 위한 세부 고려사항에 대해 서술

#### 동일한 결과를 보장하는 테스트
* 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다.

### 2.3.3 포괄적인 테스트
* 테스트의 동작 순서는 보장되지 않는다.

#### get() 예외조건에 대한 테스트
* id 값에 해당하는 사용자 정보가 없는 경우
    - EmptyResultDataAccessException을 사용할 것이라고 함.
    - 이렇게 예외가 터지는 경우는 예전에 `@Test(expected=EmptyResultDataAccessException.class)`로 테스트 어노테이션에 작성을 했음.
    - 지금은 `Assertions.assertThatThrownBy();` 메소드를 통해서 주어진 람다 함수를 호출했을 때 예외가 발생하나 검토함.
* "예외 테스트를 먼저 만들라."
    - 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.
    - 이런 예외 상황이 발생했을 때 어떻게 처리되는지 확인하는 테스트를 작성한다면 꼼꼼한 개발이 가능하다.

### 2.3.4. 테스트 주도 개발
* 조건, 행위, 결과로 테스트가 구분됨
    - given, when, then과 같은 것.

#### 테스트 주도 개발
* 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 할 수 있게 테스트 코드를 먼저 작성.
    - 테스트를 성공하는 코드를 작성하는 방식의 개발 방법.
* 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 작성하지 않는다는 게 기본 원칙이라 함.
* 이를 통해 짧은 주기로 빠르게 피드백을 받을 수 있는 개발이 가능하다고 함.
    - 다음 토이 프로젝트는 이같은 방식으로 작성하는 것도 생각해봐야 할 듯.

### 2.3.5 테스트 코드 개선
#### @Before
* 중복된 처리를 @Before 코드를 통해 수행
    - 현재는 `@BeforeEach`, `@BeforeAll`로 대체된 듯함.
* 테스트 클래스에서 @Test 어노테이션이 붙은 테스트 메소드를 찾고, 테스트 클래스 오브젝트를 하나 만듦.
    - @Before 실행 -> 코드 실행 후 결과 저장 -> @After 실행 과정을 반복.
* 현재 JUnit5도 이런 과정으로 동작할까?
* 테스트 메소드를 실행할 때마다 테스트 클래스의 인스턴스를 새로 만든다고 함.    
    - 그렇다면 너무 비효율적이지 않나.
    - 각 테스트가 서로에게 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해서라고 함.

#### 픽스처
* 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 함.
* 픽스처를 미리 세팅하는 구문을 작성해 @Before로 추출한다 생각해도 될 듯함.

## 2.4 스프링 테스트 적용
* p.184. To be continued...
