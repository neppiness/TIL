# **TIL on January 30th, 2023**
### BOJ step by step: 기하 2
#### [boj.kr/11758](../../../Problem%20Solving/boj/Math/11758-01-30-2023.cpp)
* 벡터 기하 문제 
  - 내적은 임의의 벡터의 특정 방향 성분 크기를 확인하기 위해 사용함: A·B = |A||B|cosθ
  - 외적은 두 벡터에 수직인 벡터 또는 한 평면의 법선벡터를 구할 때 활용한다.
* A(a1, a2), B(b1, b2)라고 둘 때, 외적의 크기는 a1b2 - a2b1으로 구할 수 있다. 두 벡터가 반시계 방향이면 이 값은 양수고, 시계 방향이면 음수다. 0인 경우, 두 벡터가 동일 직선에 있다는 의미이다.

#### [boj.kr/25308](../../../Problem%20Solving/boj/Math/25308-01-30-2023.cpp)
* CCW와 순열을 잘 활용하면 풀 수 있을 듯.
  - 모든 능력치 배열 순서를 확인하자; 능력치를 오름차순으로 정렬 후 next_permutation 활용
  - 간단하게 중심부에서부터 a1으로 향하는 벡터와 a1에서 a2로 향하는 벡터의 외적 값을 구하고, 해당 값이 시계방향, 즉 음수임을 확인하면 된다.
* 단, 한 좌표가 45도 회전한 경우를 따져야 하기 때문에, 이에 대한 처리는 0.0001 보다 차이가 작은 경우로 두자. 이게 제대로 작동할지는 모르겠음.
  - 별도로 소수점 처리 관련된 내용을 공부하자.


### BOJ step by step: 동적 계획법 3
#### [boj.kr/1311](../../../Problem%20Solving/boj/Dynamic%20programming/1311-01-28-2023.cpp)
* 상태를 비트마스킹 기법으로 기록하면 될 것.
* 이제 그 상태를 어떻게 DP에 활용할 것인지 생각해보자.

* N명의 사람이 N개의 작업을 선택하게 함.

* 완전 탐색으로 접근하면 1부터 N까지 순열을 만들고 그에 대한 비용을 확인하는 방식일 것.
  - DP로 중복 문제를 여러 개 만든다 생각하면...

* N = 3인 경우 고르는 과정을 아래와 같이 나타낼 수 있을 것.

|Status  |   |   |   |
|--------|---|---|---|
|Init.   |   |000|   |
|1-person|100|010|001|
|2-person|110|101|011|
|3-person|   |111|   |

* `int solve(int cur, int personidx) {}`
  - `personidx`: 고를 사람의 인덱스가 `n`이 되면 반환.
  - 여기선 solve 함수가 현재 상태에서 시작해 선택하는 비용의 최솟값을 반환한다고 하자.
    * 현재 상태: 일의 분배 상태는 cur 변수가 나타냄. personidx를 통해 누굴 고를 차롄지 파악 가능.
    * `x`명 고른 상태일 때는 그때만 얻을 수 있는 cur 값들이 있어 구분될 것.
  - DFS처럼 한 경로로 파고들면 안 되고, BFS처럼 한 사람, 한 사람씩 뽑아 계산하면서 진행해야 한다.
    * 그러기 위해서 현 personidx에 대해 `set`로 계산해야 하는 상태 수를 이전 personidx 단계에서 기록 후 넘어오는 것도 방법일 듯.

* solve 함수에 인자로 전달하는 것들이 캐싱할 때도 활용되는 거라 생각하면 되는 듯함.

* 다음 두 함수를 통해 매우 빠르게 32비트 상에 켜진 비트 수를 셀 수 있다. 이를 통해 현재 몇 개의 값을 뽑은 상태인지 파악할 수 있음.
  - `__builtin_popcount(var_32bits);`: gcc/g++
  - `__popcnt(var_32bits);`: Visual C++

* 이제 고민해야 하는 건 solve 함수의 정의임. 어떤 의미를 주고 어떤 점화식을 구현해야 모든 일을 하는 데 필요한 최소 비용을 출력할 수 있을지 고민해볼 것.