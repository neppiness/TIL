# **TIL on January 20th 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x12 Math
#### [boj.kr/10250](../../../Problem%20Solving/boj/Math/10250-01-20-2023.cpp): PR용 풀이 정리
* 작성한 풀이는 아래와 같다.
```cpp
/*
조건에 따라 엘리베이터에서 가까운, 즉 낮은 번호의 방을
낮은 층에서부터 높은 층까지 채운 후 다음 번호로 넘어간다.

n번째로 도착한 손님에게 방을 부여한다고 하자.
호실의 1, 10의 자리 숫자(no)는 n을 H로 나눈 몫과 관련되며
층수(fl)는 n을 H로 나눈 나머지와 관련된다.
해당 관계는 18-19번째 줄과 같이 정리된다.

만약 호수가 한 자릿수라면 앞에 0을 붙인다.
이후 층수와 호수를 붙여 완성된 방 번호를 출력한다.
*/
```

### BOJ step by step: 동적 계획법과 최단거리 역추적
#### [boj.kr/14003](../../../Problem%20Solving/boj/Dynamic%20programming/14003-01-18-2023.cpp): solved on 1st try (memory: 21924 kB, time: 308 ms, Code length: 892 B)
* 풀이부터 짜보고 생각하자.
* 캐시는 길이가 len인 공통 수열의 마지막 원소를 저장한다.
  - `int cache[MX + 2]; // last element indexed by length of increasing subsequence`
  - 해당 길이의 마지막 원소들은 단조증가한다.
* `void solve(int idx)`는 저장된 cache 배열에 입력값 `A[idx]`를 배치한다.
  - lower_bound로 `A[idx]`의 위치를 잡는다. lower_bound로 찾은 값은 `A[idx]` 이상인 값이다.
  - 그렇게 찾은 위치에다 `A[idx]`를 입혀주면 모든 경우에 대해 조치할 수 있다:
    1. `A[idx]` 보다 큰 값이면 그 위치를 작은 값으로 낮춰준다. 
    2. `A[idx]`와 같은 값이면 그냥 `A[idx]`를 넣어도 문제 없다.
    3. `A[idx]` 보다 작은 값일 순 없다.
  - 따라서 단순하게 아래와 같이 lower_bound로 주소를 찾고, 그 주소가 가리키는 곳에 수열의 원소를 배치하면 된다.

```cpp
for(int i = 0; i < n; i++) {
  int x; cin >> x;
  *lower_bound(cache, cache + n + 1, x) = x;
}
```

* 이제 복원 방법을 고안하자.
  - 값은 연산을 반복하면서 의미없이 덮여버리기 때문에, `cache`는 길이를 구할 때와 마찬가지로, 해당 증가하는 수열의 길이로 마지막 원소를 호출한다.
  - 이분탐색 편의성을 위해 `current_index` 배열을 따로 선언한다.
  - 덮어써야 하는 때만 덮어쓰자: 갱신이 필요할 때만 value와 current_index를 갱신하면 된다.
  - `prev_index` 배열 역시 따로 선언해둬야 한다.
  - 단, current_index는 cache와 마찬가지로 increasing subsequence 길이로 인덱싱 하는 것이고, prev_index는 수열의 인덱스 자체로 인덱싱 하는 배열이어야 하니 구분해야 한다.
* 이전 인덱스들 따라가며 스택에 넣고 추적하는 방식을 사용.


#### [boj.kr/9252](../../../Problem%20Solving/boj/Dynamic%20programming/9252-01-20-2023.cpp)
* LCS 풀이에서 복원 방법만 정리해보자.
  - 길이 갱신으로 접근해도 괜찮음. prv 배열을 만들고, 거기에 key 문자열의 인덱스를 저장하자.

* key 배열이 AA고, lock 배열이 AAA인 경우를 가정하자. AAA의 세 원소는 편의상 A1A2A3로 구분한다.

|el.  |A1 |A2  |A3  |
|-----|---|----|----|
|init.|Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |
|A    |A1 |A1A2|A2A3|

* 원소가 일치해 그 원소를 가져온다고 할 때, 이전까지 매칭된 기록을 참조하게 된다.
  - key의 첫 번째 원소와 매칭 시: 첫 번째 매칭 시도이므로, 이전에 기록해둔 공통 부분 수열이 없기 때문에 매칭된 자기 원소만 가져오게 된다. A1, A2, A3는 A와 매칭 시도하여 A1, A2, A3라는 공통 부분 수열을 얻게 된다.
  - key의 두 번째 원소와 매칭 시: A1의 경우 매칭에 성공하더라도, 이전까지 구성된 수열 상 매칭된 것이 없기 때문에, A1으로 그치게 된다. A2와 A3는 각각 A1과 A2로 구성된 수열을 참조하고, 자신이 매칭되기 때문에 이를 붙이면 A1A2, A2A3라는 공통 부분 수열을 얻게 된다.

* 다른 관점에서 확인하기 위해, AAB와 AB의 매칭을 분석하자.

|el.  |A1 |A2  |B  |
|-----|---|----|---|
|init.|Φ  |Φ   |Φ  |
|A    |A1 |A2  |Φ  |
|B    |Φ  |Φ   |A2B|

* 여기서는 기록되는 수열이 어떻게 정의되느냐에 따라 방식이 달라지게 된다.
  - 우리가 현재 구하려는 LCS가 keyidx, lckidx 시점의 것이라고 하고, 이를 위해 keyidx - 1, lckidx - 1만 참조하기 위해서는 keyidx - 1, lckidx - 1 상태의 LCS가 keyidx - 1에서 0부터 lckidx - 1의 LCS를 반영하는 식이어야 가능하다.
  - 그렇지 못한 경우, 아래와 같은 잘못된 결과를 얻을 수 있다.

|el.  |A1 |A2  |A3  |
|-----|---|----|----|
|init.|Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |
|B    |Φ  |A1  |A2  |
|B    |Φ  |Φ   |A1  |
|B    |Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |

* 이 경우, AAA와 ABBBA를 매칭시키는데, 3번째 B를 매칭할 때에는 이전까지 매칭된 결과를 다 잃어버려서 마지막 A를 확인할 때 LCS가 A1, A2, A3라고 결론짓게 된다. 그러나 이 조합에 대한 LCS는 자명하게 AA이다.

* 가장 간단히 생각할 부분을 떼어오자.

|el.|A|B|
|---|-|-|
|A  |A|?|

* 위 표에서 `?`로 표기한 자리를 어떻게 채울 것인지 생각해보자.
  - `?` 자리가 AB와 A의 공통 부분 수열을 의미한다 생각하자. 이에 따라 ?는 A로 채우는 것이 자연스럽다.

* lock이 AB, key가 BA인 예시를 생각해보자.

|el.|A|B|
|---|-|-|
|B  |Φ|B|
|A  |A|?|

* 위 표에서는 `?`로 표기한 자리에 무엇이 들어가야 할까?
  - AB와 BA의 LCS는 A, B 모두 될 수 있다.
  - 그리고 그 다음에 어떤 값이 이어지더라도 문제 없이 잘 처리될 수 있다.
  - 따라서 이에 대해선 자유롭게 선택해도 될 듯하다.

* 위에서 제시했던 예시를 한 번 더 반복하자.

|el.  |A1 |A2  |A3  |
|-----|---|----|----|
|init.|Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |
|B    |?  |?   |?   |
|B    |?  |?   |?   |
|B    |?  |?   |?   |
|A    |?  |?   |?   |

* 어떻게 이 ?들을 채워야 AA라는 자명한 LCS를 얻을 수 있을까?
  - 좌에서 우로 확장만 하는 것은 문제를 발생시킨다.

|el.  |A1 |A2  |A3  |
|-----|---|----|----|
|init.|Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |
|B    |Φ  |A1  |A1  |

* B에 의해 매칭되는 게 없더라도, A와 AB의 매칭을 생각해보면 LCS는 A는 되어야 하기 떄문이다. 따라서, keyidx - 1의 결과를 자연스럽게 이어받는다.

|el.  |A1 |A2  |A3  |
|-----|---|----|----|
|init.|Φ  |Φ   |Φ   |
|A    |A1 |A2  |A3  |
|B    |A1 |A2  |A3  |

* 그렇기 때문에 이전에 떠올렸던 아래와 같은 점화식이 정당화된다.
  * solve 함수에 사용될 점화식은 아래와 같다.
    - `ret = min({solve(keyidx, lckidx - 1), solve(keyidx - 1, lckidx), solve(keyidx - 1, lckidx - 1) + ismatched});`
    - `solve(keyidx, lckidx - 1)`: 문자열 key의 부분 문자열 중 인덱스가 0 이상 keyidx 이하인 문자로 이루어진 부분 문자열과 lock의 부분 문자열 중 인덱스가 0 이상 lckidx - 1 이하인 문자로 이루어진 부분 문자열로 만들 수 있는 LCS의 길이
    - `solve(keyidx - 1, lckidx)`: 문자열 key의 부분 문자열 중 인덱스가 0 이상 keyidx - 1 이하인 문자로 이루어진 부분 문자열과 lock의 부분 문자열 중 인덱스가 0 이상 lckidx 이하인 문자로 이루어진 부분 문자열로 만들 수 있는 LCS의 길이
    - `solve(keyidx - 1, lckidx - 1) + ismatched`: 문자열 key의 부분 문자열 중 인덱스가 0 이상 keyidx - 1 이하인 문자로 이루어진 부분 문자열과 lock의 부분 문자열 중 인덱스가 0 이상 lckidx - 1 이하인 문자로 이루어진 부분 문자열에 `bool ismatched = (key[keyidx] == lck[lckidx]);` 값을 더해 LCS 값을 늘릴 수 있나 확인.

* 이제 이를 복원할 방법을 고민하자. 점화식 사이에서 조심해야 하는 건 오로지 매칭에 성공했을 경우, 이전 문자를 잘 가리키도록 해야한다는 것 뿐인 듯하다.