# **Chapter 1. Introduction**

* 운영체제는 컴퓨터의 하드웨어를 관리하기 위한 소프트웨어다
* 응용 프로그램의 기저를 제공하고, 사용자와 하드웨어를 이어주는 매개체다.
* OS는 사방에 존재한다. 일반 컴퓨터부터 각종 전자기기, 휴대기기 등에 OS가 있다.
* 현대 컴퓨팅 환경 내 OS의 역할을 알고싶다면 먼저 컴퓨터 하드웨어의 조직과 아키텍쳐를 알아야 한다.
  - CPU, 메모리, 입출력 장치, 저장소 등이 이에 해당된다.

## 1.1 운영체제는 무엇을 하는가
* 컴퓨터는 크게 네 가지 요소로 구분될 수 있다.
  1. 하드웨어
  2. 운영체제(operating system, OS)
  3. 응용 프로그램(application programs)
  4. 사용자(user)
* 또한 다른 관점에서 컴퓨터는 하드웨어, 소프트웨어, 그리고 데이터로 구분될 수 있다.
  - OS는 컴퓨터 시스템 동작(operation)을 통해 이런 리소스를 적절히 활용할 수단을 제공한다.

### 1.1.1 User View (유저 관점)
* 유저는 컴퓨터 입출력 장치를 통해 응용 프로그램을 활용함.
  - 응용 프로그램은 운영체제 위에서 실행됨
  - 운영체제는 하드웨어에서 실행됨
* 유저는 키보드, 마우스로 운영체제를 활용할 수도 있고, 모바일 기기처럼 터치스크린을 활용할 수도 있음.
  - 어떤 것들은 기본적으로 사용자와 상호작용을 하지 않는 것을 전제로 하기도 함

### 1.1.2 System View (시스템 관점)
* 컴퓨터 관점에선 OS가 가장 밀접한 프로그램이다.
* OS를 리소스 할당자, 리소스 관리자 정도로 생각할 수 있을 듯하다.
* 컴퓨터 시스템은 문제를 풀기 위한 많은 리소스를 가지고 있다.
  - CPU time, memory space, storage space, I/O devices 등
* 충돌이 일어날 수 있는 리소스 요청은 OS가 이들을 어떻게 할당할 것인지를 결정해줘야 한다.
  - 이를 통해 사용자가 효율적이고 공평하게 프로그램들을 동작시킬 수 있다.
* 제어프로그램인 OS는 유저 프로그램 실행이 오류를 발생시키거나 컴퓨터를 잘못 쓰지 않게 관리한다.

### 1.1.3 Defining OS
* OS엔 정확한 정의가 없다.
* 하드웨어만으로 여러 문제를 해결하기 어려워 응용 프로그램이 개발되었다.
  - 이때 I/O 기기의 제어 등을 수행하던 프로그램들이 하나로 합쳐져 OS가 되었다.
* OS는 컴퓨터에서 항상 동작하는 하나의 프로그램이다.
  - 이를 보통 커널이라 한다.
  - 시스템 프로그램: OS와 관계되지만 커널의 일부가 아닌 프로그램. 시스템이 동작 중일 때 관리를 도움.
  - 미들웨어: 모바일 OS에서 앱 개발자에게 추가 서비스를 제공하는 소프트웨어 프로그램 집합

## 1.2 Computer-System Organization
* 현대 범용 컴퓨터는 하나 이상의 CPU와 장치 컨트롤러(device controller)가 '버스(bus)'를 통해 연결된다.
  - 이를 통해 구성요소와 공유 메모리가 서로 접근할 수 있게 된다.
* OS는 장치 컨트롤러를 위한 장치 드라이버(device driver)가 있다.
  - 장치 드라이버는 장치 컨트롤러를 인식하고 OS의 나머지 부분이 장치에 접근할 수 있는 일정한 인터페이스를 제공한다.
  - CPU와 장치 드라이버는 병렬적으로 동작하며 병렬적으로 메모리에 접근을 시도한다.
    + 이러한 부분은 메모리 컨트롤러가 동기화하여 순차적으로 메모리에 접근할 수 있게 한다.

### 1.2.1 Interrupts
* 전형적인 컴퓨터 동작을 고려하면:
  - 어떤 프로그램이 입출력을 수행한다고 하자. 이를 위해선 장치 드라이버가 적절한 레지스터를 장치 컨트롤러에 불러와야 한다.
  - 장치 컨트롤러는 레지스터 내용을 확인하고 무엇을 할지 결정한다.
  - 컨트롤러는 장치로부터 데이터를 전달받아 로컬 버퍼에 저장한다.
  - 데이터 전송이 끝나면 장치 컨트롤러는 장치 드라이버에 동작이 끝났음을 알린다.
  - 장치 드라이버는 OS의 다른 파트에 제어를 넘긴다. 데이터 자체를 넘기거나 다 읽어들인 데이터의 포인터를 넘겨줄 수 있다.
* 여기서 어떻게 장치 컨트롤러가 장치 드라이버에게 작업을 마쳤음을 알릴 수 있는가?
  - 그것이 인터럽트(interrupt)를 통해 이루어진다.

**1.2.1.1 Overview**
* 하드웨어는 시스템 버스를 통해서 CPU에 시그널을 보내 인터럽트를 일으킬 수 있다.
* 인터럽트는 OS와 하드웨어의 주된 상호작용 방식이기도 하다.
* CPU가 인터럽트 되면 하던 것을 멈추고 즉시 실행을 고정된 위치(fixed location)로 보낸다.
  - 이때 고정된 위치는 다시 작업을 재개할 수 있도록 작업 내역을 임시 보관할 위치다.
  - 해당 고정 위치는 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 포함하고 있다.
  - 인터럽트 서비스 루틴이 실행되고 이를 마치면 CPU는 이전에 수행하던 작업을 재개한다.
* 그림을 통해 입출력 장치와 CPU가 어떻게 상호작용 하는지 확인할 수 있다.
  - 입출력 요청에 따라 입출력 장치가 동작하기 시작하고, 전송이 끝난 뒤 인터럽트 신호를 CPU에게 보낸다.
  - 이를 받은 CPU는 입출력 인터럽트를 처리한다. 이후 처리가 끝나면 다시 CPU는 유저 프로그램을 처리한다.
  - 입출력 장치는 별도의 요청 전까지 아이들 상태(idle state)로 있는다.

> 드라이버와 컨트롤러가 어떻게 구분되나?
* 장치 컨트롤러(device controller)는 컴퓨터 내부의 전기적 부품임. 특정 기기를 담당함.
  - CPU와 비슷한 레벨의 장치임
  - 장치 컨트롤러마다 장치 드라이버가 있다.
* 장치 드라이버(device driver)는 운영체제별로, 하드웨어에 종속되는 프로그램이며 인터럽트를 처리할 수 있게 해주고, 비동기적 시간에 종속되는 하드웨어 인터페이스에 요구된다.
  - 이는 OS 내부의 코드로 연결된 장치가 OS와 호환성을 갖고 OS로부터 인식될 수 있으며, OS에 신호를 보낼 수 있도록 만들어준다.

* 포인터 표(a table of pointers)가 인터럽트 루틴을 빠르게 동작하게 만들기 위해 쓰일 수 있다.
  - 포인터 표는 로우 메모리(첫 100개 주소 정도)에 위치하며 여기에 다양한 기기의 인터럽트 서비스 주소를 담는다.
  - 이 배열을 인터럽트 벡터(interrupt vector)라고 한다.
  - 이같은 기법을 사용해서 운영체제는 인터럽트를 처리한다.

**1.2.1.2 Implementation**
* CPU 하드웨어는 연산을 수행한 후 인터럽트-리퀘스트 라인(interrupt request line)을 감지한다.
  - 만약 컨트롤러가 이 라인에 신호를 보낸 경우, 거기서 인터럽트의 고유 번호를 읽는다.
  - 이 번호를 통해 인터럽트 벡터에 접근하고, 인터럽트 주소로 이동할 수 있게 된다.
  - 이후 인터럽트를 처리하고, `return_from_interrupt`를 실행하면 인터럽트 전에 처리하던 위치로 돌아간다.
* 위와 같은 기본 동작을 수행하는데, 좀 더 정교한 처리 기능을 위해선 아래와 같은 것들이 필요하다.
  - 중요한 처리 중일 떄는 인터럽트 처리가 연기되어야 한다.
  - 인터럽트 처리자(interrupt handler)에게 전달하는 효율적인 방법이 필요하다.
  - 인터럽트에 레벨을 구분해 긴급한 순서대로 처리할 수 있어야 한다.
  - 위 같은 기능은 현대 컴퓨터 하드웨어의 CPU와 인터럽트-컨트롤러 하드웨어에 의해 제공된다.
* 대부분의 CPU는 두 유형의 리퀘스트 라인이 있다.
  - 논마스커블 인터럽트(nonmaskable interrupt)와 마스커블 인터럽트(maskable interrupt)이다.
  - 논마스커블은 예약된(reserved) 것으로, 복구 불가능한 메모리 에러와 같은 중요한 인터럽트에 대한 것이다.
  - 마스커블은 디바이스 컨트롤러가 요청을 할 수 있는 범용적인 인터럽트이다.
* 모든 인터럽트 핸들러를 인터럽트 벡터에 둘 수는 없다.
  - 따라서 체이닝을 활용하여, 어떤 인터럽트에 대해 그 핸들러가 위치한 주소를 받고 나면 해당 주소의 리스트를 하나씩 확인하게 된다.
  - 이는 핸들러를 탐색하는 속도와 인터럽트 벡터(또는 테이블)의 오버헤드에 대한 적절한 타협 결과이다.

### 1.2.2 Storage Structure
* CPU는 오로지 메모리에서만 연산자를 불러올 수 있다.
  - 따라서 어떤 프로그램이든 실행되기 위해선 메모리에 불러와야 한다.
* 특정 메모리 주소에 대해 불러오기 또는 저장하기 과정들을 통해서 메모리와 상호작용할 수 있다.
  - 로드(load) 연산은 CPU의 내부 레지스터로 바이트나 단어를 옮긴다.
  - 스토어(store) 연산은 레지스터에 있는 데이터를 메모리에 옮긴다.
  - 명시적인 로드와 스토어 뿐 아니라, CPU는 실행을 위해 메인 메모리로부터 연산자를 자동으로 불러온다.
    + 이 실행 명령은 프로그램 카운터가 저장된 장소에 있던 것이다.
    > 솔직히 풀어서 써도 어떤 의미인지 잘 와닿지 않음.
* 메모리가 빠르고, 어차피 프로그램을 실행하려면 메모리에 불러와야 한다. 그러나, 이를 영구히 저장해둘 순 없는데;
  - 모든 프로그램을 담기엔 충분히 크지 않다.
  - RAM은 휘발성 메모리기 때문에 여기에 데이터를 영구적으로 저장할 수 없다.
* 기억 장치는 다음과 같이 구분할 수 있다.
  - 1차 기억 장치(primary storage): 레지스터, 캐시, 주 메모리(RAM)
  - 2차 기억 장치(secondary storage): 비휘발성 메모리, 하드디스크 드라이브
  - 3차 기억 장치(tertiary storage): 광학 디스크, 마그네틱 테이프

* [내가 C 언어를 공부하기 전에 알았으면 좋았을 것들](https://modoocode.com/315)
  - 모두의 코드 내용에 따르면 64비트 CPU는 레지스터가 16개밖에 없다고 함.
  - 각 레지스터는 64비트의 데이터를 담을 수 있음.
  - 따라서 CPU에 담을 수 있는 데이터 크기는 최대 128바이트임.
  - 그보다 빠르게 접근해야 하는 자료들은 순차적으로 L1, L2, L3 캐시로 내려옴
