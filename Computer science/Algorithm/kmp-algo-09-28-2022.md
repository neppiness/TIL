[TIL on September 28th, 2022](../../TIL/2022/09/09-28-2022.md)
# **KMP Algorithm**
### Pattern matching
- My implementation
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);

  string a, b;
  a = "ORONDONTISS";
  b = "NTI";

  string ans;
  bool istrue = 0;
  for(int i = 0; i < a.length(); i++){
    if(a[i] != b[0]) continue;
    for(int j = 0; j < b.length(); j++) {
      if(i + j >= a.length()) break;
      if(a[i + j] != b[j]) break;
      if(j == b.length() - 1) istrue = 1;
    }
  }
  if(istrue) ans = "YES";
  else ans = "NO";
  cout << ans;
}
```

- Example
```cpp
bool find(string& A, string& B){
  for(int st = 0; st < (int) (A.size() - B.size()); st++){
    bool match = true;
    for(int i = 0; i < B.size(); i++){
      if(A[st + i] != B[i]){
        match = false;
        break;
      }
    }
    if(match) return true;
  }
  return false;
}
```
- Worst case: time complexity of O(|A||B|)
- KMP algorithm could solve pattern matching problems in O(|A|+|B|) of time complexity

### Failure function
- F(x): the maximum length of prefix and suffix less than x + 1
- Should start to check from x to a smaller value
- Let string S be "ABCDE". To check F(x), the part of the string index 0 to x + 1, `S[0:x+1]` is used
  * F(3): `S[0:4] = "ABCD"` is used to check the suffix and prefix
  * To check wheter F(3) = 3: string "ABC" and "BCD" is compared and because it's not the same, F(3) is not 3
  * To check wheter F(3) = 2: string "AB" and "CD" is compared and because it's not the same, F(3) is not 2
  * Likewise, F(3) = 0

#### DP application
- To simply calculate failure function of a certain value as the procedures above, the time complexity is O(|S|^2) at worst case
  * Using DP method, it could be reduced to O(|S|)
- 


___

### References
1. [[실전 알고리즘] 0x1E강 - KMP](https://blog.encrypted.gg/1040)