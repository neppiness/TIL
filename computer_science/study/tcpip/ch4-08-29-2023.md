# **Chapter 4. Beyond the Basics**

* 자바의 소켓을 활용한 프로그래밍 모델에 대해 2장에서 배웠다.
* 이제 이를 다양한 프로그래밍 모델에 적용해본다.

## 4.1 Multitasking
* 이터랙티브 서버(iterative server)
  - 이터랙티브 서버는 요청을 순차적으로 다룬다.
  - 하나의 요청을 마치면 다음 요청을 처리한다.
  - 이는 접속량이 적을 때 잘 동작한다.
  - 그러나, 어떤 요청은 처리하는 데 오랜 시간이 걸릴 수 있어 대기 시간을 예측하기 어려울 수 있다.
* 따라서, 우리는 각 연결을 독립적으로 처리하기 위한 방법을 찾아야 한다.
  - 자바 스레드는 정확히 이 역할을 수행할 수 있다.
  - 서버들이 많은 클라이언트 요청(clients)을 동시에 처리(handle)할 수 있게 된다.
  - 스레드 마다 각 클라이언트를 담당하도록 할 수 있다.
* 두 가지 접근 방식이 있음.
  1. thread-per-client: 클라이언트가 연결되면 새로운 스레드를 만들어서 할당함
  2. thread pool: 스레드들을 만들어놓고 클라이언트가 연결되면 할당함

### 4.1.1 Java Threads
* 자바는 새 스레드로 연산을 수행하는 두 가지 방법을 제공한다.
  1. 스레드 클래스의 서브 클래스를 정의하고 run() 메소드로 해당 작업을 처리
  2. Runnable 인터페이스를 구현하여 run 메소드에 해당 작업을 처리하도록 구현. 이후 스레드 클래스 생성자 인자로 해당 인터페이스를 넘김.
* 두 경우 모두 start() 메소드가 실행되기 전까지는 처리하지 않는다.
* Runnable 인터페이스를 구현해 넘겨주는 편이 확장성이 좋아 보통 그렇게 처리한다.
  - Runnable 인터페이스는 run 메소드 하나만 구현하도록 가지고 있다.
```java
interface Runnable {
    void run();
}
```

* 스레드의 start() 메소드로 작업을 지시하면 JVM은 인스턴스의 run() 메소드를 새 스레드에서 실행한다.
  - 그동안 작업을 지시한 메인 스레드(original thread)는 start() 호출에서 돌아와 다음 작업을 진행한다.
  - Note: 직접 run() 메소드를 호출하면 새로운 스레드가 생성되지 않는다.
  - 작업이 비동기적으로 이루어지므로 어떤 순서로 작업을 마치게 될지 알 수 없다.
* 위 과정을 구현하는 코드는 아래와 같다.
```java
import java.util.concurrent.TimeUnit;

public class ThreadExample implements Runnable {
    private String greeting; // Message to print to consolejava
    public ThreadExample(String greeting) {
        this.greeting = greeting;
    }

    public void run() {
        while (true) {
            System.out.println(Thread.currentThread().getName() + ": " + greeting);
            try {
                // Sleep 0 to 100 milliseconds
                TimeUnit.MILLISECONDS.sleep(((long) Math.random() * 100));
            } catch (InterruptedException e) {
            } // Should not happen
        }
    }

    public static void main(String[] args) {
        new Thread(new ThreadExample("Hello")).start();
        new Thread(new ThreadExample("Aloha")).start();
        new Thread(new ThreadExample("Ciao")).start();
    }
}
```

* 각각의 일을 수행하게 하는 것은 위 코드와 같은 식으로도 충분히 구현할 수 있다.
  - 다만, 수정할 데이터를 공유하는 경우에는 동시성이 문제가 되므로 주의를 요한다.

### 4.1.2 Server Protocol
* 위에서 서술한 멀티태스킹은 클라이언트-서버 프로토콜과는 무관하다.

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.logging.Level;
import java.util.logging.Logger;

public class EchoProtocol implements Runnable {

    private static final int BUFSIZE = 32; // Size (in bytes) of I/O buffer
    private Socket clntSock; // Socket connect to client
    private Logger logger; // Server logger

    public EchoProtocol(Socket clntSock, Logger logger) {
        this.clntSock = clntSock;
        this.logger = logger;
    }

    public static void handleEchoClient(Socket clntSock, Logger logger) {
        try {
            // Get the input and output I/O streams from socket
            InputStream in = clntSock.getInputStream();
            OutputStream out = clntSock.getOutputStream();

            int recvMsgSize; // Size of received message
            int totalBytesEchoed = 0; // Bytes received from client
            byte[] echoBuffer = new byte[BUFSIZE]; // Receive Buffer

            // Receive until client closes connection, indicated by -1
            while ((recvMsgSize = in.read(echoBuffer)) != -1) {
                out.write(echoBuffer, 0, recvMsgSize);
                totalBytesEchoed += recvMsgSize;
            }

            logger.info("Client " + clntSock.getRemoteSocketAddress() + ", echoed "
                    + totalBytesEchoed + " bytes.");
        } catch (IOException ex) {
            logger.log(Level.WARNING, "Exception in echo protocol", ex);
        } finally {
            try {
                clntSock.close();
            } catch (IOException e) {
                // blank
            }
        }
    }

    public void run() {
        handleEchoClient(clntSock, logger);
    }
}
```

* EchoProtocol 자체가 Runnable 인터페이스의 구현체
* 아래 코드에서 의문이 듦.

```java
public void run() {
    handleEchoClient(clntSock, logger);
}
```
* handle을 하려면 EchoProtocol의 인스턴스가 있어야 할 것
  - 이에 따르면 이미 필드에 clntSock과 logger가 세팅된 상태일 것
  - 그런데 왜 46번째 줄에서는 handleEchoClient 호출 과정에 다시 인자로 (clnkSock, logger)를 전달하는가?

* Logger 클래스에 대해서
  - 서버에 문제가 발생했을 때 로그를 통해 확인할 수 있다.
  - 다음 명령을 통해 하나의 인스턴스를 받을 수 있으며, 이는 싱글톤으로 설계되어 있다.
  - `Logger logger = Logger.getLogger("practical");`
* 로거의 레벨, 심각도(severity), 로그 엔트리
  - 내장 레벨: severe, warning, info, config, fine, finer, finest.
* 로거는 핸들러에게 메시지를 전송한다.
  - 핸들러는 최소 로그 레벨밖에 없기 때문에 메시지의 수준이 로거와 핸들러의 한계치보다 높아야 한다.
  - (이 부분은 로그에 대한 기본 지식이 없어서 잘 이해가 안 됨)
* 로그는 멀티스레드 환경에 대해 안전하다(thread-safe)

<br>

### 4.1.3 Thread-per-Client
* 서버는 클라이언트의 연결 요청을 받아들이고 이를 처리하는 새로운 스레드를 생성함.
  - 이 과정을 무한 루프를 돌며 반복적으로 수행
* 이는 추가 스레드 없이 단일 스레드로 처리하는 iterative 서버와 유사하다.
  - 차이점은 직접 클라이언트의 요청을 처리하는 게 아니라는 점
* 무한루프 부분의 코드를 보자.

```java
// Run forever, accepting and spawning a thread for each connection
while (true) {
    Socket clntSock = servSock.accept(); // Block waiting for connection
                                         // Spawn thread to handle new connection
    Thread thread = new Thread(new EchoProtocol(clntSock, logger));
    thread.start();
    logger.info("Created and started Thread " + thread.getName());
}
```

* `servSock.accept();`을 통해 socket을 반환받기에 이를 변수에 할당
  - thread 생성 후 소켓과 로거를 전달해줌.
  - thread를 시작함

### 4.1.4 Thread Pool
* 새 스레드는 시스템 리소스를 소모한다.
  1. 스레드 생성은 CPU 연산을 수행해야 한다.
  2. 각 스레드는 자신만의 자료구조를 가지기에 시스템 메모리를 쓰게 된다.
  3. 하나의 스레드가 대기 상태로 전환되었을 때:
    + JVM은 그 상태를 저장하고, 다른 동작할 스레드를 선택하며, 선택된 스레드의 상태를 복원해야 한다.
    * 이를 context switch라고 한다.
* 스레드 수가 많아질수록 스레드 오버헤드에 많은 리소스가 쓰이게 된다.
* 이렇기에 우리는 스레드의 최대 수를 제한하고 스레드를 재활용해야 한다.
* 스레드 풀보다 많은 수의 접속 요청이 들어오면 이를 큐에 넣고 대기시킨다.
  - 이후 요청을 처리한 스레드가 다시 풀에 돌아오면 다른 클라이언트와 연결되어 요청을 처리한다.
* accept이 될 때까지 연결을 시도하는 코드는 아래와 같다.

```java
// Spawn a fixed number of threads to service clients
for (int i = 0; i < threadPoolSize; i++) {
    Thread thread = new Thread() {
        public void run() {
            while (true) {
                try {
                    Socket clntSock = servSock.accept(); // Wait for a connection
                    EchoProtocol.handleEchoClient(clntSock, logger); // Handle it
                } catch (IOException ex) {
                    logger.log(Level.WARNING, "Client accept failed", ex);
                }
            }
        }
    };
    thread.start();
    logger.info("Created and started Thread = " + thread.getName());
}
```

* `while (true)` 안에서 try로 시도하며 clnSock에 값이 들어오도록 시도
  - 이 경우, 엄청난 속도로 예외가 뿜어져나오지 않을까 좀 궁금함. 직접 해봐야 알 듯.
* 이상적으로 부하가 많이 걸릴 때 스레드 수를 늘리고, 부하가 적을 때는 스레드 수를 줄일 수 있다면 좋다.
  - 자바는 이같은 편의기능을 제공한다.

### 4.1.5 System-Managed Dispatching: The Executor Interface
```java
interface Executor {
    void excute(Runnable task);
}
```
* 자바는 사용하기 편리한 다양한 Executor를 내장한다.
  - 예시: 스레드가 잡지 못한 예외가 발생해서 멈춘 경우에 즉시 새로운 스레드를 생성해 대체해주기도 한다.
  - 코드: `Executor service = Executors.newCachedThreadPool(); // Dispatch svc`
* 이같은 편의기능을 활용하여 손쉽게 스레드 관리를 할 수 있다는 게 이 속절의 포인트

<br>

## 4.2 Blocking and Timeouts
* 소켓 I/O가 블락되는 경우
  1. 해당 데이터를 쓸 수 없는 경우: read(), receive() 메소드가 블락된다.
  2. 버퍼를 전달하기 위한 충분한 공간이 없는 경우: write() 메소드가 블락된다.
  3. 연결이 수립되기 전에는 accept() 메소드는 블락된다.
  4. 서버가 느려서 데이터가 처리가 안 되면 이를 받아야만 진행되는 전체 어플리케이션이 블락된다.
* 호출이 끝나기 전에 수행할 작업이 있는 경우는 해당 호출에 의해 블락되면 안 된다.
* UDP 데이터그램은 데이터그램을 잃어버렸다고 해서 블락하면 안 된다.

### 4.2.1 accept(), read(), and receive()
* 이 메소드들은 최대 대기 시간을 걸어둔다: setSoTimeout()
  - 해당 시간을 넘어가면 InterruptedIOException이 발생한다.

### 4.2.2 Connecting and Writing
* 소켓 생성자는 호스트와 포트의 연결을 수립하고자 시도함.
  - 연결이 수립되거나 시간 초과가 발생하기 전까지 블락된 상태로 대기한다.
* Java의 write는 timeout이 없어서 큰 데이터의 경우 상한이 없는 시간 동안 기다리게 될 수 있다고 함.
  - 지금의 java는 어떤지 확인이 필요한 부분.

### 4.2.3 Limiting Per-Client Time
* 이 하위 절의 내용에 따라 타임 리밋을 설정할 수 있다고 함.

<br>

## 4.3 Multiple Recipients
* *To be continued*
