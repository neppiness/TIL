# **TIL on April 19th, 2023**

### solved.ac Class 6 Problems
#### [BOJ #1019](../../../Problem%20Solving/boj/solvedac/1019-04-19-2023.cpp)
* 0부터 세고 나서, 마지막에 0을 한 개 빼주는 풀이.
1. 0부터 9까지는 모든 숫자가 1번씩 등장한다.
2. 이후에는 십의 자리에 숫자 하나씩 배치하며 숫자를 증가시킨다.
3. 백의 자리에 배치된 숫자는 해당 백의 자리를 모두 순회하면 100개가 증가한다.

* 재귀적으로 구현하면 풀 수 있을 듯함. `vector<int> solve(int st, int en);`을 정의해서, st이상 en 미만인 값에 대한 0부터 9까지 활용된 숫자 수를 반환하도록 함.
```cpp
int a[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
```

* 좀 더 명확한 풀이를 구상한 이후에 수행해야 할 듯함.

* 재귀적으로 단계를 분할해 푸는 것이 좋을 것으로 보임. 
  - 일단 기저 사례는 잘 구현함.

```cpp
vector<int> solve(int st, int en) {
  vector<int> a(10, 0);
  vector<int> tmp;

  if(en < 10) {
    for(; st <= en; st++) a[st] = 1;
    return a;
  }
  // 이하 구현 필요
}
```

* 구조체 Digits을 정의해서 곱하기 연산에 대해 간단하게 할 수 있도록 설정할 것.
  - solve(0, 3) * 10 = {10, 10, 10, 10, 0, 0, 0, 0, 0, 0};

* N = 19인 경우, 어떻게 나눠서 풀 수 있는지 생각해보자.
  - solve(1, 19) = solve(1, 9) + solve(10, 19)
  - solve(1, 9) = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1}
* solve(10, 19) = {1, 11, 1, 1, 1, 1, 1, 1, 1, 1}
  - 십의 자리 숫자가 1임. 이 숫자는 (en + st - 1)개 쓰임: solve(1, 1) * (en + st - 1)
  - 일의 자리 숫자는 0부터 9까지 쓰임: solve(0, 9)
  - 따라서, solve(10, 19) = solve(1, 1) * (19 - 10 + 1) + solve(0, 9)이다.
  - 이 둘을 더하게 되면 예제의 답인 {1, 12, 2, 2, 2, 2, 2, 2, 2, 2}을 얻게 된다.

* 시간 초과인 로직. 다른 풀이를 생각하자.


### Random Defense
#### [BOJ #2346](../../../Problem%20Solving/boj/random%20defense/2346-04-19-2023.cpp): solved on 1st try (memory: 2152 kB, time: 0 ms, Code length: 705 B)
* 연결리스트 문제. 야매 연결리스트 활용하여 해결함.

#### [BOJ #1495](../../../Problem%20Solving/boj/random%20defense/1495-04-19-2023.cpp): solved on 2nd try (memory: 2028 kB, time: 4 ms, Code length: 563 B)
* DP문제. 함수 int solve(int no)은 no번째 곡을 연주할 때 볼륨의 최댓값이라 하자.
  - 기저 사례는 no == 0일 때 S값을 반환하도록 하자.
* BFS라고 생각하고 접근했는데, 메모리 초과를 받음. queue에 너무 많은 데이터를 저장해야 했음.
  - DP로 재구현해야 함.
* 큰 값만 반환하면 안 되고, 작은 값에서도 가져올 수 있어야 함.

* set로 BFS와 유사하게 확인하는 로직을 짰음. 디버깅 중. 어떤 부분이 잘못됐었는지 반드시 기록할 것.
  - ns를 클리어 안 해줘서 데이터가 쌓였던 것이 잘못. 이를 비워주는 명령을 구현함.

<br>

### 스프링 핵심 원리 - 기본편
#### 섹션 7. 의존관계 자동 주입