[TIL on March 15th, 2023](../../TIL/2023/03/03-15-2023.md)
## 섹션 6. HTTP 상태코드
### 상태 코드
* 클라이언트가 보낸 요청(request)의 처리 상태를 응답(response)에서 알려주는 기능
  1. 1xx (Informational): 요청이 수신되어 처리 중 - 거의 사용하지 않음
  2. 2xx (Successful): 요청 정상 처리 - `200 OK`부터 시작해서 주요하게 쓰이는 것들이 있음.
  3. 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 - 리디렉션
  4. 4xx (Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
  5. 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

* 클라이언트가 명확히 인식할 수 없는 코드가 오기도 할 것. 그 경우, 백의 자릿수로 어떤 상태를 반환한 것인지 판단하면 됨. 이를 '상위 상태코드'로 해석해서 처리한다고 말함
<br>

### 200번대 상태 코드 중 활용 빈도가 높은 것들에 대한 설명
* 개발할 때 각 팀들이 어느 정도 코드들을 활용할 것인지 약속하고 작업하는 게 일반적이다.

* 200 OK
  - HTTP start-line에 OK를 달고 보내줌.
  
* 201 Created
  - 아래와 같은 요청을 보냈다고 하자.
```http
POST /members HTTP/1.1
Content-Type: application/json

{
  "username": "young",
  "age": 20
}
```
  - 처리 후 그에 대한 응답을 아래와 같이 보냈다고 하자.
  - 생성된 리소스는 응답의 Location 헤더 필드로 식별: `Location: /members/100`
```http
HTTP/1.1 201 Created
Content-Type: application/json
Content-Legnth: 34
Location: /members/100

{
  "username": "young",
  "age": 20
}
```

* 202 Accepted(활용 빈도 떨어짐)
  - 요청이 접수되었으나 처리가 완료되지 않았음.
  - 배치 처리 같은 곳에서 사용

* 204 No Content
 - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음.
 - 웹 문서 편집기에서 save 버튼을 누른다.
 - save 버튼을 눌러도 같은 화면을 유지해야 한다.
 - 결과 내용이 없어도 204 메시지만으로 성공을 인식할 수 있다.
 - Q. delete하려는 파일이 이미 지워진 상태라면 반환할 내용이 없다는 표시를 하진 않나?
<br>

### 300번대 리디렉션 개념과 301, 308 영구적 리디렉션
* 300번대, 리디렉션
  - 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동함

```http
GET /event HTTP/1.1
Host: localhost:8080
```

```http
HTTP/1.1 301 Moved Permanently
Location: /new-event
```

```http
GET /new-event HTTP/1.1
Host: localhost:8080
```

```http
HTTP/1.1 200 OK
...
```

  - 리디렉션 응답을 받게 되면 그 응답을 받은 브라우저는 자동으로 해당 리디렉션 경로로 요청을 보냄. 이에 대한 처리를 새로운 페이지에서 진행하게 되는 것.

* 영구 리디렉션 - 특정 리소스의 URI가 영구적으로 옮겨간 경우
* 일시 리디렉션 - 일시적인 변경
  - 주문 완료 후 주문 내역 화면으로 이동
  - PRG: Post/Redirect/Get 패턴
* 특수 리디렉션 - 결과 대신 캐시를 사용
  - 캐시 기간 만료 여부를 파악하기 위해 서버에게 확인 받음.

* 301, 308 Moved Permanently
  - 리소스의 URI가 영구적으로 이동
  - 원래의 URL를 사용하지 않음. 검색 엔진 등에서도 변경 인지할 수 있음.
  - 301 Moved Permanently: 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(GET의 본문을 허용 안 하는 서버의 경우엔 본문 내용이 지워질 것이라 예상됨.)
    * GET으로 변할 수도, 아닐 수도 있고, 본문이 제거될 수도, 아닐 수도 있다는 의미로 스펙을 작성했던 것으로 보임.
  - (거의 안 씀)308 Permanent Redirect: 301과 기능은 같으나 리디렉션 시 요청 메서드와 본문 유지(POST를 보내고 리디렉션 응답을 받았다면 POST 메서드를 유지함)
  - 활용하기 나름이겠지만, 만약에 리디렉션이 필요한 경우 내부적으로 이전 location에서 필요로 했던 데이터들이 전부 바뀌어버린다. 따라서 308로 POST를 유지하면서까지 활용할 수 있게 되는 경우는 실무적으로 거의 없음을 인지할 것.
<br>

### 일시적 리디렉션 302, 307, 303
* 302 Found (실무에서 많이 활용하고 있음)
  - 리디렉션 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(될 수도 있고 안 될 수도 있다)

* 307 Temporary Redirect
  - 302와 기능이 같음. 리디렉션 시 요청 메서드와 본문 유지(요청 메서드를 변경해선 안 됨)

* 303 See Other
  - 302와 기능이 같음. 리디렉션 시 요청 메서드가 GET으로 명확히 변경

* 304 Not Modified
* 300 Multiple Choices
<br>

### 일시적 리디렉션 예시
* PRG: Post/Redirect/Get
  - POST로 주문 후에 웹 브라우저를 새로고침: 이 경우 재요청됨. 이에 따라 중복 주문이 될 수 있음.

* PRG 미적용
1. 요청
```http
POST /order HTTP/1.1
Host: localhost:8080

itemId=mouse&count=1
```

2. 주문 데이터 저장: mouse 1개

3. 응답
```http
HTTP/1.1 200 OK

<html>주문완료<html>
```

4. 결과 화면에서 새로고침

5. 재요청
```http
POST /order HTTP/1.1
Host: localhost:8080

itemId=mouse&count=1
```

6. 주문데이터 추가

7. 응답
```http
HTTP/1.1 200 OK

<html>주문완료<html>
```

* PRG 적용
  - POST 메서드를 활용해 주문 후에 새로고침을 하면 중복 주문이 될 수 있음. 이를 막기 위함
  - POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다ㅣㅇ렉트
  - 새로고침해도 결과 화면을 GET으로 조회
  - 중복 주문 대신에 결과 화면만 GET으로 다시 요청

1. 요청
```http
POST /order HTTP/1.1
Host: localhost:8080

itemId=mouse&count=1
```

2. 주문 데이터 저장: mouse 1개

3. 응답
```http
HTTP/1.1 302 Found
Location: /order-result/19
```

4. 자동 리다이렉트

5. 재요청
```http
GET /order-result/19 HTTP/1.1
Host: localhost:8080
```

6. 주문데이터 조회, 19번 주문 정보

7. 응답
```http
HTTP/1.1 200 OK

<html>주문완료<html>
```

8. 결과 화면에서 새로고침
```http
GET /order-result/19
```
  - 단순히 결과 화면만 다시 요청하게 되는 것.
<br>

* 역사
  - 302 스펙의 의도는 HTTP 메서드를 유지하는 것
  - 대부분의 웹 브라우저들이 대부분 GET으로 바꿔버림
  - 그래서 모호한 302를 대신하는 307, 303이 등장
* 현실
  - 307, 303을 권장하지만 현실적으로 이미 많은 어플이 302를 기본으로 사용
  - 자동 리디렉션 시에 GET으로 변해도 된다면 302를 사용해도 큰 문제 없다.

* 300 Multiple Choices: 안 쓴다

* 304 Not Modified
  - 캐시를 목적으로 사용
  - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다(캐시로 리다이렉트)
  - 로컬 캐시를 사용해야 하기 때문에 304 응답은 응답에 메시지 바디를 포함하면 안 된다.
  - 조건부 GET, HEADS 요청 시 사용
<br>

### 4xx 클라이언트 오류
* 인증이 안 되거나, 클라이언트의 스펙이 잘못된 경우가 많다.

* 4xx (Client Error)
  - 클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
  - 오류의 원인이 클라이언트에 있음
  - 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에 똑같이 재시도해도 실패함
  - 이에 반해 500대 오류는 재시도 시에 서버 상태가 정상화된 경우 성공할 수 있음.

* 400: Bad request
  - 요청 구문, 메시지 등의 오류
  - 클라이언트는 요청 내용을 다시 검토하고 보내야 함.
  - 예: 요청 파라미터가 잘못됐거나 API 스펙이 맞지 않을 때.
  - 이런 부분은 백엔드 개발자들이 잘 제어해야 함.

* 401: Unauthorized, 클라이언트가 해당 리소스에 접근하려면 인증이 필요함, 로그인이 안 된 상태.
  - 인증(Authentication)되지 않음
  - 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
  - 참고
    * 인증(Authentication): 본인이 누구인지 확인, 로그인 필요
    * 인가(Authorization): 권한 필요
    * 401 오류 메시지가 Unauthorized지만 실질적으로는 인증이 되지 않았다는 의미로 쓰이고 있다고 지적하심.
  
* 403 Forbidden: 승인 거부
  - 로그인은 있지만, 접근 권한이 없는 경우에 승인이 거부됨.

* 404 Not Found: 요청 리소스를 찾을 수 없음
  - 이런 리소스가 없는데, 이를 서버에 요청한 경우
  - 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶다면(403이라 하면 해당 리소스가 존재한다는 걸 알 수도 있기 때문에)
<br>

### 5xx 서버 오류
* 500 Internal Server Error
  - 서버 문제로 오류 발생. 애매한 경우 500 오류를 냄

* 503 Service Unavailable
  - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음.
  - Retry-After 헤더 필드로 얼마 뒤에 복귀되는지 보낼 수도 있음.

* 서버에서는 웬만하면 500대 에러를 만들면 안 된다.