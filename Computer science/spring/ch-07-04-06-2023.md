[TIL on April 6th, 2023](../../TIL/2023/04/04-06-2023.md)
## 섹션 7. AOP
### AOP가 필요한 상황
* 모든 메소드의 호출 시간을 측정하고 싶다면?
  - 시간 측정 로직을 모든 메소드에 넣어둘 순 없지 않나.
  - 만약 메소드가 1000개 있다고 하자. 이에 대한 로직 시작 시각과 로직 마치는 시각을 잡아놓고 초 단위로 계산하게 했다. 이미 여기까지 하는 것도 끔찍한데, 여기에다 갑자기 ms 단위로 바꾸자고 하면... 디지털 노가다 그 자체일 것이다.

* 아래와 같이 join 메소드에 시간 측정 로직을 추가한다고 하자.
```java
    public Long join(Member member) {

        long start = System.currentTimeMillis();
        try {
            validateDuplicateMember(member); // 중복 회원 검증
            memberRepository.save(member);
            return member.getId();
        } finally {
            long finish = System.currentTimeMillis();
            long timeMs = finish - start;
            System.out.println("join = " + timeMs + "ms");
        }
    }
```
  - 이를 통해서 테스트했을 때, join 로직을 수행하는 데 2ms가 걸린다고 확인이 되었음.
  - 이런 로직을 메소드 마다 적용한다 생각하면 끔찍한 일임.

* 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)
  - 이같이 구현하는 것은 아래 문제들을 내포한다.
    - 회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다.
    - 시간을 측정하는 로직은 공통 관심 사항이다.
    - 시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다(끔찍함).
    - 시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다.
    - 시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다.
* 이런 끔찍한 반복 작업을 덜어줄 것이 바로 AOP이다.
<br>

### AOP 적용
* AOP란?: Aspect-oriented programming
<br>