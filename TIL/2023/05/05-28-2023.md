# **TIL on May 28th, 2023**

### Random Defense Using C++
#### [BOJ #16918](/Problem%20Solving/boj/random%20defense/16918-05-28-2023.cpp): solved on 1st try (memory: 2580 kB, time: 52 ms, Code length: 1219 B)
* 모든 보드의 초 값을 더하면서 3초가 될 때 터뜨리는 방식으로 구현하면 될 듯함.


#### [BOJ #9659](/Problem%20Solving/boj/random%20defense/9659-05-28-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 134 B)
* 홀수면 상근이가 이기고 짝수면 창영이가 이긴다.


#### [BOJ #12891](/Problem%20Solving/boj/random%20defense/12891-05-28-2023.cpp): solved on 1st try (memory: 3680 kB, time: 16 ms, Code length: 639 B)
* 투 포인터로 간단히 풀 수 있을 듯.


#### [BOJ #16929](/Problem%20Solving/boj/random%20defense/16929-05-28-2023.cpp)
* 한 점에서부터 같은 색 점을 찾아 이동하며 거리를 확인. 가장 마지막에 시작점으로 돌아오는지 확인하면 됨.
* 깊이 우선 탐색으로 접근해야 할 듯함.

#### [BOJ #2109](/Problem%20Solving/boj/random%20defense/2109-05-28-2023.cpp)
* 과제 문제와 유사함. n일 째에 할 수 있는 과제를 먼저 수행하는 식으로 접근.
  - 우선순위 큐로 간단하게 구현해봤음.
  - 1번째 제출 WA. 풀이 수정 필요. 로직이 확립이 안 된 상태에서 예제 답만 보고 제출했던 것. 수정할 게 많음.