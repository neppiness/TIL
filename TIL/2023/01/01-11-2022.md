# **TIL on January 11th 2023**
### Problem Solving Using C++
#### BaaaaaaaarkingDog Practical Algo. Lecture: 0x12 Math
##### [boj.kr/1735](../../../Problem%20Solving/boj/Math/2312-01-11-2023.cpp): solved on 1st try (memory: 2256 kB, time: 0 ms, Code length: 736 B)
* N = 100,000인 소수를 목록으로 만들고, 작은 소수부터 순회하며 입력 받은 *x*값을 나누는 알고리즘
  - N이 100,000이기 때문에 제곱하다가 인트 범위를 벗어날 우려가 있어 에라토스테네스 체 로직에 활용되는 iterator들은 long long으로 선언해버렸다.
  - *x*를 소수로 나누면서 몫을 챙기는 로직.
  - 소수로 나누는 반복문에서 `if(x == 0) break;`가 아니라 `if(x == 1) break;`이어야 정상작동한다. 1은 소수로 나눠떨어지지 않기 때문에 `x == 0`인 경우는 절대로 없다.

#### solved.ac Essential Problems
##### [boj.kr/9252](../../../Problem%20Solving/boj/solvedac/9252-01-09-2023.cpp)
* 최대 증가 부분 수열 문제 응용이고, 이를 역추적해 최장 공통 부분 수열을 뽑아내는 건데, 풀이 과정이 아직도 안 익숙해서 기본 문제 구현이 안 됨(boj.kr/9251). 다시 한 번 공부하고 접근할 필요가 있음.
  - 차분히 지금 뭘 구현해야 하는지 명확하게 따지면서 접근하자.
* 이전까지 만든 가장 긴 수열에다 현재 문자 붙여서 새로운 공통 수열 만들기.

* 9251번 정답 코드는 만들었지만, 여전히 점화식 의미가 모호함. 엄밀하게 풀이 작성할 것. 그래야 인덱스 추적해서 9252번을 풀 수 있을 듯.

* 앞에 입력으로 주어지는 문자열을 key, 이후에 입력으로 주어지는 문자열을 lck(자물쇠, lock)이라고 하자.
  - 예제와 같이 key는 `ACAYKP`, lck는 `CAPCAK`인 경우를 상정하자.

|lck |C|A|P|C|A|K|
|----|-|-|-|-|-|-|
|init|0|0|0|0|0|0|
|0(A)|0|1|1|1|1|1|
|1(C)|1|1|1|2|2|2|
|2(A)|1|2|2|2|3|3|
|3(Y)|1|2|2|2|3|3|
|4(K)|1|2|2|2|3|4|
|5(P)|1|2|3|3|3|4|

* 캐시 `cache[keyidx][lckidx]` 
  - 정의: 0번부터 lckidx번 인덱스의 lck 문자열과 0번부터 keyidx번 인덱스의 key 문자열의 최장 공통 부분 수열 길이
  - `cache[keyidx][lckidx]`를 계산할 때 참고되는 것은 `cache[keyidx - 1][lckidx]`와 `cache[keyidx - 1][lckidx - 1] + ismatched`, 그리고 `cache[keyidx][lckidx - 1]`값.
    1. `cache[keyidx - 1][lckidx]`: 이전에 뽑은 LCS 요소들 유지
    2. `cache[keyidx][lckidx - 1]`: 이번 keyidx에 대해 얻은 LCS 요소 유지
    3. `cache[keyidx - 1][lckidx - 1] + (key[keyidx] == lck[lckidx])`로 LCS 길이를 증가 또는 유지.
  - 기저 사례: 0 베이스에서 출발.

* 간단하게 keyidx 0과 1에 대해서 어떤 조합을 뽑는 것과 동일한지 확인하자

|lck |C1|A1|P |C2   |A2    |K    |
|----|--|--|--|-----|------|-----|
|init|Φ |Φ |Φ |Φ    |Φ     |Φ    |
|0(A)|Φ |A1|A1|A1   |A1(A2)|A1   |
|1(C)|C1|A1|A1|A1,C2|A1,C2 |A1,C2|

* 이제 결과를 출력하기 위한 idx 배열을 구상하자.
  - idx는 최대 길이인 1000까지 인덱스로 받을 수 있게 배열을 선언: `int idx[1002];`
  - 이 배열은 LCS 길이가 갱신될 때마다 갱신하여 LCS 복원에 활용될 것이다.
  - 즉, `cache[keyidx - 1][lckidx - 1] + ismatched`로 인한 갱신이 일어나면, 길이로 인덱싱하는 인덱스 배열에 `keyidx - 1`값을 기록하는 식으로 구현할 생각.


#### BOJ step by step: Stack 2
##### [boj.kr/3015](../../../Problem%20Solving/boj/Stack/3015-10-17-2022.cpp)
* 이전에 시도했을 때 시간 초과가 났던 문제.
* `(현재 스택 사이즈) - 1`이 곧 만들 수 있는 쌍의 수임
  - 그렇게 될 때 숫자가 하나면 0개의 쌍을 반환함
  - 5개가 같은 숫자라 생각하자. 일단 가장 작은 인덱스의 숫자를 포함해 만들 수 있는 쌍의 수는 4개. 그 다음은 3개. 이렇게 총 4 + 3 + 2 + 1개의 쌍을 만들 수 있으며, 총 10개의 쌍을 만들 수 있음.

* 이제 스택을 어떤 식으로 활용할지 생각해보자. 물론 스택 활용에 틀어박혀 생각하면 안 되고, 자연스러운 풀이를 고민하자.

* 제약이 되는 쪽은 키가 작은 쪽이다. 그러니 키가 작은 쪽을 버리고 다음으로 넘어가는 방식을 고민하자.

* 아래 관찰에 착안해서 풀이를 고민해보자.
  - 1, 3, 5 조합은 어떤가?: 1, 3은 가져가고, 이들보다 큰 5를 받는다고 하면 1의 인덱스를 다음으로 넘겨야 함. 그래야 3, 5 조합을 확인할 수 있음.
  - 5, 3, 1은 어떤가?: (5, 3), (3, 1)이 전부. 마찬가지로 5와 1 사이에 1보다 큰 3이 껴있기 때문에 이같이 됨
  - 3, 5, 1은?: (3, 5), (5, 1). 가운데 끼어있는 5가 가장 커도 달라지진 않음
  - 5, 1, 3은 어떤가: (5, 1), (5, 3), (1, 3). 1은 5와 3 모두 보다 작기 때문에 한 쌍을 더 챙길 수 있음

* 시작 원소 st, 끝 원소 en이라 할 때, st와 en 둘 중 하나보다 큰 원소가 중간에 끼면 st를 바꿔야함.