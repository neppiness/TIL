# **Ch. 10 Virtual Memory**

### NOTE: 9.1.3 Logical Versus Physical Address Space
* 컴파일타임(컴파일 중인 시점)이나 로드타임(불러오는 중인 시점)에는 논리적 주소나 물리적 주소나 같다.
* 런타임(실행 중인 시점)에 주소를 묶는 방식은 논리적 주소와 물리적 주소를 다르게 만든다.
  - 이 경우 우리는 논리적 주소를 가상 주소(virtual adadress)로써 참조하게 된다.
* 런타임에 MMU(Memory management unit)는 물리적 주소를 가상 주소로 매핑한다.
* 'relocation' 레지스터에는 다음 프로레스에 할당할 첫 주소를 기록해둔다.
  - 프로세스는 가상 주소만 참고하고, 이 가상 주소는 실제 relocation 레지스터에 기록된 base 값부터 시작되는 물리적 주소와 연결된다.
* 예시
  - base가 300040이고 프로그램 크기가 120,900이라면 물리 주소 300040부터 420940까지를 프로그램이 점유하게 된다.
  - 프로그램은 0부터 120,900까지의 (가상) 주소를 사용하는 것처럼 쓸 수 있다.
* 프로세스가 실행되기 전에 모든 프로세스가 메모리 안에 들어가도록 요구하곤 한다.
* 가상 메모리(Virtual Memory)는 메모리 안에 온전히 들여다놓지 않은 프로세스들도 실행할 수 있게 해준다.
  - 이를 통해 물리 메모리보다 큰 프로그램도 실행할 수 있다.
  - 또한 가상 메모리는 주 메모리를 매우 크고 균일한 배열로 추상화한다.
  - 이에 따라 물리 메모리로부터 보이는 프로그래머 논리적 메모리와 구분된다(?).
  - 이를 통해 프로그래머는 메모리 용량 한계를 더이상 고려하지 않아도 된다.
* 가상 메모리는 프로세서들이 파일과 라이브러리를 공유할 수 있게 하며, 공유 메모리를 구현할 수 있게 만든다.
* 또한 프로세서를 만드는 효율적인 메커니즘을 제공한다.
* 그러나 가상 메모리는 구현하기 어렵고, 주의깊게 사용하지 않으면 성능이 상당히 떨어지게 된다.

<br>

## 10.1 Background
* '인스트럭션들은 물리적 메모리 안에 있어야 한다'는 요구조건은 필수적이고 합리저인 것처럼 보인다.
  - 그러나 이 요구조건은 프로그램의 크기를 물리 메모리의 크기로 제한한다.
* 실제 프로그램을 사용할 때는 모든 기능이 필요한 게 아니다.
  1. 에러 처리나 특별한 기능의 경우 실행될 일이 많이 없을 수 있다.
  2. 배열은 실제 선언한 크기와 달리 더 크게 메모리를 점유할 수 있다.
* 따라서 프로그램의 일부를 메모리에 띄우게 된다. 이를 통해서 다음 이점을 얻을 수 있다.
  1. 프로그램의 크기 한계가 물리 메모리 크기로 제한되지 않는다.
  2. 각 프로그램이 물리 메모리를 적게 점유하게 되면 CPU 활용도가 높아진다.
  3. 메모리에 파일 일부를 불러오거나 스왑하는 과정이 줄어 I/O 처리를 덜하게 되며, 각 프로그램의 실행속도가 빨라지게 된다.
* 가상 메모리는 물리적 메모리로부터 개발자가 인지하는 논리적 메모리를 분리한다.
* 프로세스의 가상 주소 공간은 프로세스가 메모리에 어떻게 저장되는지 논리적(가상적) 관점을 제공한다.
* 메모리 4영역은 모두 가상 메모리 안에 배치된다.
  - 희소 공간(sparse space의 직역): 스택과 힙 사이의 갭을 의미한다.
  - 프로그램 실행 중에 동적으로 라이브러리를 불러오면 희소 공간 안에 라이브러리 내용이 채워진다.
  - 이와 같은 부분은 공유 페이지로써 서로 다른 프로세스가 하나의 공간에 있는 내용을 참조할 수도 있다.

<br>

## 10.2 Demand Paging (file p. 504)
> 그 전에 paging에 대해서 먼저 공부할 수밖에 없을 듯함.

<br>

### NOTE: Paging
* Main Memory: file p. 349 


## 최종 목표 
> 그래서 가상 메몸리를 왜 쓰냐라는 질문에 답하기 위한 것들을 알면 될 듯함.
