[TIL on August 11th, 2022](../../TIL/2022/08/08-11-2022.md)
# **Sort II**

### Counting sort
- Assume that an array is given as `arr[] = {1, 5, 4, 2, 3, 1, 4, 3};`
- We can make a table that the number occurence counts as shown below:

 | 1 | 2 | 3 | 4 | 5 |
 |---|---|---|---|---|
 | 2 | 1 | 2 | 2 | 1 |

- After that, we can sort the array using this table
- This sorting algorithm is called as Counting sort
- It spends quite amount of memory so that we can only apply it for the array whose maximum element is under 10M
- Time complexity: if the number of numbers in the range is K, the time complexity becomes O(N+K)
- So Counting sort is very efficient when K is relatively small

### Radix sort
#### Non-comparative sorting
- Radix sort is a non-comparative sorting algorithm
  * It avoids comparison by creating and distributing elements into buckets according to their radix
- For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered

#### Characteristics of radix sorting
- The sorting can be started from both the least and the most significant digit
- Each step requires just a single pass over the data, since each item can be placed in its bucket without comparison with any other element

#### Starting from the least significant digit
- Input list: `[170, 45, 75, 90, 2, 802, 2, 66]`
- Starting from the rightmost (last) digit, sort the numbers based on that digit:
`[{170, 90}, {2, 802, 2}, {45, 75}, {66}]`

- Sorting by the next left digit:
`[{02, 802, 02}, {45}, {66}, {170, 75}, {90}]`
  * Notice that an implicit digit 0 is prepended for the two 2s so that 802 maintains its position between them.

- And finally by the leftmost digit:
`[{002, 002, 045, 066, 075, 090}, {170}, {802}]`
  * Notice that a 0 is prepended to all of the 1- or 2-digit numbers

#### Starting from most significant digit; forward recursive
- Input list, fixed width numeric strings with leading zeros:
`[170, 045, 075, 025, 002, 024, 802, 066]`

- First digit, with brackets indicating buckets:
`[{045, 075, 025, 002, 024, 066}, {170}, {802}]`
  * Notice that 170 and 802 are already complete because they are all that remain in their buckets, so no further recursion is needed

- Next digit:
`[{ {002}, {025, 024}, {045}, {066}, {075} }, 170, 802]`

- Final digit:
`[ 002, { {024}, {025} }, 045, 066, 075 , 170, 802]`

All that remains is concatenation:
`[002, 024, 025, 045, 066, 075, 170, 802]`

#### Implementation
- [radix-sort-08-12-2022.cpp](./radix-sort-08-12-2022.cpp)

#### Comparison / Non-comparison sort
- Comparison sort: merge, quick, bubble sort
- Non-comparison sort: counting, radix sort

<br>

### STL sort
- We can sort an array with one line of command
```cpp
int N = 5;
int a[N] = {1, 4, 5, 2, 7};
sort(a, a+N);

vector<int> b = {1, 4, 5, 2, 7};
sort(b.begin(), b.end()); // or sort(b.begin(), b.begin()+N);
```

- As mentioned before, STL sort is based on Quick sort
  * However, if uneven division is repeated so that the recursion depth becomes deeper, it is operated by another sorting algorithm to guarantee O(NlgN) of time complexity
- Thus, we can use STL sort without some time complexity concerns
- Quick sort isn't a stable sort, neither the STL sort is
  * We could use stable_sort function for stable sorting
  * A syntax for stable sort is identical to STL sort

#### Sort for pair and tuple
- The comparison for pair and tuple is defined as a comparison between first elements of each group
- ex) {2, 5} < {3, -2} / {2, 1, 0} > {2, -2, 6}
- So we can sort coordinates and the other properties with pair or tuple

#### Custom comparison function
To be continue

<br>

### Application of sorting
___

### References
1. [[실전 알고리즘] 0x0F강 - 정렬 II](https://blog.encrypted.gg/966)
2. [Radix sort From Wikipedia](https://en.wikipedia.org/wiki/Radix_sort)