[TIL on March 22nd, 2023](../../TIL/2023/03/03-21-2023.md)
## 섹션 6. 스프링 DB 접근 기술
* 개요
- '순수 JDBC'부터 시작해 발전하는 과정을 따라가는 것이라 이해하면 됨.
- 메모리에서 시작해서 한 단계씩 진화하는 과정을 보여주고자 함.
<br>

### H2 데이터베이스 설치
* DB는 보통 mySQL이나 NoSQL을 활용.
* JDCB URL을 `jdbc:h2:tcp://localhost/~/test`로 설정함. 이를 통해서 파일에 직접 접근하는 방식이 아니라, 소켓을 통해 접근하는 방식으로 수정해야 오류가 발생하지 않음.

```sql
drop table if exists member CASCADE;
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```

* DB에서는 long 타입이 bigint 타입임.
* `generated by default as identity`를 설정하면 이 값이 비어있는 경우 DB가 자동으로 할당해줌.
* `insert into member(name) values('spring')` 명령을 통해 이름이 spring인 데이터를 저장할 수 있음.
* 이 과정은 H2의 웹 콘솔을 통한 제어임. 다음부터는 우리가 만들어 둔 어플리케이션을 제어해서 직접 DB를 제어하고자 함.
<br>


### 순수 JDBC
* 옛날에는 이렇게 작업했었다는 수준으로 이해하면 된다. *편하게 들어라.*
* `build.gradle`에 의존성 추가
```
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'

	implementation 'org.springframework.boot:spring-boot-starter-jdbc' // added
	runtimeOnly 'com.h2database:h2' // added

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
* `src/main/resources` 안에 있는 `application.properties`에 아래와 같은 내용을 입력함.
```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
```
  - 이를 통해 소스의 위치를 알려주고 이를 h2로 구동시킴. h2.Driver를 인식하지 못하는 경우 build.gradle을 갱신해주면 됨.

* 이렇게 설정해주고 나면 spring이 알아서 DB와 연결해줌.
* 이후 명령이 복잡함.
  - 쿼리할 것에 대해 `String sql = "insert into member(name) values(?)";` 형식으로 작성함.
  - conn으로 connection을 받고, pstmt에 PreparedStatement를 받음. 이후 pstmt를 setString 한 뒤 executeUpdate 수행.
  - 생성된 키를 rs로 받고, 확인 작업. 조회 실패 시 SQLException을 던짐. 이 모든 과정에 대해 try-catch로 잡아주고 finally로는 connection을 끊어줘야 함.

```java
    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
```
* 커넥션은 아래와 같이 스프링을 통해 수행하는 게 좋다. 매번 새로운 연결을 수행하는 게 좋지 않다고 함.
```java
    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }
```

* 이후 SpringConfig 클래스에 구현체를 바꿔치기 함.
```java
    private final DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }
```
```java
    @Bean
    public MemberRepository memberRepository() {
        // return new MemoryMemberRepository();
        return new JdbcMemberRepository(dataSource);
    }
```

* 요점: 스프링을 왜 쓰는가?
  - 객체 지향적 설계의 장점, 다형성 활용.
  - 스프링 컨테이너가 이를 지원한다.

![구현 클래스 추가 이미지](./img/imp-class-img.png)

* 인터페이스는 그대로 활용하고 구현체만 바뀌어서 넘어간다.
* 개방-폐쇄 원칙(OCP, Open-Closed Principle)
  - 확장에는 열려있고, 수정에는 닫혀있다.
  - 수정 또는 변경이라 함. 그런데, 수정을 해야 확장을 할 것 아닌가?
* 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.

* 이것이 객체 지향의 가장 큰 장점이라 설명함.
<br>

### 스프링 통합 테스트
* DB까지 연결해 수행하는 통합 테스트를 할 것.
* 지금까지 작성한 테스트들은 순수한 자바 코드에 대한 테스트였음.
  - 이제부터 스프링과 엮어서 테스트하는 방식을 배울 것.

* 일단은 어떤 테스트가 이루어지는지만 배워두자.

* `@SpringBootTest`와 `@Transactional`을 어노테이션으로 걸어야 한다.
  - class 바깥에 적어둬야 함.
* Test는 내가 필요한 것을 주입하고 시험해보면 끝남.
* 이전에 메모리 상에서 테스트용 데이터를 지워주는 로직을 썼었는데, `@Transactional` 덕분에 그런 작업이 필요가 없어짐.

* 테스트는 시험용 데이터베이스 또는 로컬 PC 안에 있는 데이터베이스에서 수행해야 함.

* 테스트는 반복할 수 있어야 한다. 그러나, 데이터베이스에 특정 데이터를 추가하는 테스트를 수행한다고 하면, 이를 반복해서 수행헀을 때 결과가 달라질 수가 있음.
  - 이를테면, 지금처럼 중복 가입을 막은 경우에, 테스트를 여러 번 수행하면 이미 있던 데이터로 재가입을 시도하려는 로직이 되고, 이에 따라 가입에 실패하게 됨.

* 이럴 경우 beforeEach, afterEach로 DB를 정리해도 됨. 그러나, 데이터베이스는 트랜잭션이라는 게 있음. commit을 하기 전엔 데이터가 확정되지 않음. 따라서 작업을 모두 해놓고 commit을 하지 않으면 저절로 롤백됨.
  - 변경사항을 반영하지 않도록 제어할 수 있게 된다.

* 강의 노트에서 발췌(p.47)
  - `@SpringBootTest`: 스프링 컨테이너와 테스트를 함께 실행한다.
  - `@Transactional`: 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고,
테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지
않는다.

* 순수하게 자바 코드로 된 부분에 대한 테스트를 '유닛 테스트'라고 함. 이에 반대되는 개념이 '통합 테스트'임. 자바 스프링과 DB까지 모두 연동돼서 수행하는 테스트를 '통합 테스트'라고 지칭하는 것.

* 단위 테스트가 좋은 테스트다. 이처럼 잘 나눠서 수행하는 테스트가 좋은 테스트일 수 있다.
  - 통합 테스트가 필요하긴 하다. 그렇지만 그럴 필요가 없는 부분에서 고도화된 테스트를 수행하면 자원 낭비라고 말하고 싶으신 듯.
<br>

### 스프링 JdbcTemplate
* 실무에서도 많이 쓰이는 방식
  - 주입은 아래와 같이 수행한다.
  - 생성자를 만드는데, DataSource를 주입시킴.
```java
    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
```
* 생성자가 하나인 경우에는 `@Autowired`를 생략할 수 있다.

* Jdbc의 더럽고 복잡한 부분을 간략화한 게 아래 결과라 이해하면 됨.
```java
    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper());
        return result.stream().findAny();
    }
```
```java
    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
```
* RowMapper를 위같이 작성해두긴 해야 함.
  - RowMapper가 열을 매핑하는 역할.
  - rs: resultSet, rowNum: 열 번호


* template인 이유: 템플릿-메서드 패턴이라는 디자인 패턴에서 차용한 것으로 이해됨.
* save 기능은 아래와 같이 구현된다.

```java
    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());
        
        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }
```
* SimpleJdbcInsert
  - `jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");`로 설정하면 쿼리를 짤 필요가 없다. 테이블 명과 primary key가 있으면 바로 insert할 수 있음. 이후 추가 작업을 위해서 parameters라는 이름의 Map 인터페이스를 구현함.
  - 이를 MapSqlParameterSource의 인자로 전달해 인스턴스를 생성하고, jdbcInsert의 executeAndReturnKey 메서드를 통해 map 형태의 인자를 입력하고 key 값을 돌려받을 수 있음. 이 돌려 받은 키를 member의 Id로 설정한 뒤에 member를 반환.
  - 다만, 이 save가 member를 반환할 필요가 있는지, 어떻게 활용되는지 알 필요가 있을 듯함.
<br>

### JPA | 자바 퍼시스턴스 API
* 위의 jdbcTemplate의 경우에는 SQL을 사용자가 직접 작성할 필요가 있었음. 그러나 JPA를 도입하게 되면 이를 완전히 대체해준다.
* 단순히 SQL을 만들어주는 것을 넘어서서 SQL 보다 객체 중심의 설계를 가능하게 도와줌. 이러한 패러다임 전환이 가능함.

![https://trends.google.co.kr/trends/explore?date=all&q=%2Fm%2F026dw9m,%2Fm%2F0fqmvs4&hl=ko](./img/jpa-vs-mybatis.png)
* 전세계적으로 볼 때, JPA의 활용도가 훨씬 높음. 다만, 우리나라에서 초기에 도입됐을 때 관성에 의해 아직도 마이바티스를 많이 활용하고 있는 것으로 나타나는 듯함.

* Spring framework는 엄청나게 큰 기술이다. JPA도 스프링만큼 기술적인 넓이와 깊이가 있는 기술이다.

* build.gradle에 아래와 같은 의존성을 추가하자.
```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
```

* application properties에는 아래와 같이 설정하자.
```
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

* JPA란 인터페이스다. 구현체로 hibernate나 eclipse 등이 있는 것. 여기서는 hibernate를 쓴다.
  - JPA는 자바 진영의 표준 인터페이스임.

* ORM: Object Relational-database Mapping, 객체와 관계형 데이터베이스를 매핑한다는 의미. 이를 어노테이션으로 수행한다.
  - 이 매핑을 관리할 도메인에 설정하는 것. 그 구현은 아래와 같음.

* Identity 전략: DB에서 아이디를 자동으로 생성해서 관리하는 방식이라 생각하면 될 듯.
  - 오라클 같은 경우엔 sequence라고 하기도 함.

```java
package hello.hellospring.domain;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Member {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

* 이후 이 도메인을 가지고 Repository를 구현하기 시작함. `JpaMemberRepository` 클래스를 구현한다고 하자.


<br>

### 스프링 데이터 JPA
* JPA를 스프링으로 한 번 감싼 것.