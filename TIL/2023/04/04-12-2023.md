# **TIL on April 12th, 2023**
### 스프링 핵심 원리 - 기본편
#### 섹션 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용: completed at 5:33 PM on April 12th, 2023.
#### 섹션 4. 스프링 컨테이너와 스프링 빈
<br>

### 백준: 단계별로 풀어보기 | 스택 2
#### [BOJ #3015](../../../Problem%20Solving/boj/Stack/3015-04-11-2023.cpp)
* 예제 문제에 대해 확인해보자.
  - 7 / 2 4 1 2 2 5 1

* 단순하게 처음부터 끝까지 확인하는 풀이를 생각하자.
  - 여기서부터 발상을 시작하는 게 좋은 게, 결국 전부 다 확인하는 풀이는 정답임. 이를 최적화할 수 있다면 이 문제에 적용할 수 있는 해를 얻을 수 있는 것이니까.

* `a[] = {2, 4, 1, 2, 2, 5, 1};`이라 선언하고, 0번 인덱스를 잡은 채로 나머지를 둘러보자(시간복잡도 O(N^2) 풀이)
  - 인덱스 쌍을 [idx1, idx2]로 표현해보자.
  - 인덱스 0에 대해서 나머지 모든 인덱스를 확인하자.
    * [0, 1]: 2, 4. 가능한 쌍
    * [0, 2]: 중간에 0번 인덱스와 2번 인덱스인 2, 1 보다 큰 4가 끼어있기 때문에 불가능함.
    * [0, 3], [0, 4], [0, 5], [0, 6]: 모두 1번 인덱스가 4이기 때문에, 0번 보다 크고, 해당 쌍은 유효하지 않다.
  - 다음 인덱스로 넘어가자.
    * [1, 2]: 키 (4, 1) 가능한 쌍
    * [1, 3]: 키 (4, 2). 중간에 이보다 더 큰 값이 없기 때문에 가능함.
    * [1, 4]: 키 (4, 2). 중간에 높이가 같은 경우는 있지만, 더 큰 값은 없기 때문에 가능.
    * [1, 5]: 키 (4, 5). 위와 마찬가지 이유로 가능한 쌍.
    * [1, 6]: 키 (4, 1). 5가 가리기 때문에 불가능.

* 반대로부터 생각해야 할 것 같음.
  - 마지막 인덱스인 6에 대해서 생각하면서 좌우로 좁히는 방식이라 한다면 어떨까?
<br>

### Random Defense
#### [BOJ #17406](../../../Problem%20Solving/boj/random%20defense/17406-04-12-2023.cpp): solved on 1st try (memory: 2056 kB, time: 20 ms, Code length: 1563 B)
* 범위 바깥의 수를 돌리진 않으니 예외 처리가 까다롭지도 않음.
  - next_permutation을 활용해서 6! = 720개 경우의 수를 돌아보면서 A의 최솟값을 갱신하면 되는 문제임.
  - 다만, 주어진 명령에 대해서 회전 연산을 수행하는 게 중요할 듯.
* 단순한 구현 방법을 생각해보자.
  - 튜플로 회전 연산을 기억함. 이후 next_permutation에서 주어진 회전 연산 순서에 따라 원배열 복제본에 연산 적용
  - 방향을 기억하면서 범위에서 벗어나는 경우 방향을 바꾸는 식으로 구현하면 어떨까. tmp 배열을 선언하는데, 최대 크기는 50x50으로. 기준 위치는 좌측상단(x, y가 최소인 곳).

* 배열을 회전하는 함수는 아래와 같이 구현함
```cpp

void rot(int x, int y, int s_lim) {
  for(int s = 1; s <= s_lim; s++) {
    int cx = x - s, cy = y - s;
    int dir = 0;
    while(dir != 4) {
      int nx = cx + dx[dir];
      int ny = cy + dy[dir];
      if(nx < x - s || ny < y - s) { dir++; continue; }
      if(nx > x + s || ny > y + s) { dir++; continue; }
      b[nx][ny] = a[cx][cy];
      swap(cx, nx); swap(cy, ny);
    }
  }
}
```
* 이에 대한 결과값은 행렬 b에 저장되기 때문에 이를 a로 옮겨 닮아야 한다. 해당 작업은 아래와 같이 이루어진다.

```cpp
  for(auto seq : perm) {
    auto [r, c, s] = op[seq];
    rot(r, c, s);
    for(int i = 0; i < n; i++)
      for(int j = 0; j < m; j++)
        a[i][j] = b[i][j];
  }
```