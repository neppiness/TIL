# **TIL on June 8th, 2023**

### Random Defense Using C++
#### [BOJ#5719](/Problem%20Solving/boj/Dijkstra%20algorithm/5719-06-06-2023.cpp): solved on 3rd try (memory: 2984 kB, time: 36 ms, Code length: 1617 B)
* 다익스트라 풀이 구현 중. 다익스트라로 최단 거리를 찾은 후, 역추적 하면서 쓰인 경로를 비활성화 할 것.
* 도로는 단방향 간선임. 문제 제대로 읽을 것.
* `for (int i = 0; i < n; i++) rev_adj[i].clear();`를 통한 초기화를 안 했었음. 이를 구현함
* 2번째 제출은 TLE. 어떤 게 문제가 될 수 있는지 확인 중.
  - 해당 간선을 사용한다는 것이 확정되면 다시 큐로 들어가지 않도록 막아야 함.


#### [BOJ#3474](/Problem%20Solving/boj/random%20defense/3474-06-08-2023.cpp): solved on 1st try (memory: 2020 kB, time: 20 ms, Code length: 317 B)
* 2의 배수, 4의 배수, ... 2^x의 배수에 대한 나눗셈으로 해당 수가 몇 개 포함되는지 확인한다. 마찬가지로 5의 배수, 25의 배수, ... 5^y의 배수에 대한 나눗셈으로 해당 수가 몇 개 포함되는지 확인한다. 이후 2의 수와 5의 수 중 작은 수가 곧 해당 팩토리얼의 0의 개수가 된다. 오버플로우를 피하기 위해 long long 범위로 선언했으나, 10억 팩토리얼의 0의 개수는 249,999,998개로 인트 범위 내에 들어온다.
* 5의 배수 개수만 세도 옳은 풀이가 된다. 코드도 줄이고 시간도 줄임.


#### [BOJ#3079](/Problem%20Solving/boj/random%20defense/3079-06-08-2023.cpp)
* 우선순위 큐 활용 문제일 듯.
  - 나올 때마다 들어가는 게 아니라 기다릴 필요가 있음. 따라서 다른 접근이 필요함.
* 다익스트라는 어떨까? - 감은 있는데, 이걸 어떻게 그래프 문제로 변환할 수 있는지 구현에 대한 확신이 부족함.


#### [BOJ#17425](/Problem%20Solving/boj/random%20defense/17425-06-08-2023.cpp)
* 풀이 다시 정립하기.


#### [BOJ#1948](/Problem%20Solving/boj/Dijkstra%20algorithm/1948-06-08-2023.cpp): solved on 1st try (memory: 10320 kB, time: 412 ms, Code length: 1209 B)
* 다익스트라로 경로를 구한 후에 최적 경로에 대해 표시를 하면 될 것으로 생각됨.
* 답이 사실 다익으로 접근하는 건 아니었던 듯. 하지만, 거의 최단 경로와 유사한 방식으로 구현해 풀 수 있었음.
* 다른 방식의 위상정렬을 공부하면 더 쉽게 접근 가능한가 궁금함.
* [라이 위상정렬 강의에 설명이 있음.](https://m.blog.naver.com/kks227/220800013823)


#### [BOJ#13907](/Problem%20Solving/boj/Dijkstra%20algorithm/13907-06-08-2023.cpp)
* 통과하는 도로의 총 개수를 상태로써 기록하는 풀이를 구현함.
  - 아무리 도로를 많이 통과해도 N번 이상을 지나진 않게 됨
  - 정말 더 많은 경로를 거쳐 최단 경로를 얻을 가능성이 없는가?: 이미 n - 1번의 도로를 통과하면 모든 정점을 경유하는 경우가 된다. 중복된 정점을 경유하면 절대로 그 정점을 한 번만 경유하는 경로보다 짧을 수가 없다(간선 비용이 양수이기 때문에).
  - `dist[en]`에 대해서 값들을 증가시키면서 확인하면 됨.
  - 큐에 지금껏 몇 번을 오갔는지 기록하도록 설정.
* 풀이 면밀히 분석해보기. n번의 간선을 통과하면 아무리 멀어도 도착해야 함.
  - 1열로 연결된 경우를 생각하자. n개의 정점은 n-1개의 간선으로 연결되어 있을 것이며, 제대로 된 경로라면 n-1번을 거치면 무조건 목적지에 도달하게 되어 있음.
  - 큐에 들어가 계산되는 대상은 최소화해야함. 잘못하면 연산량이 지나치게 많아져 문제가 될 수 있음.