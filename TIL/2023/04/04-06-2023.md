# **TIL on April 6th, 2023**
### Class 6 Problems | solved.ac
#### [BOJ #1948](../../../Problem%20Solving/boj/Math/1948-04-06-2023.cpp)
* 다익스트라 알고리즘을 활용해서 풀 수 있을 듯함. 출발 도시와 도착 도시가 있다고 하면, 출발 도시에서 경유지까지 가는 최단 경로와 도착 도시에서 경유지까지 가는 최단 경로의 합으로 접근하면 좋을 듯.
  - 이 과정에서 거치는 길의 수는 최단 경로가 갱신될 때에 갱신되도록 구현.
* 가능한 모든 경로를 확인해야 함. 그래서 1-4, 4-6, 1-2, 2-6, 6-7 도로를 쉬지 않고 달려야 함. 최단 경로 문제가 아님. 그렇지만, 다익스트라를 활용하면 주변 모든 경로를 확인하게 되니까 최장 경로를 찾고 경로 복원하는 방식으로 풀 수 있을 것 같긴 함. 첫번째 솔루션은 폐기.

### LCA 연습문제
#### [BOJ #15480](../../../Problem%20Solving/boj/Tree/15480-04-06-2023.cpp)
* 매번 루트를 바꿔가면서 재계산해서 LCA 출력하면 되는 문제로 보이는데, 시간 복잡도를 다시 생각해보자.
<br>

### 단계별로 풀어보기 | 심화 2
#### [BOJ #25192](../../../Problem%20Solving/boj/Hash/25192-04-06-2023.cpp): solved on 1st try (memory: 10192 kB, time: 36 ms, Code length: 342 B)
* ~~세트로 채팅 엔터를 제외한 닉네임을 기록하고 세트 크기를 출력하면 될 듯함.~~
* ENTER가 들어오면 카운트 횟수를 늘림. 만약, gg_emo[chat_id]가 ENTER 횟수와 같다면 넘어감. 그외 경우 gg_emo[chat_id]를 ENTER 횟수와 같게 만들고 답을 하나 늘림. 구현은 아래와 같음.

```cpp
  while(n--) {
    cin >> s;
    if(s == "ENTER") { cnt++; continue; }
    if(gg_emo[s] == cnt) continue;
    gg_emo[s] = cnt;
    ans++; 
  }
```
<br>

### 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술
#### [섹션 6. 스프링 DB 접근 기술](../../../Computer%20Science/spring/ch-06-03-28-2023.md)
* 섹션 6-6. 스프링 데이터 JPA
#### [섹션 7. AOP](../../../Computer%20Science/spring/ch-07-04-06-2023.md)