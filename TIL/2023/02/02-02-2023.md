# **TIL on February 2nd, 2023**
### solved.ac Class 5 Essential Problems
#### [boj.kr/1182](../../../Problem%20Solving/boj/solvedac/1182-02-02-2023.cpp): solved on 2nd try (memory: 2020 kB, time: 84 ms, Code length: 545 B)
* 부분수열의 합; 쉬운 버전
  - 지금 '1208-02-01-2023.cpp'의 setup 함수 기반이 되는 로직은 옳은 로직임


#### [boj.kr/1208](../../../Problem%20Solving/boj/solvedac/1208-02-01-2023.cpp): solved on 9th try (memory: 14440 kB, time: 356 ms, Code length: 936 B)
* 심각한 오류 발견
  - 입력: 1 1 0 / 출력: 2
  - 디버깅 해보기

* 정말 절대로 해선 안 되는 실수를 했음.
  - `-x`를 찾으면 절대 안 되는데 지금까지 `-x`를 찾고, `s == 0`인 경우에 대해 성립하는 것만 확인했음.
  - `int tar = s - x;`로 설정하고, `tar` 값을 찾는 것으로 바꿈
  - equal_range 함수를 통해 upper_bound와 lower_bound를 동시에 계산하고 이를 구간 찾는 데 활용함.
  - 다시는 이런 실수 하지 않도록 주의할 것.

* 다른 풀이들은 좀 더 간단하게 하는 듯.
  - 수열을 분할하지 않는 건 좀 별로인 것 같지만, 모든 원소를 넣고 빼보면서 값을 만들고, 해당 값의 개수를 배열에 저장하는 방식으로 풀었음. 2'000'000은 여기서 일종의 정규화에 활용됨.
  - 한 번은 백트래킹으로 값을 세고, 한 번은 백트래킹으로 그 값에 대응되는 값을 확인하며 만들어지는 쌍에 대한 cnt를 추가함.
  - 이렇게 얻은 값에서 중복을 제하는 방식으로 계산함.
  - 배열 내에서만 동작해서 속도가 정말 빠름. 12ms.
  - 그에 반해 내 풀이는 356ms나 걸림. 대신 내 풀이는 long long 범위까지도 커버할 수 있는 풀이긴 함.
  - 이런 식으로 접근할 수도 있구나 참고하기.


### S3 to G3 Random Defense
#### [boj.kr/10971](../../../Problem%20Solving/boj/random%20defense/10971-02-02-2023.cpp): solved on 2nd try (memory: 2020 kB, time: 48 ms, Code length: 713 B)
* N!로 풀리는 문제.
* 1번째 제출 WA
  - 조건 똑바로 읽자. **갈 수 없는 경우 0이 주어진다.**
* 2번째 제출, 갈 수 없는 경우 다음 순열로 넘어가도록 구현. AC.


#### [boj.kr/1922](../../../Problem%20Solving/boj/random%20defense/1922-02-02-2023.cpp): solved on 1st try (memory: 4460 kB, time: 32 ms, Code length: 699 B)
* 최소 스패닝 트리 문제, 크루스칼 알고리즘으로 구현함.
* 개인적으로 유니온 파인드는 부모 노드를 먼저 찾고 진행하는 게 깔끔하게 좋은 듯함.
  - 두 노드의 부모 노드가 같은 경우 merge를 하지 않고 다음 간선 확인
  - 두 노드의 부모 노드가 다른 경우 merge 수행. 비용 추가.

```cpp
void merge(int u, int v) {
  if(p[u] > p[v]) swap(u, v);
  p[u] += p[v];
  p[v] = u;
}

// ...

for(auto [cost, u, v] : edge) {
  int pu = find(u);
  int pv = find(v);
  if(pu == pv) continue;
  merge(pu, pv);
  ans += cost;
}
```

* merge도 몇 줄 안 되기 때문에 그냥 간선에 대한 포문 내에서 깨버려도 괜찮을 듯함
  - 큰 차이는 없지만 연산량 아끼려면 간선이 n-1개 뽑혔을 때 끝내도록 구현할 것
  - find 속도가 매우 빠르기 때문에 MST 완성 후 간선들을 돌아보는 작업도 얼마 걸리지 않을 것
  - 그래도 근본적으로 이 조건이 빠져서 시간 초과가 나진 않을 듯함


### [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
#### [Conditionals](https://google.github.io/styleguide/cppguide.html#Conditionals)
* In an `if` statement, including its optional `else if` and `else` clauses, put one space between the `if` and the opening parenthesis, and between the closing parenthesis and the curly brace (if any), but no spaces between the parentheses and the condition or initializer. If the optional initializer is present, put a space or newline after the semicolon, but not before.
  - `if`문과 그 조건을 담을 괄호 사이엔 띄어쓰기가 있어야 한다.
  - 조건 괄호와 실행할 명령을 담을 중괄호 사이엔 띄어쓰기를 해야한다.
  - 조건 괄호는 조건과 붙어 있어야 한다.
  - 만약 `if`문의 조건 안에서 선언이 이루어지는 경우(if optional initializer is present) 세미콜론 이후에 띄어쓰기나 줄바꿈을 넣어야 한다.

  ```cpp
  if (int idx = findidx(); idx != 0) {
    a[n  - idx] = 1;
    continue;
  }
  ```

* Use curly braces for the controlled statements following `if`, `else if` and `else`. Break the line immediately after the opening brace, and immediately before the closing brace. A subsequent `else`, if any, appears on the same line as the preceding closing brace, separated by a space.
  - `else if`나 `else를` 넣는 경우 실행문이 길든 짧든 중괄호를 쓰라고 권함.
```cpp
if (condition) {                   // no spaces inside parentheses, space before brace
  DoOneThing();                    // two space indent
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // closing brace on new line, else on same line
  DoAThirdThing(a);
} else {
  DoNothing();
}
```

* 단, `if`만 쓰는 경우 들여쓰기나 중괄호 없이 작성을 허용함.

```cpp
if (x == kFoo) return new Foo();

if (x == kBar)
  return new Bar(arg1, arg2, arg3);

if (x == kQuz) { return new Quz(1, 2, 3); }
```


#### [Horizontal Whitespace](https://google.github.io/styleguide/cppguide.html#Horizontal_Whitespace)
* Operators
```cpp
// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x && !y)
  ...
```


#### [Type Names](https://google.github.io/styleguide/cppguide.html#Type_Names)
* Type names start with a capital letter and have a capital letter for each new word, with no underscores: MyExcitingClass, MyExcitingEnum.
  - 타입명은 대문자로 시작해서 새 단어 마다 대문자를 붙여준다(upper camel case)

* The names of all types — classes, structs, type aliases, enums, and type template parameters — have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:
  - 클래스, 구조체, 타입 별칭, 이넘, 타입에 활용되는 매개변수들은 동일한 명명 규칙을 따른다.

```cpp
// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, std::string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, std::string>;

// enums
enum class UrlTableError { ...
```

#### [Variable Names](https://google.github.io/styleguide/cppguide.html#Variable_Names)
* The names of variables (including function parameters) and data members are all lowercase, with underscores between words.
  - 변수명은 모두 소문자를 활용하되, 단어 사이에는 언더스코어(_)를 사용한다.

* Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.
  - 클래스의 로컬 변수들은 끝에 언더스코어(_)를 추가한다.


#### [Constant Names](https://google.github.io/styleguide/cppguide.html#Constant_Names)
* Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named with a leading "k" followed by mixed case. Underscores can be used as separators in the rare cases where capitalization cannot be used for separation
  - 상수명 첫번째 글자는 k를 붙인다.

* For example:
```cpp
const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
```

* All such variables with static storage duration (i.e., statics and globals, see [Storage Duration](https://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration) for details) should be named this way. This convention is optional for variables of other storage classes, e.g., automatic variables, otherwise the usual variable naming rules apply.
  - static storage duration 상의 변수들에 대해 이와 같이 명명한다. 그외 storage classes의 변수들은 일반적 변수명 규약에 따른다.
  - static stroage duration: 프로그램이 시작될 때 생성돼서 끝날 때 소멸되는 지속 시간을 의미함.


#### [Function Names](https://google.github.io/styleguide/cppguide.html#Function_Names)
* Regular functions have mixed case. Ordinarily, functions should start with a capital letter and have a capital letter for each new word.
  - 함수는 Upper camel case를 사용한다.

```cpp
AddTableEntry()
DeleteUrl()
OpenFileOrDie()
```

* (The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they're objects rather than functions is an unimportant implementation detail.)
  - API 일부로써 드러났고, 함수처럼 보이게 의도된 클래스 또는 네임스페이스 범위 상수들에도 적용된다.

Accessors and mutators (get and set functions) may be named like variables. These often correspond to actual member variables, but this is not required. For example, `int count()` and `void set_count(int count)`.
  - setter, getter는 일반 변수명처럼 선언한다.
  - `int count()` 또는 `void set_count(int count)`와 같이 써서 실질적 동작을 하는 함수와 구분함.


### BOJ step by step: 기하 2
#### [boj.kr/17386](../../../Problem%20Solving/boj/Math/17386-02-02-2023.cpp)
* 떠오르는 방법들을 서술해보자.

1. 벡터를 활용해서 두 선분의 평행 여부를 확인하고, 평행하지 않은 경우 두 직선의 교점을 구한다. 이후 x, y가 선분 범위에 들어오나 확인한다. `bool isintherange = (min(x1, x2) <= x && max(x1, x2) >= x);`