# **TIL on March 18th, 2023**
### Pick and solve
#### [boj.kr/14226](../../../Problem%20Solving/boj/random%20defense/14226-03-16-2023.cpp): solved on 1st try (memory: 17808 kB, time: 8 ms, Code length: 1152 B)
* const int MX = 3000정도면 연산횟수도 그렇게 많이 먹지 않고 찾아갈 수 있을 것이라 생각함. 2^12 = 4096이므로, 최대 12번의 연산이면 이모티콘 복사 붙여넣기 작업을 충분히 수행할 것.
* 클립보드에 있는 이모티콘 수가 문제임. 이 상태를 추적할 수 있도록 구현해야 함.
* 기저사례는 이모티콘 수가 s가 되었을 때.
* BFS 기반 풀이

#### [boj.kr/1449](../../../Problem%20Solving/boj/random%20defense/1449-03-18-2023.cpp)
* 물이 새는 곳이 1과 2라고 하자. 2짜리 테이프로 막는 방법을 생각하면 - 0.5부터 2.5까지 막으면 된다. 1부터 4까지라고 하면 0.5부터 4.5까지 막아야 하므로 길이 4가 필요. 이렇게 생각하면 [a, b]를 a 이상, b 이하라고 볼 때 테이프는 두 값에 포함되는 숫자 개수이상으로 길어야 한다.
* N도 L도 1000이하인 자연수
그러니, "1부터 1까지 막기"부터 시작해서 "1부터 1000까지 막기"까지를 시도할 수 있음.
마찬가지로 "2부터 2까지 막기"부터  "2부터 1000까지 막기"까지 할 수 있음.
이렇게 N^2에 대해서 가능한 분할 횟수를 판단하는 브루트포스 문제로 접근할 수 있을 듯함.
* i번째 고장난 위치부터 j번째 고장난 위치까지 테이프를 붙일 수 있는지 없는지 판단하는 건 항상 같은 결과를 반환하기 때문에, 아예 기록해버려도 됨. 이후에는 분할에 대한 판단만 하면 되는 것. 몇 개 구간으로 (i, j)를 묶을 수 있는가-

### Class 6 Problems | solved.ac
#### [boj.kr/11266](../../../Problem%20Solving/boj/solvedac/11266-03-18-2023.cpp)
* "제거 시 연결 컴포넌트 개수가 증가하는 정점"
  - 그러니 막 컴포넌트 총 개수가 2개 이상이라 해서 모든 정점이 단절점이 되는 건 아님.

#### [boj.kr/13023](../../../Problem%20Solving/boj/random%20defense/13023-03-16-2023.cpp)
* 길이가 5인 단순경로 찾기. 어떻게 깔끔한 풀이를 할 수 있을까?