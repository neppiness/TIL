# **TIL on January 27th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x18 그래프
#### [boj.kr/6118](../../../Problem%20Solving/boj/Graph/6118-01-27-2023.cpp): solved on 1st try (memory: 3760 kB, time: 16 ms, Code length: 761 B)
* "어떤 헛간에서 다른 헛간으로는 언제나 도달 가능"
* 1번 헛간에서의 거리가 멀어질수록 냄새 감소: 1번 헛간에서 가장 먼 곳을 찾으란 의미인 듯.
* 헛간 개수가 20,000개 밖에 안 되니까, 거리의 MX 값만 기록하고, 그 값을 가진 모든 노드를 기록한 표 상에서 찾으면 될 듯.

* PR용 해설은 아래와 같음.
```cpp
/*
BFS를 적용합니다.
dist 배열은 -1로 초기화해서 방문 배열의 역할도 수행합니다.

모든 노드를 순회한 뒤 dist 배열을 확인하며
가장 거리가 먼 헛간 번호와 그 거리,
동일 거리에 있는 헛간 수를 출력합니다.
*/
```


### BaaaaaaaarkingDog Practical Algo. Lecture: 0x1D 다익스트라 알고리즘
#### [boj.kr/20183](../../../Problem%20Solving/boj/Dijkstra%20algorithm/20183-re-01-27-2023.cpp): solved on 1st try (memory: 45384 kB, time: 1064 ms, Code length: 1149 B)
* 간선을 저장하는 벡터를 다음과 같이 설정
  - `vector<tuple<int, int, int>> e[MX + 2]; // e[node_no] = {cost, u, v}`
  - 파라메트릭 서치로 풀 수 있을 것 같음. 시간 복잡도를 계산해보자: 기억으로 다익스트라는 ElgE만큼 걸림. 여기에 lg10^14 = 46.5이기 때문에 연산량은 약 4억 4천만. 시간 제한이 5초나 되기 때문에 문제 없이 통과될 것(1억에 1초를 잡아도 무난함)
* 다익스트라 알고리즘에서 최단 거리 테이블을 무한으로 초기화하는 것을 깜빡함. 주의할 것.
* 그리고, 시작점에 인접한 간선에 대해 최단 거리 테이블 갱신할 때 제시한 상한 확인을 안 했음. 주의 바람.
  - 이건 구현 자체가 잘못돼서 그랬던 건데, 아래와 같이 구현하면 간단함.

```cpp
  dist[st] = 0;
  pq.push({0, st});
  while(!pq.empty()) {
    auto [co, cur] = pq.top(); pq.pop();
    if(dist[cur] != co) continue;
    for(auto [d, nxt] : adj[cur]) {
      if(d > lim) continue;
      d += co;
      if(dist[nxt] <= d) continue;
      dist[nxt] = d;
      pq.push({d, nxt});
    }
  }
```

* PR용 주석
```cpp
/*
최대 요금의 최솟값을 찾는 매개변수 탐색을 수행합니다(56-60번째 줄).

다익스트라 알고리즘을 통해 최단거리를 찾으면서
간선 비용 상한보다 큰 비용의 간선은 사용하지 않도록 구현합니다(30번째 줄).

다익스트라 알고리즘을 수행한 후,
목적지의 최소 비용과 가진 돈 C를 비교해
성공, 실패를 구분합니다(38-39번째 줄).
*/
```


### BOJ step by step: 동적 계획법 3
#### [boj.kr/11723](../../../Problem%20Solving/boj/Dynamic%20programming/11723-01-27-2023.cpp): solved on 1st try (memory: 2024 kB, time: 648 ms, Code length: 523 B)
* 비트마스크 기초라고 함. 어떻게 풀어야 할까?
* 20자리기 때문에, `vector<bool> v;`를 통해서 이 작업을 수행한다고 생각하자.
  - 사실 그러면 그냥 v[i]에 접근해서 조작하는 거랑 다를 게 없긴 함.

* 20자리이기 때문에, 32비트인 4바이트 정수로도 조작이 가능하다.
  - `add x`: true와 OR를 수행해서, 있든 없든 해당 자리를 켤 수 있음.
  - `remove x`: false와 AND를 수행해서 있든 없든 해당 자리를 끌 수 있음.
    * `~(1 << x)` 와 AND 연산을 수행하면, 해당 자리를 끌 수 있다.
  - `check x`: true와 AND를 수행하면 켜져 있는지 꺼져 있는지 확인할 수 있음.
  - `toggle x`: 해당 비트에만 NOT 연산을 할 수 있을까?
  - `all`: int 값을 20비트 부호 없는 정수 최댓값인 2^20-1로 대체: 1'048'575이며, (1 << 20) - 1로 계산 가능.
  - `empty`: int 값을 모든 비트가 꺼진 상태인 0으로 대체

* toggle 구현을 생각해보자
  - XOR을 활용한다: 두 비트의 상태가 다르면 1, 같으면 0이다.
  - `(1 << x)`를 통해서 얻은 정수의 경우, 비트가 켜져있는 상태이다. 따라서;
    1. 확인할 정수의 해당 비트 자리가 켜져 있으면 둘 다 켜져있기 때문에 0으로 만든다.
    2. 확인할 정수의 해당 비트 자리가 꺼져 있으면 둘의 상태가 다르기 때문에 1로 만든다.
  - 이로써 현 상태를 변경시킬 수 있다.

* 속도 향상은 8% 정도 됐음. 특별히 이런 비트마스크가 반드시 필요할 때가 있을지 의문이 생김.