# **TIL on May 27th, 2023**

### Random Defense Using C++
#### [BOJ #16197](/Problem%20Solving/boj/random%20defense/16197-05-27-2023.cpp): solved on 1st try (memory: 2020 kB, time: 296 ms, Code length: 1941 B)
* 4^10이 백만 정도라서 모든 명령 조합을 다 확인하는 방식으로 풀이 가능함.
* 위치 추적을 안 하면 굉장히 비효율적인 코드가 나옴
  - 두 동전의 위치를 기록하면서 넘겨줘야 함.
* 1번째 제출 WA. OOB 확인 안 하고 배열에 접근했음.


#### [BOJ #13904](/Problem%20Solving/boj/random%20defense/13904-05-27-2023.cpp): solved on 1st try (memory: 2032 kB, time: 0 ms, Code length: 843 B)
* i일 째에 최대 점수를 택하지 않는 것이 i + 1일의 최대 점수로 이어질 수가 있나?: true
  - 간단하게, 3일 째에 점수가 100인 과제가 있다고 하고, 1일째에 점수가 2인 과제가 있다고 하자. 1일 째에 만들 수 있는 최대 점수는 100점이지만, 3일 째까지 만들 수 있는 최대 점수는 102임. 그리고 최대 점수를 만들기 위해선 1일 째에 2점을 택해야 한다.
* 이전까지 얻은 최고 점수를 계속 들고 가는 게 중요한 게 아님.
* 선택한 과제의 상태를 무엇으로 기록할 수 있나?

* i일 째에 취할 수 있는 것: 지금까지 수행하지 않았던 과제 하나를 수행하거나, 과제를 포기하거나.
  - 이는 n개의 과제가 있다고 할 때 인덱스를 0부터 n - 1까지 활용하게 될 것이니, -1을 선택하면 과제를 안 하게 되는 걸로 구현해도 될 듯함.

* 이제 역으로, 주어진 날 중 마지막 날이라고 하자. 이때는 현재 할 수 있는 과제 중 점수가 가장 큰 과제를 하는 게 옳은 선택인가?
  - `2 / 1 2 / 3 100`이라고 하면 3일 째에 100을 선택하게 됨.
  - 점수를 먹고 넘어간다고 하자. 그러면 선택된 상태는 어떻게 기록하지? 선택한 것이든 버린 것이든 확인할 인덱스를 넘겨주면서 볼까?

* cmp 함수를 직접 구현했지만, 사실 vector로 선언하면 무난히 역정렬이 가능함: `sort(hw.rbegin(), hw.rend());`


#### [BOJ #1562](/Problem%20Solving/boj/random%20defense/1562-05-27-2023.cpp): solved on 1st try (memory: 6104 kB, time: 0 ms, Code length: 762 B)
* 앞에 선택된 수가 뭔지만 기록하고, 그것이 몇 번째 수인지 기록하면 그 이후의 경우의 수를 저장할 수 있음. 0부터 9까지 수가 모두 등장해야하므로, 이 상태만 마스킹해서 넘겨줄 것.


#### [BOJ #18244](/Problem%20Solving/boj/random%20defense/18244-05-27-2023.cpp): solved on 1st try (memory: 2040 kB, time: 0 ms, Code length: 826 B)
* 증가 감소 횟수만 잘 기록해서 현 상태로 넘겨주면 풀 수 있음.


#### [BOJ #2342](/Problem%20Solving/boj/random%20defense/2342-05-27-2023.cpp): solved on 1st try (memory: 19868 kB, time: 12 ms, Code length: 1024 B)
* 같은 지점을 연속해서 누를 때는 1의 힘을 사용함.
  - 이전까지 어떻게 눌렀는지가 상관이 없음.
  - 발의 위치를 기록해야 할 것. x번째를 누를 때 발의 위치가 i, j라면 이후 얻을 수 있는 최소 힘을 구하는 함수를 정의하자.
  - 오른발을 옮기는 경우와 왼발을 옮기는 경우로 구분할 것.