# **TIL on March 8th, 2023**
### BaaaaaaaarkingDog Practical Algo. Lecture: 0x0D 시뮬레이션
#### [boj.kr/17779](../../../Problem%20Solving/boj/Simulation/17779-03-07-2023.cpp)
* 문제 조건에 따라 5번 선거구를 표시함.
  - 1번 구역은 (1, 1)을 반드시 포함하도록 설정되기 때문에 여기서부터 bfs로 구역을 채워도 무방할 것으로 판단됨.
  - 그렇게 확산하면서 oob 조건에 경계조건을 부여하면 됨. 이후 인구 수를 세고, 가장 많은 인구를 갖는 선거구의 인구 수와 가장 적은 인구를 갖는 선거구의 인구 수 차이를 구하면 됨.
* 모든 경우의 수를 다 확인하는 경우, x, y와 d1, d2를 어떻게 설정할지 판단해보자.
  - y는 1보다 크거나 같고 N보다 작아야 함.
* 직접 그래프로 그려보고 판단하는 게 더 좋을 것 같긴 함.
<br>

### 단계별로 풀어보기 | 백준: 기하 2
#### [boj.kr/1069](../../../Problem%20Solving/boj/Math/1069-03-08-2023.cpp): solved on 1st try (memory: 2032 kB, time: 0 ms, Code length: 831 B)
* 집`(0, 0)`에서 은진이 위치`(X, Y)`까지의 거리는 `hypot(X, Y)`로 구할 수 있음. 아래 식을 푸는 문제가 된다.
  - hypot(X, Y) = nD + m일 때, nT + |m|의 최솟값(단, n은 정수, m은 벡터).
  - 이 의미는 거리가 D인 점프를 n번하는 경우를 표현하는 것이다. 그 경우, 시간은 nT만큼 소요된다.
* 벡터를 활용해 문제를 구현할 수 있을 듯함.
  - (X, Y)의 방향벡터를 취하고, 이에 대한 D를 곱해 점프 벡터를 만든다. (X, Y)의 방향 벡터를 (x, y)라고 하자. 이 경우 점프 벡터는 (Dx, Dy)가 된다.
* n은 0부터 2000까지 두고 직접 다 계산해보자. 별다른 최적화 방법이 떠오르지 않음.
  - $nT + \sqrt{(X - nDx)^2 + (Y - nDy)^2}$의 최솟값을 찾는 문제.
* 이렇게 보는 경우, 예제 6번의 답을 낼 수 없음. 이는 거리 1000의 점프를 두 번 해서 10, 10에서 0, 0으로 가는 방법임.
  - 직선 거리가 nD 이하인 경우에 대해 모두 nT 시간으로 접근이 가능하다.
  - 위 로직에서 nD가 hypot(X, Y)를 넘는 경우 nT 시간도 최솟값으로 고려하도록 수정하면 될 듯함.
  - 단, 한 번의 점프로는 안 되고, 두 번 이상의 점프를 하는 경우에만 해당됨.
<br>

### Practice
#### [boj.kr/2527](../../../Problem%20Solving/boj/Math/2527-03-08-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 1088 B)
* x축 선분, y축 선분의 위치 관계를 잘 활용하면 편하게 경우를 나눌 수 있는 문제.
  - 직사각형 1은 (a, b)와 (c, d)로 이루어지고, 직사각형 2는 (e, f)와 (g, h)로 이루어진다고 하자.
  - 직사각형 1의 x범위는 a ≤ x ≤ c이고, 직사각형 2의 x범위는 e ≤ x ≤ g가 된다. 따라서 이 선분에 대한 위치 관계를 생각해보자.

* 직사각형 1의 x범위를 선분 AC, 직사각형 2의 x범위를 선분 EG라고 하자. AC와 EG는 아래와 같은 위치 관계를 갖는다.
  1. 만나지 않는다: c < b || d < a
  2. 한 점에서 만난다: c == b || d == a
  3. 두 선분이 선분으로 겹친다: 그외

* 마찬가지로 직사각형 1의 y범위를 선분 BD, 직사각형 2의 y범위를 선분 FH라고 하자. 이 선분들의 위치 관계와 x범위들의 위치 관계를 조합하면 직사각형의 위치 관계를 도출할 수 있다.
  - 코드 a. 직사각형: x범위가 포함되고 y범위가 포함됨
  - 코드 b. 선분: x범위가 포함되고 y범위가 점에서 만나거나 그 반대
  - 코드 c. 점: x범위가 점에서 만나고, y범위가 점에서 만난다.
  - 코드 d. 공통 부분이 없음: x범위가 만나지 않고, y범위가 만나지 않는다.

#### [boj.kr/2527](../../../Problem%20Solving/boj/Math/15973-03-08-2023.cpp): solved on 1st try (memory: 2020 kB, time: 0 ms, Code length: 1034 B)
* 위 문제에서 제약 조건을 없앤 문제. 출력 형식만 약간 수정하면 됨.
* 난이도는 위 문제와 동일함.
<br>

### S3 to G3 Problems
#### [boj.kr/1069](../../../Problem%20Solving/boj/random%20defense/1138-03-08-2023.cpp): solved on 1st try (memory: 2020 kB, time: 24 ms, Code length: 644 B)
* 10!에 대해 전부 확인해보는 단순한 문제.
<br>

### 단계별로 풀어보기 | 백준: 최소 공통 조상
#### [boj.kr/3584](../../../Problem%20Solving/boj/Tree/3584-03-08-2023.cpp): solved on 1st try (memory: 2068 kB, time: 4 ms, Code length: 573 B)
* 최소 공통 조상 입문 문제. 부모 노드를 세팅하고, 한 노드에서부터 거슬러 올라가며 노드들을 방문 처리. 이후 다른 노드에서 거슬러 올라가며 방문 처리된 노드를 만나면 이를 반환하는 풀이.

#### [boj.kr/17435](../../../Problem%20Solving/boj/Tree/17435-03-08-2023.cpp): solved on 1st try (memory: 19208 kB, time: 272 ms, Code length: 672 B)
* 최소 공통 조상 문제에 적용하기 전 sparse table 개념을 배우는 문제.
  - 먼저 희소 테이블을 공부하자.

* [희소 테이블(Sparse Table) (수정: 2019-11-16)](https://m.blog.naver.com/kks227/220793361738)
  - 희소 테이블(sparse table): 공간 안에 상대적으로 굉장히 적은 양의 값만 존재한다.
  - 모든 정점의 나가는 간선이 정확히 1개인 유향 그래프가 있다고 하자. 임의의 정점에서 시작해서 k회 간선을 타고 이동한다면 그 도착점은 유일하게 결정됨. 한 번씩, 한 번씩 이동해서 k회 이동을 수행할 수도 있지만, k가 굉장히 크면 연산량이 매우 많음.
  - 1번, 2번, 4번, 8번, 16번, ..., 2^n번 이동하는 배열을 인덱스 1, 2, 3, 4, ..., n까지 만들어두는 방법을 생각할 수 있음. 이 경우, 최대 M회 이동을 수행하는 문제에 대해 lgM번 연산으로 파악할 수 있음.
  - 이 배열을 통해 k회 이동 시 k의 켜진 비트들에 해당하는 이동을 수행하면 됨. k = 13이라면 이진수로 나타내었을 때 "1101(2)"이므로, 켜져 있는 비트에 해당하는 1칸, 4칸, 8칸 이렇게 총 3회 이동하면 됨.
  - 구현 예시는 아래와 같음.
  
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int MAX = 500001;
const int MAX_D = 19; // 2^k >= MAX인 최소의 k
 
int main(){
  // next[i][j] = 정점 i에서 2^j번 이동한 후의 정점
  int M, next[MAX][MAX_D];

  scanf("%d", &M);
  for(int i = 1; i <= M; ++i)
    scanf("%d", &next[i][0]);

  // 작은 j부터 배열을 채워가면서 전체 배열을 채울 수 있다.
  // i에서 2^(j+1)번 이동한 후의 정점은 i에서 2^j번*2번 이동하는 것
  // next[i][j+1] = next[ next[i][j] ][j]
  for(int j = 1; j < MAX_D; ++j)
    for(int i = 1; i <= M; ++i)
      next[i][j] = next[ next[i][j-1] ][j-1];

  // 쿼리 처리
  int Q;
  scanf("%d", &Q);
  for(int i = 0; i < Q; ++i){
    int n, x;
    scanf("%d %d", &n, &x);
    // 켜져 있는 비트에 해당하는 배열만 사용해서 건너뛴다.
    for(int j = MAX_D-1; j >= 0; --j){
        if(n >= 1<<j){
          n -= 1<<j;
          x = next[x][j];
        }
    }
    // 결과 출력
    printf("%d\n", x);
  }
}
```